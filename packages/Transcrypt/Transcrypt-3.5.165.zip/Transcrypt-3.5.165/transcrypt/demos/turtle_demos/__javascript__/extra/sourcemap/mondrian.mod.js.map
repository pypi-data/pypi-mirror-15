{
	"version": 3,
	"file": "D:/activ_tosh/geatec/transcrypt/transcrypt/demos/turtle_demos/__javascript__/mondrian.mod.js",
	"sources": [
		"D:/activ_tosh/geatec/transcrypt/transcrypt/demos/turtle_demos/mondrian.py"
	],
	"sourcesContent": [
		"import turtle as turtle_graphics\nimport random\n\nclass Bounds:\n\tdef __init__ (self, x, y, width, height):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.width = width\n\t\tself.height = height\n\nBORDER_COLOR = 'black'  # so you can add 'black' to COLORS below\n\nBORDER_WIDTH = 10\n\nMINIMUM_DIVISIBLE_PORTION = .2\t# limits recursion\n\nCOLORS = ('white', 'white', 'red', 'white', 'blue', 'yellow')  # multiple 'white' to increase probability\n\nPICTURE_BOUNDS = Bounds(x=-250, y=-300, width=500, height=600)\n\ndef fill_rectangle(turtle, bounds, color=BORDER_COLOR):\n\t\"\"\" Fill a rectangle with the border color (by default) and then fill the center with a bright color \"\"\"\n\tturtle.up()\n\tturtle.goto(bounds.x, bounds.y)\n\tturtle.color(color)\n\tturtle.down()\n\tturtle.begin_fill()\n\tfor _ in range(2):\n\t\tturtle.forward(bounds.width)\n\t\tturtle.left(90)\n\t\tturtle.forward(bounds.height)\n\t\tturtle.left(90)\n\tturtle.end_fill()\n\tturtle.up()\n\n\tif color == BORDER_COLOR:\n\t\tfill_rectangle(turtle, Bounds(bounds.x + BORDER_WIDTH, bounds.y + BORDER_WIDTH, bounds.width - BORDER_WIDTH*2, bounds.height - BORDER_WIDTH*2), random.choice(COLORS))\n\n\ndef mondrian(piet, bounds):\n\t\"\"\" Divide, fill and divide & fill some more.  Intuitively and recursively \"\"\"\n\n\tif bounds.width < bounds.height:\n\t\trandom_dimension = random.randint (bounds.height // 5, 2 * bounds.height // 3)\n\t\tbounds_yin = Bounds(bounds.x, bounds.y + random_dimension, bounds.width, bounds.height - random_dimension)\n\t\tbounds_yang = Bounds(bounds.x, bounds.y, bounds.width, random_dimension)\n\t\t\n\t\tif bounds_yin.height > bounds_yang.height:\n\t\t\tbounds_paint, bounds_divide = bounds_yang, bounds_yin\n\t\telse:\n\t\t\tbounds_paint, bounds_divide = bounds_yin, bounds_yang\n\n\t\tprint (111, bounds_paint)\n\t\tfill_rectangle(piet, bounds_paint)\n\n\t\tif bounds_divide.height < MINIMUM_DIVISIBLE_PORTION * PICTURE_BOUNDS.height:\n\t\t\tfill_rectangle(piet, bounds_divide)\n\t\telse:\n\t\t\tpass\n\t\t\t# mondrian(piet, bounds_divide)\n\telse:\n\t\trandom_dimension = random.randint(bounds.width // 5, 2 * bounds.width // 3)\n\t\tbounds_yin = Bounds(bounds.x, bounds.y, random_dimension, bounds.height)\n\t\tbounds_yang = Bounds(bounds.x + random_dimension, bounds.y, bounds.width - random_dimension, bounds.height)\n\t\tif bounds_yin.width > bounds_yang.width:\n\t\t\tbounds_paint, bounds_divide = bounds_yang, bounds_yin\n\t\telse:\n\t\t\tbounds_paint, bounds_divide = bounds_yin, bounds_yang\n\n\t\tprint (222, bounds_paint)\n\t\tfill_rectangle(piet, bounds_paint)\n\n\t\tif bounds_divide.width < MINIMUM_DIVISIBLE_PORTION * PICTURE_BOUNDS.width:\n\t\t\tfill_rectangle(piet, bounds_divide)\n\t\telse:\n\t\t\tpass\n\t\t\t#mondrian(piet, bounds_divide)\n\n\ndef paint_canvas(dummy_x=0, dummy_y=0):\n\t\"\"\" Runs the program and can be used as an event handler \"\"\"\n\t#fill_rectangle(turtle_graphics, PICTURE_BOUNDS, 'black')\n\tmondrian(turtle_graphics, PICTURE_BOUNDS)\n\npaint_canvas()\n"
	],
	"mappings": "AAAA;AAwFA;AApFA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}