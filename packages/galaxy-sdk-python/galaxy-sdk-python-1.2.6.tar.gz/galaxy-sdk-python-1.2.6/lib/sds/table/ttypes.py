# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import sds.errors.ttypes
import sds.common.ttypes
import sds.auth.ttypes
import rpc.authorization.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class DataType(object):
  """
  数据类型
  """
  BOOL = 1
  INT8 = 2
  INT16 = 3
  INT32 = 4
  INT64 = 5
  FLOAT = 6
  DOUBLE = 7
  STRING = 8
  BINARY = 9
  RAWBINARY = 10
  BOOL_SET = 100
  INT8_SET = 101
  INT16_SET = 102
  INT32_SET = 103
  INT64_SET = 104
  FLOAT_SET = 105
  DOUBLE_SET = 106
  STRING_SET = 107
  BINARY_SET = 108

  _VALUES_TO_NAMES = {
    1: "BOOL",
    2: "INT8",
    3: "INT16",
    4: "INT32",
    5: "INT64",
    6: "FLOAT",
    7: "DOUBLE",
    8: "STRING",
    9: "BINARY",
    10: "RAWBINARY",
    100: "BOOL_SET",
    101: "INT8_SET",
    102: "INT16_SET",
    103: "INT32_SET",
    104: "INT64_SET",
    105: "FLOAT_SET",
    106: "DOUBLE_SET",
    107: "STRING_SET",
    108: "BINARY_SET",
  }

  _NAMES_TO_VALUES = {
    "BOOL": 1,
    "INT8": 2,
    "INT16": 3,
    "INT32": 4,
    "INT64": 5,
    "FLOAT": 6,
    "DOUBLE": 7,
    "STRING": 8,
    "BINARY": 9,
    "RAWBINARY": 10,
    "BOOL_SET": 100,
    "INT8_SET": 101,
    "INT16_SET": 102,
    "INT32_SET": 103,
    "INT64_SET": 104,
    "FLOAT_SET": 105,
    "DOUBLE_SET": 106,
    "STRING_SET": 107,
    "BINARY_SET": 108,
  }

class OperatorType(object):
  """
  操作符类型
  """
  EQUAL = 1
  NOT_EQUAL = 2
  GREATER = 3
  GREATER_OR_EQUAL = 4
  LESS = 5
  LESS_OR_EQUAL = 6

  _VALUES_TO_NAMES = {
    1: "EQUAL",
    2: "NOT_EQUAL",
    3: "GREATER",
    4: "GREATER_OR_EQUAL",
    5: "LESS",
    6: "LESS_OR_EQUAL",
  }

  _NAMES_TO_VALUES = {
    "EQUAL": 1,
    "NOT_EQUAL": 2,
    "GREATER": 3,
    "GREATER_OR_EQUAL": 4,
    "LESS": 5,
    "LESS_OR_EQUAL": 6,
  }

class SecondaryIndexConsistencyMode(object):
  """
  索引数据一致性类型
  """
  LAZY = 0
  EAGER = 1
  IMMUTABLE = 2

  _VALUES_TO_NAMES = {
    0: "LAZY",
    1: "EAGER",
    2: "IMMUTABLE",
  }

  _NAMES_TO_VALUES = {
    "LAZY": 0,
    "EAGER": 1,
    "IMMUTABLE": 2,
  }

class CannedAcl(object):
  """
  ACL模板，针对每个应用进行设置，
  开发者登录可以访问所拥有的表数据，无需额外设置
  """
  APP_SECRET_READ = 1
  APP_SECRET_WRITE = 2
  APP_USER_ENTITY_GROUP_READ = 3
  APP_USER_ENTITY_GROUP_WRITE = 4
  APP_USER_READ = 5
  APP_USER_WRITE = 6
  PUBLIC_READ = 7
  PUBLIC_WRITE = 8

  _VALUES_TO_NAMES = {
    1: "APP_SECRET_READ",
    2: "APP_SECRET_WRITE",
    3: "APP_USER_ENTITY_GROUP_READ",
    4: "APP_USER_ENTITY_GROUP_WRITE",
    5: "APP_USER_READ",
    6: "APP_USER_WRITE",
    7: "PUBLIC_READ",
    8: "PUBLIC_WRITE",
  }

  _NAMES_TO_VALUES = {
    "APP_SECRET_READ": 1,
    "APP_SECRET_WRITE": 2,
    "APP_USER_ENTITY_GROUP_READ": 3,
    "APP_USER_ENTITY_GROUP_WRITE": 4,
    "APP_USER_READ": 5,
    "APP_USER_WRITE": 6,
    "PUBLIC_READ": 7,
    "PUBLIC_WRITE": 8,
  }

class TableState(object):
  """
  表状态
  """
  CREATING = 1
  ENABLING = 2
  ENABLED = 3
  DISABLING = 4
  DISABLED = 5
  DELETING = 6
  DELETED = 7
  LAZY_DELETE = 8
  RENAMING = 9

  _VALUES_TO_NAMES = {
    1: "CREATING",
    2: "ENABLING",
    3: "ENABLED",
    4: "DISABLING",
    5: "DISABLED",
    6: "DELETING",
    7: "DELETED",
    8: "LAZY_DELETE",
    9: "RENAMING",
  }

  _NAMES_TO_VALUES = {
    "CREATING": 1,
    "ENABLING": 2,
    "ENABLED": 3,
    "DISABLING": 4,
    "DISABLED": 5,
    "DELETING": 6,
    "DELETED": 7,
    "LAZY_DELETE": 8,
    "RENAMING": 9,
  }

class SnapshotState(object):
  """
  快照状态
  """
  ENABLED = 1
  INPROGRESS = 2

  _VALUES_TO_NAMES = {
    1: "ENABLED",
    2: "INPROGRESS",
  }

  _NAMES_TO_VALUES = {
    "ENABLED": 1,
    "INPROGRESS": 2,
  }

class ScanOp(object):
  COUNT = 0
  DELETE = 1
  UPDATE = 2

  _VALUES_TO_NAMES = {
    0: "COUNT",
    1: "DELETE",
    2: "UPDATE",
  }

  _NAMES_TO_VALUES = {
    "COUNT": 0,
    "DELETE": 1,
    "UPDATE": 2,
  }

class BatchOp(object):
  GET = 1
  PUT = 2
  INCREMENT = 3
  REMOVE = 4

  _VALUES_TO_NAMES = {
    1: "GET",
    2: "PUT",
    3: "INCREMENT",
    4: "REMOVE",
  }

  _NAMES_TO_VALUES = {
    "GET": 1,
    "PUT": 2,
    "INCREMENT": 3,
    "REMOVE": 4,
  }

class EditType(object):
  """
  增量操作类型
  """
  PUT = 1
  DELETE = 2

  _VALUES_TO_NAMES = {
    1: "PUT",
    2: "DELETE",
  }

  _NAMES_TO_VALUES = {
    "PUT": 1,
    "DELETE": 2,
  }


class Value(object):
  """
  数据值union类型

  Attributes:
   - boolValue
   - int8Value
   - int16Value
   - int32Value
   - int64Value
   - doubleValue: 用于FLOAT/DOUBLE类型
   - stringValue
   - binaryValue: 用于BINARY/RAWBINARY类型
   - boolSetValue
   - int8SetValue
   - int16SetValue
   - int32SetValue
   - int64SetValue
   - doubleSetValue: 用于FLOAT/DOUBLE类型集合
   - stringSetValue
   - binarySetValue
   - nullValue: null，只用于RC_BASIC存储格式
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'boolValue', None, None, ), # 1
    (2, TType.BYTE, 'int8Value', None, None, ), # 2
    (3, TType.I16, 'int16Value', None, None, ), # 3
    (4, TType.I32, 'int32Value', None, None, ), # 4
    (5, TType.I64, 'int64Value', None, None, ), # 5
    (6, TType.DOUBLE, 'doubleValue', None, None, ), # 6
    (7, TType.STRING, 'stringValue', None, None, ), # 7
    (8, TType.STRING, 'binaryValue', None, None, ), # 8
    (9, TType.LIST, 'boolSetValue', (TType.BOOL,None), None, ), # 9
    (10, TType.LIST, 'int8SetValue', (TType.BYTE,None), None, ), # 10
    (11, TType.LIST, 'int16SetValue', (TType.I16,None), None, ), # 11
    (12, TType.LIST, 'int32SetValue', (TType.I32,None), None, ), # 12
    (13, TType.LIST, 'int64SetValue', (TType.I64,None), None, ), # 13
    (14, TType.LIST, 'doubleSetValue', (TType.DOUBLE,None), None, ), # 14
    (15, TType.LIST, 'stringSetValue', (TType.STRING,None), None, ), # 15
    (16, TType.LIST, 'binarySetValue', (TType.STRING,None), None, ), # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.BOOL, 'nullValue', None, None, ), # 20
  )

  def __init__(self, boolValue=None, int8Value=None, int16Value=None, int32Value=None, int64Value=None, doubleValue=None, stringValue=None, binaryValue=None, boolSetValue=None, int8SetValue=None, int16SetValue=None, int32SetValue=None, int64SetValue=None, doubleSetValue=None, stringSetValue=None, binarySetValue=None, nullValue=None,):
    self.boolValue = boolValue
    self.int8Value = int8Value
    self.int16Value = int16Value
    self.int32Value = int32Value
    self.int64Value = int64Value
    self.doubleValue = doubleValue
    self.stringValue = stringValue
    self.binaryValue = binaryValue
    self.boolSetValue = boolSetValue
    self.int8SetValue = int8SetValue
    self.int16SetValue = int16SetValue
    self.int32SetValue = int32SetValue
    self.int64SetValue = int64SetValue
    self.doubleSetValue = doubleSetValue
    self.stringSetValue = stringSetValue
    self.binarySetValue = binarySetValue
    self.nullValue = nullValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.boolValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.int8Value = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.int16Value = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int32Value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.int64Value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.doubleValue = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.boolSetValue = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readBool();
            self.boolSetValue.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.int8SetValue = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readByte();
            self.int8SetValue.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.int16SetValue = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readI16();
            self.int16SetValue.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.int32SetValue = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = iprot.readI32();
            self.int32SetValue.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.int64SetValue = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = iprot.readI64();
            self.int64SetValue.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.doubleSetValue = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readDouble();
            self.doubleSetValue.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.stringSetValue = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.stringSetValue.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.binarySetValue = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.binarySetValue.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.nullValue = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Value')
    if self.boolValue is not None:
      oprot.writeFieldBegin('boolValue', TType.BOOL, 1)
      oprot.writeBool(self.boolValue)
      oprot.writeFieldEnd()
    if self.int8Value is not None:
      oprot.writeFieldBegin('int8Value', TType.BYTE, 2)
      oprot.writeByte(self.int8Value)
      oprot.writeFieldEnd()
    if self.int16Value is not None:
      oprot.writeFieldBegin('int16Value', TType.I16, 3)
      oprot.writeI16(self.int16Value)
      oprot.writeFieldEnd()
    if self.int32Value is not None:
      oprot.writeFieldBegin('int32Value', TType.I32, 4)
      oprot.writeI32(self.int32Value)
      oprot.writeFieldEnd()
    if self.int64Value is not None:
      oprot.writeFieldBegin('int64Value', TType.I64, 5)
      oprot.writeI64(self.int64Value)
      oprot.writeFieldEnd()
    if self.doubleValue is not None:
      oprot.writeFieldBegin('doubleValue', TType.DOUBLE, 6)
      oprot.writeDouble(self.doubleValue)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 7)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.binaryValue is not None:
      oprot.writeFieldBegin('binaryValue', TType.STRING, 8)
      oprot.writeString(self.binaryValue)
      oprot.writeFieldEnd()
    if self.boolSetValue is not None:
      oprot.writeFieldBegin('boolSetValue', TType.LIST, 9)
      oprot.writeListBegin(TType.BOOL, len(self.boolSetValue))
      for iter48 in self.boolSetValue:
        oprot.writeBool(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int8SetValue is not None:
      oprot.writeFieldBegin('int8SetValue', TType.LIST, 10)
      oprot.writeListBegin(TType.BYTE, len(self.int8SetValue))
      for iter49 in self.int8SetValue:
        oprot.writeByte(iter49)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int16SetValue is not None:
      oprot.writeFieldBegin('int16SetValue', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.int16SetValue))
      for iter50 in self.int16SetValue:
        oprot.writeI16(iter50)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int32SetValue is not None:
      oprot.writeFieldBegin('int32SetValue', TType.LIST, 12)
      oprot.writeListBegin(TType.I32, len(self.int32SetValue))
      for iter51 in self.int32SetValue:
        oprot.writeI32(iter51)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.int64SetValue is not None:
      oprot.writeFieldBegin('int64SetValue', TType.LIST, 13)
      oprot.writeListBegin(TType.I64, len(self.int64SetValue))
      for iter52 in self.int64SetValue:
        oprot.writeI64(iter52)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.doubleSetValue is not None:
      oprot.writeFieldBegin('doubleSetValue', TType.LIST, 14)
      oprot.writeListBegin(TType.DOUBLE, len(self.doubleSetValue))
      for iter53 in self.doubleSetValue:
        oprot.writeDouble(iter53)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stringSetValue is not None:
      oprot.writeFieldBegin('stringSetValue', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.stringSetValue))
      for iter54 in self.stringSetValue:
        oprot.writeString(iter54)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.binarySetValue is not None:
      oprot.writeFieldBegin('binarySetValue', TType.LIST, 16)
      oprot.writeListBegin(TType.STRING, len(self.binarySetValue))
      for iter55 in self.binarySetValue:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nullValue is not None:
      oprot.writeFieldBegin('nullValue', TType.BOOL, 20)
      oprot.writeBool(self.nullValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.boolValue)
    value = (value * 31) ^ hash(self.int8Value)
    value = (value * 31) ^ hash(self.int16Value)
    value = (value * 31) ^ hash(self.int32Value)
    value = (value * 31) ^ hash(self.int64Value)
    value = (value * 31) ^ hash(self.doubleValue)
    value = (value * 31) ^ hash(self.stringValue)
    value = (value * 31) ^ hash(self.binaryValue)
    value = (value * 31) ^ hash(self.boolSetValue)
    value = (value * 31) ^ hash(self.int8SetValue)
    value = (value * 31) ^ hash(self.int16SetValue)
    value = (value * 31) ^ hash(self.int32SetValue)
    value = (value * 31) ^ hash(self.int64SetValue)
    value = (value * 31) ^ hash(self.doubleSetValue)
    value = (value * 31) ^ hash(self.stringSetValue)
    value = (value * 31) ^ hash(self.binarySetValue)
    value = (value * 31) ^ hash(self.nullValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Datum(object):
  """
  数据单元

  Attributes:
   - type
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'value', (Value, Value.thrift_spec), None, ), # 2
  )

  def __init__(self, type=None, value=None,):
    self.type = type
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = Value()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Datum')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvisionThroughput(object):
  """
  吞吐量配额

  Attributes:
   - readCapacity
   - writeCapacity
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'readCapacity', None, None, ), # 1
    (2, TType.I64, 'writeCapacity', None, None, ), # 2
  )

  def __init__(self, readCapacity=None, writeCapacity=None,):
    self.readCapacity = readCapacity
    self.writeCapacity = writeCapacity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.readCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.writeCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvisionThroughput')
    if self.readCapacity is not None:
      oprot.writeFieldBegin('readCapacity', TType.I64, 1)
      oprot.writeI64(self.readCapacity)
      oprot.writeFieldEnd()
    if self.writeCapacity is not None:
      oprot.writeFieldBegin('writeCapacity', TType.I64, 2)
      oprot.writeI64(self.writeCapacity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.readCapacity)
    value = (value * 31) ^ hash(self.writeCapacity)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableQuota(object):
  """
  空间配额

  Attributes:
   - size: 空间配额，单位为字节
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'size', None, None, ), # 1
  )

  def __init__(self, size=None,):
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableQuota')
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 1)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.size)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class KeySpec(object):
  """
  Attributes:
   - attribute
   - asc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'attribute', None, None, ), # 1
    (2, TType.BOOL, 'asc', None, True, ), # 2
  )

  def __init__(self, attribute=None, asc=thrift_spec[2][4],):
    self.attribute = attribute
    self.asc = asc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.attribute = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.asc = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('KeySpec')
    if self.attribute is not None:
      oprot.writeFieldBegin('attribute', TType.STRING, 1)
      oprot.writeString(self.attribute)
      oprot.writeFieldEnd()
    if self.asc is not None:
      oprot.writeFieldBegin('asc', TType.BOOL, 2)
      oprot.writeBool(self.asc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.attribute)
    value = (value * 31) ^ hash(self.asc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LocalSecondaryIndexSpec(object):
  """
  局部二级索引定义

  Attributes:
   - indexSchema: 索引定义
   - projections: 映射的属性，仅当索引类型为Eager时才可设置
   - consistencyMode: 索引数据一致性模式
   - unique: 是否为唯一索引
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'indexSchema', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'projections', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'consistencyMode', None,     0, ), # 3
    (4, TType.BOOL, 'unique', None, False, ), # 4
  )

  def __init__(self, indexSchema=None, projections=None, consistencyMode=thrift_spec[3][4], unique=thrift_spec[4][4],):
    self.indexSchema = indexSchema
    self.projections = projections
    self.consistencyMode = consistencyMode
    self.unique = unique

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.indexSchema = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = KeySpec()
            _elem61.read(iprot)
            self.indexSchema.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.projections = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readString();
            self.projections.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.consistencyMode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.unique = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LocalSecondaryIndexSpec')
    if self.indexSchema is not None:
      oprot.writeFieldBegin('indexSchema', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.indexSchema))
      for iter68 in self.indexSchema:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.projections is not None:
      oprot.writeFieldBegin('projections', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.projections))
      for iter69 in self.projections:
        oprot.writeString(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.consistencyMode is not None:
      oprot.writeFieldBegin('consistencyMode', TType.I32, 3)
      oprot.writeI32(self.consistencyMode)
      oprot.writeFieldEnd()
    if self.unique is not None:
      oprot.writeFieldBegin('unique', TType.BOOL, 4)
      oprot.writeBool(self.unique)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.indexSchema)
    value = (value * 31) ^ hash(self.projections)
    value = (value * 31) ^ hash(self.consistencyMode)
    value = (value * 31) ^ hash(self.unique)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EntityGroupSpec(object):
  """
  EntityGroup定义

  Attributes:
   - attributes: 属性有序列表
   - enableHash: 是否对属性进行哈希分布:
  开启后表中记录按照(hash(attribute value), attribute value)大小顺序分布
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'attributes', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'enableHash', None, True, ), # 2
  )

  def __init__(self, attributes=None, enableHash=thrift_spec[2][4],):
    self.attributes = attributes
    self.enableHash = enableHash

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = KeySpec()
            _elem75.read(iprot)
            self.attributes.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.enableHash = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EntityGroupSpec')
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.attributes))
      for iter76 in self.attributes:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.enableHash is not None:
      oprot.writeFieldBegin('enableHash', TType.BOOL, 2)
      oprot.writeBool(self.enableHash)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.enableHash)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSchema(object):
  """
  表Schema设置

  Attributes:
   - version: Schema版本号，仅作为输出，作为输入不需要设置
   - entityGroup: Entity group定义, 不设置表示不开启Entity Group支持。
  开启后自动支持应用用户表空间隔离(需配合相应权限设置),
  即每个应用用户将看到独立的表空间
   - primaryIndex: 主键定义
   - secondaryIndexes: 二级索引定义
   - attributes: 属性定义
   - ttl: 记录存活时间，单位为秒。-1表示不会自动删除
   - preSplits: 表初始分片数目，仅支持Entity Group开启hash分布的表，且仅在建表时起作用
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRUCT, 'entityGroup', (EntityGroupSpec, EntityGroupSpec.thrift_spec), None, ), # 2
    (3, TType.LIST, 'primaryIndex', (TType.STRUCT,(KeySpec, KeySpec.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'secondaryIndexes', (TType.STRING,None,TType.STRUCT,(LocalSecondaryIndexSpec, LocalSecondaryIndexSpec.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'attributes', (TType.STRING,None,TType.I32,None), None, ), # 5
    (6, TType.I32, 'ttl', None, -1, ), # 6
    (7, TType.I32, 'preSplits', None, 1, ), # 7
  )

  def __init__(self, version=None, entityGroup=None, primaryIndex=None, secondaryIndexes=None, attributes=None, ttl=thrift_spec[6][4], preSplits=thrift_spec[7][4],):
    self.version = version
    self.entityGroup = entityGroup
    self.primaryIndex = primaryIndex
    self.secondaryIndexes = secondaryIndexes
    self.attributes = attributes
    self.ttl = ttl
    self.preSplits = preSplits

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.entityGroup = EntityGroupSpec()
          self.entityGroup.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.primaryIndex = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = KeySpec()
            _elem82.read(iprot)
            self.primaryIndex.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.secondaryIndexes = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin()
          for _i87 in xrange(_size83):
            _key88 = iprot.readString();
            _val89 = LocalSecondaryIndexSpec()
            _val89.read(iprot)
            self.secondaryIndexes[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin()
          for _i94 in xrange(_size90):
            _key95 = iprot.readString();
            _val96 = iprot.readI32();
            self.attributes[_key95] = _val96
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.preSplits = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSchema')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.entityGroup is not None:
      oprot.writeFieldBegin('entityGroup', TType.STRUCT, 2)
      self.entityGroup.write(oprot)
      oprot.writeFieldEnd()
    if self.primaryIndex is not None:
      oprot.writeFieldBegin('primaryIndex', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.primaryIndex))
      for iter97 in self.primaryIndex:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.secondaryIndexes is not None:
      oprot.writeFieldBegin('secondaryIndexes', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.secondaryIndexes))
      for kiter98,viter99 in self.secondaryIndexes.items():
        oprot.writeString(kiter98)
        viter99.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.attributes))
      for kiter100,viter101 in self.attributes.items():
        oprot.writeString(kiter100)
        oprot.writeI32(viter101)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ttl is not None:
      oprot.writeFieldBegin('ttl', TType.I32, 6)
      oprot.writeI32(self.ttl)
      oprot.writeFieldEnd()
    if self.preSplits is not None:
      oprot.writeFieldBegin('preSplits', TType.I32, 7)
      oprot.writeI32(self.preSplits)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.entityGroup)
    value = (value * 31) ^ hash(self.primaryIndex)
    value = (value * 31) ^ hash(self.secondaryIndexes)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.ttl)
    value = (value * 31) ^ hash(self.preSplits)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReplicationProvisionThroughput(object):
  """
  远程复制吞吐量配额

  Attributes:
   - consumeCapacity
   - commitCapacity
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'consumeCapacity', None, None, ), # 1
    (2, TType.I64, 'commitCapacity', None, None, ), # 2
  )

  def __init__(self, consumeCapacity=None, commitCapacity=None,):
    self.consumeCapacity = consumeCapacity
    self.commitCapacity = commitCapacity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.consumeCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.commitCapacity = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReplicationProvisionThroughput')
    if self.consumeCapacity is not None:
      oprot.writeFieldBegin('consumeCapacity', TType.I64, 1)
      oprot.writeI64(self.consumeCapacity)
      oprot.writeFieldEnd()
    if self.commitCapacity is not None:
      oprot.writeFieldBegin('commitCapacity', TType.I64, 2)
      oprot.writeI64(self.commitCapacity)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.consumeCapacity)
    value = (value * 31) ^ hash(self.commitCapacity)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReplicationSpec(object):
  """
  远程复制定义

  Attributes:
   - enableReplication: 是否做增量复制
   - throughput: 吞吐量配额
   - maxSubscribers: 订阅者的最大数量
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enableReplication', None, None, ), # 1
    (2, TType.STRUCT, 'throughput', (ReplicationProvisionThroughput, ReplicationProvisionThroughput.thrift_spec), None, ), # 2
    (3, TType.I32, 'maxSubscribers', None, None, ), # 3
  )

  def __init__(self, enableReplication=None, throughput=None, maxSubscribers=None,):
    self.enableReplication = enableReplication
    self.throughput = throughput
    self.maxSubscribers = maxSubscribers

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.enableReplication = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.throughput = ReplicationProvisionThroughput()
          self.throughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxSubscribers = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReplicationSpec')
    if self.enableReplication is not None:
      oprot.writeFieldBegin('enableReplication', TType.BOOL, 1)
      oprot.writeBool(self.enableReplication)
      oprot.writeFieldEnd()
    if self.throughput is not None:
      oprot.writeFieldBegin('throughput', TType.STRUCT, 2)
      self.throughput.write(oprot)
      oprot.writeFieldEnd()
    if self.maxSubscribers is not None:
      oprot.writeFieldBegin('maxSubscribers', TType.I32, 3)
      oprot.writeI32(self.maxSubscribers)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.enableReplication)
    value = (value * 31) ^ hash(self.throughput)
    value = (value * 31) ^ hash(self.maxSubscribers)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableMetadata(object):
  """
  表元信息

  Attributes:
   - tableId: 表ID
  仅作为输出值，作为输入时无需指定
   - developerId: 所有者的开发者ID，
  对于CreateTable/AlterTable，值不设置时，默认为当前登录用户。
   - appAcl: 权限控制设置
   - quota: 空间配额
   - throughput: 吞吐量配额
   - description: 表备注信息
   - enableScanInGlobalOrder: 是否支持全局有序扫描
   - replication: 远程复制定义
   - enableSysSnapshot: 是否支持系统定期做snapshot， 默认为true
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableId', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
    (3, TType.MAP, 'appAcl', (TType.STRING,None,TType.LIST,(TType.I32,None)), None, ), # 3
    (4, TType.STRUCT, 'quota', (TableQuota, TableQuota.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'throughput', (ProvisionThroughput, ProvisionThroughput.thrift_spec), None, ), # 5
    (6, TType.STRING, 'description', None, None, ), # 6
    (7, TType.BOOL, 'enableScanInGlobalOrder', None, None, ), # 7
    (8, TType.STRUCT, 'replication', (ReplicationSpec, ReplicationSpec.thrift_spec), None, ), # 8
    (9, TType.BOOL, 'enableSysSnapshot', None, None, ), # 9
  )

  def __init__(self, tableId=None, developerId=None, appAcl=None, quota=None, throughput=None, description=None, enableScanInGlobalOrder=None, replication=None, enableSysSnapshot=None,):
    self.tableId = tableId
    self.developerId = developerId
    self.appAcl = appAcl
    self.quota = quota
    self.throughput = throughput
    self.description = description
    self.enableScanInGlobalOrder = enableScanInGlobalOrder
    self.replication = replication
    self.enableSysSnapshot = enableSysSnapshot

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.appAcl = {}
          (_ktype103, _vtype104, _size102 ) = iprot.readMapBegin()
          for _i106 in xrange(_size102):
            _key107 = iprot.readString();
            _val108 = []
            (_etype112, _size109) = iprot.readListBegin()
            for _i113 in xrange(_size109):
              _elem114 = iprot.readI32();
              _val108.append(_elem114)
            iprot.readListEnd()
            self.appAcl[_key107] = _val108
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.quota = TableQuota()
          self.quota.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.throughput = ProvisionThroughput()
          self.throughput.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enableScanInGlobalOrder = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.replication = ReplicationSpec()
          self.replication.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.enableSysSnapshot = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableMetadata')
    if self.tableId is not None:
      oprot.writeFieldBegin('tableId', TType.STRING, 1)
      oprot.writeString(self.tableId)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    if self.appAcl is not None:
      oprot.writeFieldBegin('appAcl', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.appAcl))
      for kiter115,viter116 in self.appAcl.items():
        oprot.writeString(kiter115)
        oprot.writeListBegin(TType.I32, len(viter116))
        for iter117 in viter116:
          oprot.writeI32(iter117)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.quota is not None:
      oprot.writeFieldBegin('quota', TType.STRUCT, 4)
      self.quota.write(oprot)
      oprot.writeFieldEnd()
    if self.throughput is not None:
      oprot.writeFieldBegin('throughput', TType.STRUCT, 5)
      self.throughput.write(oprot)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 6)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.enableScanInGlobalOrder is not None:
      oprot.writeFieldBegin('enableScanInGlobalOrder', TType.BOOL, 7)
      oprot.writeBool(self.enableScanInGlobalOrder)
      oprot.writeFieldEnd()
    if self.replication is not None:
      oprot.writeFieldBegin('replication', TType.STRUCT, 8)
      self.replication.write(oprot)
      oprot.writeFieldEnd()
    if self.enableSysSnapshot is not None:
      oprot.writeFieldBegin('enableSysSnapshot', TType.BOOL, 9)
      oprot.writeBool(self.enableSysSnapshot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableId)
    value = (value * 31) ^ hash(self.developerId)
    value = (value * 31) ^ hash(self.appAcl)
    value = (value * 31) ^ hash(self.quota)
    value = (value * 31) ^ hash(self.throughput)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.enableScanInGlobalOrder)
    value = (value * 31) ^ hash(self.replication)
    value = (value * 31) ^ hash(self.enableSysSnapshot)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSpec(object):
  """
  表配置信息

  Attributes:
   - schema
   - metadata
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schema', (TableSchema, TableSchema.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'metadata', (TableMetadata, TableMetadata.thrift_spec), None, ), # 2
  )

  def __init__(self, schema=None, metadata=None,):
    self.schema = schema
    self.metadata = metadata

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schema = TableSchema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = TableMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSpec')
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 1)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.schema)
    value = (value * 31) ^ hash(self.metadata)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Subscriber(object):
  """
  Attributes:
   - tableName: 表名
   - subscriberName: 订阅者名字
   - subscriberId: 订阅者ID,仅作为输出值，作为输入时无需指定
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'subscriberName', None, None, ), # 2
    (3, TType.STRING, 'subscriberId', None, None, ), # 3
  )

  def __init__(self, tableName=None, subscriberName=None, subscriberId=None,):
    self.tableName = tableName
    self.subscriberName = subscriberName
    self.subscriberId = subscriberId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.subscriberName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.subscriberId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Subscriber')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.subscriberName is not None:
      oprot.writeFieldBegin('subscriberName', TType.STRING, 2)
      oprot.writeString(self.subscriberName)
      oprot.writeFieldEnd()
    if self.subscriberId is not None:
      oprot.writeFieldBegin('subscriberId', TType.STRING, 3)
      oprot.writeString(self.subscriberId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.subscriberName)
    value = (value * 31) ^ hash(self.subscriberId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Sinker(object):
  """
  Attributes:
   - subscribedTableName: 主集群订阅的表名
   - subscriberName: 订阅者名字
   - endpoint: 主集群域名
   - sinkedTableName: 备集群的表名
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'subscribedTableName', None, None, ), # 1
    (2, TType.STRING, 'subscriberName', None, None, ), # 2
    (3, TType.STRING, 'endpoint', None, None, ), # 3
    (4, TType.STRING, 'sinkedTableName', None, None, ), # 4
  )

  def __init__(self, subscribedTableName=None, subscriberName=None, endpoint=None, sinkedTableName=None,):
    self.subscribedTableName = subscribedTableName
    self.subscriberName = subscriberName
    self.endpoint = endpoint
    self.sinkedTableName = sinkedTableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.subscribedTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.subscriberName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.endpoint = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.sinkedTableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Sinker')
    if self.subscribedTableName is not None:
      oprot.writeFieldBegin('subscribedTableName', TType.STRING, 1)
      oprot.writeString(self.subscribedTableName)
      oprot.writeFieldEnd()
    if self.subscriberName is not None:
      oprot.writeFieldBegin('subscriberName', TType.STRING, 2)
      oprot.writeString(self.subscriberName)
      oprot.writeFieldEnd()
    if self.endpoint is not None:
      oprot.writeFieldBegin('endpoint', TType.STRING, 3)
      oprot.writeString(self.endpoint)
      oprot.writeFieldEnd()
    if self.sinkedTableName is not None:
      oprot.writeFieldBegin('sinkedTableName', TType.STRING, 4)
      oprot.writeString(self.sinkedTableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.subscribedTableName)
    value = (value * 31) ^ hash(self.subscriberName)
    value = (value * 31) ^ hash(self.endpoint)
    value = (value * 31) ^ hash(self.sinkedTableName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableStatus(object):
  """
  表状态信息

  Attributes:
   - state: 表状态
   - createTime: 创建时间
   - alterTime: 最近修改时间
   - statTime: 最近统计时间
   - size: 占用空间统计，单位为字节
   - rowCount: 行数统计，非即时精确值
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'state', None, None, ), # 1
    (2, TType.I64, 'createTime', None, None, ), # 2
    (3, TType.I64, 'alterTime', None, None, ), # 3
    (4, TType.I64, 'statTime', None, None, ), # 4
    (5, TType.I64, 'size', None, None, ), # 5
    (6, TType.I64, 'rowCount', None, None, ), # 6
  )

  def __init__(self, state=None, createTime=None, alterTime=None, statTime=None, size=None, rowCount=None,):
    self.state = state
    self.createTime = createTime
    self.alterTime = alterTime
    self.statTime = statTime
    self.size = size
    self.rowCount = rowCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.createTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.alterTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.statTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.size = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.rowCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableStatus')
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 1)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.createTime is not None:
      oprot.writeFieldBegin('createTime', TType.I64, 2)
      oprot.writeI64(self.createTime)
      oprot.writeFieldEnd()
    if self.alterTime is not None:
      oprot.writeFieldBegin('alterTime', TType.I64, 3)
      oprot.writeI64(self.alterTime)
      oprot.writeFieldEnd()
    if self.statTime is not None:
      oprot.writeFieldBegin('statTime', TType.I64, 4)
      oprot.writeI64(self.statTime)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I64, 5)
      oprot.writeI64(self.size)
      oprot.writeFieldEnd()
    if self.rowCount is not None:
      oprot.writeFieldBegin('rowCount', TType.I64, 6)
      oprot.writeI64(self.rowCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.state)
    value = (value * 31) ^ hash(self.createTime)
    value = (value * 31) ^ hash(self.alterTime)
    value = (value * 31) ^ hash(self.statTime)
    value = (value * 31) ^ hash(self.size)
    value = (value * 31) ^ hash(self.rowCount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableInfo(object):
  """
  表信息

  Attributes:
   - name
   - spec
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'spec', (TableSpec, TableSpec.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'status', (TableStatus, TableStatus.thrift_spec), None, ), # 3
  )

  def __init__(self, name=None, spec=None, status=None,):
    self.name = name
    self.spec = spec
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.spec = TableSpec()
          self.spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.status = TableStatus()
          self.status.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.spec is not None:
      oprot.writeFieldBegin('spec', TType.STRUCT, 2)
      self.spec.write(oprot)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRUCT, 3)
      self.status.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.spec)
    value = (value * 31) ^ hash(self.status)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SimpleCondition(object):
  """
  简单条件，用于checkAndPut/Delete操作，判定逻辑为: value operator field

  Attributes:
   - operator
   - field
   - value
   - rowExist
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'operator', None, None, ), # 1
    (2, TType.STRING, 'field', None, None, ), # 2
    (3, TType.STRUCT, 'value', (Datum, Datum.thrift_spec), None, ), # 3
    (4, TType.BOOL, 'rowExist', None, None, ), # 4
  )

  def __init__(self, operator=None, field=None, value=None, rowExist=None,):
    self.operator = operator
    self.field = field
    self.value = value
    self.rowExist = rowExist

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.operator = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.value = Datum()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.rowExist = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SimpleCondition')
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 1)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 2)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 3)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.rowExist is not None:
      oprot.writeFieldBegin('rowExist', TType.BOOL, 4)
      oprot.writeBool(self.rowExist)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.rowExist)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TableSplit(object):
  """
  表分片信息，包括起始和结束的row key

  Attributes:
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
  )

  def __init__(self, startKey=None, stopKey=None,):
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin()
          for _i122 in xrange(_size118):
            _key123 = iprot.readString();
            _val124 = Datum()
            _val124.read(iprot)
            self.startKey[_key123] = _val124
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin()
          for _i129 in xrange(_size125):
            _key130 = iprot.readString();
            _val131 = Datum()
            _val131.read(iprot)
            self.stopKey[_key130] = _val131
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TableSplit')
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter132,viter133 in self.startKey.items():
        oprot.writeString(kiter132)
        viter133.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter134,viter135 in self.stopKey.items():
        oprot.writeString(kiter134)
        viter135.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.stopKey)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Partition(object):
  """
  表分区信息，包括分区id，起始和结束的row key

  Attributes:
   - partitionId
   - startKey
   - stopKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'partitionId', None, None, ), # 1
    (2, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
  )

  def __init__(self, partitionId=None, startKey=None, stopKey=None,):
    self.partitionId = partitionId
    self.startKey = startKey
    self.stopKey = stopKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.partitionId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin()
          for _i140 in xrange(_size136):
            _key141 = iprot.readString();
            _val142 = Datum()
            _val142.read(iprot)
            self.startKey[_key141] = _val142
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype144, _vtype145, _size143 ) = iprot.readMapBegin()
          for _i147 in xrange(_size143):
            _key148 = iprot.readString();
            _val149 = Datum()
            _val149.read(iprot)
            self.stopKey[_key148] = _val149
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Partition')
    if self.partitionId is not None:
      oprot.writeFieldBegin('partitionId', TType.I32, 1)
      oprot.writeI32(self.partitionId)
      oprot.writeFieldEnd()
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter150,viter151 in self.startKey.items():
        oprot.writeString(kiter150)
        viter151.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter152,viter153 in self.stopKey.items():
        oprot.writeString(kiter152)
        viter153.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.partitionId)
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.stopKey)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PartitionStatistics(object):
  """
  表分区统计信息

  Attributes:
   - collectedEditNumber
   - retrievedEditNumber
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'collectedEditNumber', None, None, ), # 1
    (2, TType.I64, 'retrievedEditNumber', None, None, ), # 2
  )

  def __init__(self, collectedEditNumber=None, retrievedEditNumber=None,):
    self.collectedEditNumber = collectedEditNumber
    self.retrievedEditNumber = retrievedEditNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.collectedEditNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.retrievedEditNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PartitionStatistics')
    if self.collectedEditNumber is not None:
      oprot.writeFieldBegin('collectedEditNumber', TType.I64, 1)
      oprot.writeI64(self.collectedEditNumber)
      oprot.writeFieldEnd()
    if self.retrievedEditNumber is not None:
      oprot.writeFieldBegin('retrievedEditNumber', TType.I64, 2)
      oprot.writeI64(self.retrievedEditNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.collectedEditNumber)
    value = (value * 31) ^ hash(self.retrievedEditNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SubscriberStatistics(object):
  """
  表分区订阅统计信息

  Attributes:
   - consumedDataNumber
   - committedDataNumber
   - consumedEditNumber
   - committedEditNumber
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'consumedDataNumber', None, None, ), # 1
    (2, TType.I64, 'committedDataNumber', None, None, ), # 2
    (3, TType.I64, 'consumedEditNumber', None, None, ), # 3
    (4, TType.I64, 'committedEditNumber', None, None, ), # 4
  )

  def __init__(self, consumedDataNumber=None, committedDataNumber=None, consumedEditNumber=None, committedEditNumber=None,):
    self.consumedDataNumber = consumedDataNumber
    self.committedDataNumber = committedDataNumber
    self.consumedEditNumber = consumedEditNumber
    self.committedEditNumber = committedEditNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.consumedDataNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.committedDataNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.consumedEditNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.committedEditNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SubscriberStatistics')
    if self.consumedDataNumber is not None:
      oprot.writeFieldBegin('consumedDataNumber', TType.I64, 1)
      oprot.writeI64(self.consumedDataNumber)
      oprot.writeFieldEnd()
    if self.committedDataNumber is not None:
      oprot.writeFieldBegin('committedDataNumber', TType.I64, 2)
      oprot.writeI64(self.committedDataNumber)
      oprot.writeFieldEnd()
    if self.consumedEditNumber is not None:
      oprot.writeFieldBegin('consumedEditNumber', TType.I64, 3)
      oprot.writeI64(self.consumedEditNumber)
      oprot.writeFieldEnd()
    if self.committedEditNumber is not None:
      oprot.writeFieldBegin('committedEditNumber', TType.I64, 4)
      oprot.writeI64(self.committedEditNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.consumedDataNumber)
    value = (value * 31) ^ hash(self.committedDataNumber)
    value = (value * 31) ^ hash(self.consumedEditNumber)
    value = (value * 31) ^ hash(self.committedEditNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetRequest(object):
  """
  Attributes:
   - tableName
   - keys: 记录主键，必须包含主键所有的属性
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, attributes=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype155, _vtype156, _size154 ) = iprot.readMapBegin()
          for _i158 in xrange(_size154):
            _key159 = iprot.readString();
            _val160 = Datum()
            _val160.read(iprot)
            self.keys[_key159] = _val160
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype164, _size161) = iprot.readListBegin()
          for _i165 in xrange(_size161):
            _elem166 = iprot.readString();
            self.attributes.append(_elem166)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter167,viter168 in self.keys.items():
        oprot.writeString(kiter167)
        viter168.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter169 in self.attributes:
        oprot.writeString(iter169)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.attributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetResult(object):
  """
  Attributes:
   - item
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'item', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, item=None,):
    self.item = item

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.item = {}
          (_ktype171, _vtype172, _size170 ) = iprot.readMapBegin()
          for _i174 in xrange(_size170):
            _key175 = iprot.readString();
            _val176 = Datum()
            _val176.read(iprot)
            self.item[_key175] = _val176
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetResult')
    if self.item is not None:
      oprot.writeFieldBegin('item', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.item))
      for kiter177,viter178 in self.item.items():
        oprot.writeString(kiter177)
        viter178.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.item)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutRequest(object):
  """
  Attributes:
   - tableName
   - record: 待写入的记录
   - condition: 仅当满足指定条件时执行写入操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'record', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 3
  )

  def __init__(self, tableName=None, record=None, condition=None,):
    self.tableName = tableName
    self.record = record
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.record = {}
          (_ktype180, _vtype181, _size179 ) = iprot.readMapBegin()
          for _i183 in xrange(_size179):
            _key184 = iprot.readString();
            _val185 = Datum()
            _val185.read(iprot)
            self.record[_key184] = _val185
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.record))
      for kiter186,viter187 in self.record.items():
        oprot.writeString(kiter186)
        viter187.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 3)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.condition)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PutResult(object):
  """
  Attributes:
   - success: 写入操作是否被执行(是否满足设置的条件)
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PutResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待自增的记录主键
   - amounts: 需要进行自增操作的属性，必须为整形，且不能为索引属性
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
  )

  def __init__(self, tableName=None, keys=None, amounts=None,):
    self.tableName = tableName
    self.keys = keys
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype189, _vtype190, _size188 ) = iprot.readMapBegin()
          for _i192 in xrange(_size188):
            _key193 = iprot.readString();
            _val194 = Datum()
            _val194.read(iprot)
            self.keys[_key193] = _val194
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype196, _vtype197, _size195 ) = iprot.readMapBegin()
          for _i199 in xrange(_size195):
            _key200 = iprot.readString();
            _val201 = Datum()
            _val201.read(iprot)
            self.amounts[_key200] = _val201
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter202,viter203 in self.keys.items():
        oprot.writeString(kiter202)
        viter203.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter204,viter205 in self.amounts.items():
        oprot.writeString(kiter204)
        viter205.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.amounts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IncrementResult(object):
  """
  Attributes:
   - amounts
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'amounts', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
  )

  def __init__(self, amounts=None,):
    self.amounts = amounts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.amounts = {}
          (_ktype207, _vtype208, _size206 ) = iprot.readMapBegin()
          for _i210 in xrange(_size206):
            _key211 = iprot.readString();
            _val212 = Datum()
            _val212.read(iprot)
            self.amounts[_key211] = _val212
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IncrementResult')
    if self.amounts is not None:
      oprot.writeFieldBegin('amounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.amounts))
      for kiter213,viter214 in self.amounts.items():
        oprot.writeString(kiter213)
        viter214.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.amounts)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveRequest(object):
  """
  Attributes:
   - tableName
   - keys: 待删除的记录主键
   - attributes: 待删除的属性列表，不指定表示删除整条记录。
  当删除部分属性时，即使所有属性均已被删除，记录仍存在，删除整条记录需要显式删除
   - condition: 仅当满足指定条件时执行删除操作
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'condition', (SimpleCondition, SimpleCondition.thrift_spec), None, ), # 4
  )

  def __init__(self, tableName=None, keys=None, attributes=None, condition=None,):
    self.tableName = tableName
    self.keys = keys
    self.attributes = attributes
    self.condition = condition

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype216, _vtype217, _size215 ) = iprot.readMapBegin()
          for _i219 in xrange(_size215):
            _key220 = iprot.readString();
            _val221 = Datum()
            _val221.read(iprot)
            self.keys[_key220] = _val221
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype225, _size222) = iprot.readListBegin()
          for _i226 in xrange(_size222):
            _elem227 = iprot.readString();
            self.attributes.append(_elem227)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.condition = SimpleCondition()
          self.condition.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter228,viter229 in self.keys.items():
        oprot.writeString(kiter228)
        viter229.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter230 in self.attributes:
        oprot.writeString(iter230)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRUCT, 4)
      self.condition.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.condition)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveResult(object):
  """
  Attributes:
   - success: 删除操作是否被执行（是否满足设置的条件）
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Request(object):
  """
  Attributes:
   - getRequest: 随机读操作
   - putRequest: 写入操作，不支持条件
   - incrementRequest: 自增操作
   - removeRequest: 删除操作，不支持条件
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getRequest', (GetRequest, GetRequest.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putRequest', (PutRequest, PutRequest.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementRequest', (IncrementRequest, IncrementRequest.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeRequest', (RemoveRequest, RemoveRequest.thrift_spec), None, ), # 4
  )

  def __init__(self, getRequest=None, putRequest=None, incrementRequest=None, removeRequest=None,):
    self.getRequest = getRequest
    self.putRequest = putRequest
    self.incrementRequest = incrementRequest
    self.removeRequest = removeRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getRequest = GetRequest()
          self.getRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putRequest = PutRequest()
          self.putRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementRequest = IncrementRequest()
          self.incrementRequest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeRequest = RemoveRequest()
          self.removeRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Request')
    if self.getRequest is not None:
      oprot.writeFieldBegin('getRequest', TType.STRUCT, 1)
      self.getRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.putRequest is not None:
      oprot.writeFieldBegin('putRequest', TType.STRUCT, 2)
      self.putRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementRequest is not None:
      oprot.writeFieldBegin('incrementRequest', TType.STRUCT, 3)
      self.incrementRequest.write(oprot)
      oprot.writeFieldEnd()
    if self.removeRequest is not None:
      oprot.writeFieldBegin('removeRequest', TType.STRUCT, 4)
      self.removeRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getRequest)
    value = (value * 31) ^ hash(self.putRequest)
    value = (value * 31) ^ hash(self.incrementRequest)
    value = (value * 31) ^ hash(self.removeRequest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanAction(object):
  """
  Attributes:
   - action: scan时连带操作
   - request: 实际操作，不需要指定key
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanAction')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanRequest(object):
  """
  范围查询，支持主键和二级索引查询，
  查询范围为闭开区间[startKey, endKey)，
  当指定索引时，查询范围的entity group必须唯一指定

  Attributes:
   - tableName
   - indexName: 不指定表示通过主键进行查询
   - startKey: 查询范围开始，包含startKey，
  如果startKey不是完整键，而是部分key的前缀，则实际查询的startKey为{startKey, 最小可能的后缀}补全形式
   - stopKey: 查询范围结束，不包含stopKey，
  如果stopKey不是完整键，而是部分key的前缀，则实际查询的stopKey为{stopKey, 最大可能的后缀}补全形式
   - attributes: 需要返回的属性列表，不指定表示返回所有属性
   - condition: 类SQL WHERE语句的查询条件。
  注意：与SQL不同，此条件仅作为过滤条件，不影响具体查询计划(index, startKey, endKey)，
  进行范围查询时需要显示设置index和startKey以及endKey。每个扫描的记录均计入读配额，
  即使不满足查询条件。尽量避免使用条件过滤，尤其是当过滤掉的记录占一半以上时，强烈不建议使用。
   - limit: 返回记录的最大数目，返回数目可能小于此值(如超出表的读配额时)
   - reverse: 是否进行逆序扫描，进行逆序扫描时startKey应大于endKey，
  注意：逆序查询效率较低，谨慎使用，建议设置对应的Key为逆序存储
   - inGlobalOrder: 是否全局有序扫描
   - cacheResult: 是否将结果放入cache，对于类似MapReduce的大批量扫描的应用应该关闭此选项
   - lookAheadStep: 查找属性在seek之前进行顺序skip的次数。非必要情况，请不要设置
   - action: scan时的连带操作，包括COUNT，DELETE和UPDATE
   - splitIndex: 扫描表分片的索引，对salted table全局无序扫描时设置
   - initialStartKey: 查询范围开始的初始值，对salted table全局无序扫描时设置
   - scanInOneSplit: 对salted table, 确定startKey和stopKey在同一个split内，可开启该选项加速
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.STRING, 'indexName', None, None, ), # 2
    (3, TType.MAP, 'startKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 3
    (4, TType.MAP, 'stopKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'attributes', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'condition', None, None, ), # 6
    (7, TType.I32, 'limit', None, 10, ), # 7
    (8, TType.BOOL, 'reverse', None, False, ), # 8
    (9, TType.BOOL, 'inGlobalOrder', None, False, ), # 9
    (10, TType.BOOL, 'cacheResult', None, True, ), # 10
    (11, TType.I32, 'lookAheadStep', None, 0, ), # 11
    (12, TType.STRUCT, 'action', (ScanAction, ScanAction.thrift_spec), None, ), # 12
    (13, TType.I32, 'splitIndex', None, -1, ), # 13
    (14, TType.MAP, 'initialStartKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 14
    (15, TType.BOOL, 'scanInOneSplit', None, False, ), # 15
  )

  def __init__(self, tableName=None, indexName=None, startKey=None, stopKey=None, attributes=None, condition=None, limit=thrift_spec[7][4], reverse=thrift_spec[8][4], inGlobalOrder=thrift_spec[9][4], cacheResult=thrift_spec[10][4], lookAheadStep=thrift_spec[11][4], action=None, splitIndex=thrift_spec[13][4], initialStartKey=None, scanInOneSplit=thrift_spec[15][4],):
    self.tableName = tableName
    self.indexName = indexName
    self.startKey = startKey
    self.stopKey = stopKey
    self.attributes = attributes
    self.condition = condition
    self.limit = limit
    self.reverse = reverse
    self.inGlobalOrder = inGlobalOrder
    self.cacheResult = cacheResult
    self.lookAheadStep = lookAheadStep
    self.action = action
    self.splitIndex = splitIndex
    self.initialStartKey = initialStartKey
    self.scanInOneSplit = scanInOneSplit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.indexName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.startKey = {}
          (_ktype232, _vtype233, _size231 ) = iprot.readMapBegin()
          for _i235 in xrange(_size231):
            _key236 = iprot.readString();
            _val237 = Datum()
            _val237.read(iprot)
            self.startKey[_key236] = _val237
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.stopKey = {}
          (_ktype239, _vtype240, _size238 ) = iprot.readMapBegin()
          for _i242 in xrange(_size238):
            _key243 = iprot.readString();
            _val244 = Datum()
            _val244.read(iprot)
            self.stopKey[_key243] = _val244
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.attributes = []
          (_etype248, _size245) = iprot.readListBegin()
          for _i249 in xrange(_size245):
            _elem250 = iprot.readString();
            self.attributes.append(_elem250)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.reverse = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.inGlobalOrder = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.cacheResult = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.lookAheadStep = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.action = ScanAction()
          self.action.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.splitIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.MAP:
          self.initialStartKey = {}
          (_ktype252, _vtype253, _size251 ) = iprot.readMapBegin()
          for _i255 in xrange(_size251):
            _key256 = iprot.readString();
            _val257 = Datum()
            _val257.read(iprot)
            self.initialStartKey[_key256] = _val257
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.scanInOneSplit = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.indexName is not None:
      oprot.writeFieldBegin('indexName', TType.STRING, 2)
      oprot.writeString(self.indexName)
      oprot.writeFieldEnd()
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.startKey))
      for kiter258,viter259 in self.startKey.items():
        oprot.writeString(kiter258)
        viter259.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stopKey is not None:
      oprot.writeFieldBegin('stopKey', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.stopKey))
      for kiter260,viter261 in self.stopKey.items():
        oprot.writeString(kiter260)
        viter261.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.attributes))
      for iter262 in self.attributes:
        oprot.writeString(iter262)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition is not None:
      oprot.writeFieldBegin('condition', TType.STRING, 6)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 7)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.reverse is not None:
      oprot.writeFieldBegin('reverse', TType.BOOL, 8)
      oprot.writeBool(self.reverse)
      oprot.writeFieldEnd()
    if self.inGlobalOrder is not None:
      oprot.writeFieldBegin('inGlobalOrder', TType.BOOL, 9)
      oprot.writeBool(self.inGlobalOrder)
      oprot.writeFieldEnd()
    if self.cacheResult is not None:
      oprot.writeFieldBegin('cacheResult', TType.BOOL, 10)
      oprot.writeBool(self.cacheResult)
      oprot.writeFieldEnd()
    if self.lookAheadStep is not None:
      oprot.writeFieldBegin('lookAheadStep', TType.I32, 11)
      oprot.writeI32(self.lookAheadStep)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRUCT, 12)
      self.action.write(oprot)
      oprot.writeFieldEnd()
    if self.splitIndex is not None:
      oprot.writeFieldBegin('splitIndex', TType.I32, 13)
      oprot.writeI32(self.splitIndex)
      oprot.writeFieldEnd()
    if self.initialStartKey is not None:
      oprot.writeFieldBegin('initialStartKey', TType.MAP, 14)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.initialStartKey))
      for kiter263,viter264 in self.initialStartKey.items():
        oprot.writeString(kiter263)
        viter264.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.scanInOneSplit is not None:
      oprot.writeFieldBegin('scanInOneSplit', TType.BOOL, 15)
      oprot.writeBool(self.scanInOneSplit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.indexName)
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.stopKey)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.condition)
    value = (value * 31) ^ hash(self.limit)
    value = (value * 31) ^ hash(self.reverse)
    value = (value * 31) ^ hash(self.inGlobalOrder)
    value = (value * 31) ^ hash(self.cacheResult)
    value = (value * 31) ^ hash(self.lookAheadStep)
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.splitIndex)
    value = (value * 31) ^ hash(self.initialStartKey)
    value = (value * 31) ^ hash(self.scanInOneSplit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ScanResult(object):
  """
  Attributes:
   - nextStartKey: 下一个需要扫描的记录主键，NULL表示达到制定的结束位置
   - records: 扫描的记录
   - throttled: 是否超过表的qps quota
   - nextSplitIndex: 下一个需要扫描的分片索引，-1表示已经扫描完所有分片，对salted table全局无序扫描时使用
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'nextStartKey', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'records', (TType.MAP,(TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec))), None, ), # 2
    (3, TType.BOOL, 'throttled', None, None, ), # 3
    (4, TType.I32, 'nextSplitIndex', None, -1, ), # 4
  )

  def __init__(self, nextStartKey=None, records=None, throttled=None, nextSplitIndex=thrift_spec[4][4],):
    self.nextStartKey = nextStartKey
    self.records = records
    self.throttled = throttled
    self.nextSplitIndex = nextSplitIndex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.nextStartKey = {}
          (_ktype266, _vtype267, _size265 ) = iprot.readMapBegin()
          for _i269 in xrange(_size265):
            _key270 = iprot.readString();
            _val271 = Datum()
            _val271.read(iprot)
            self.nextStartKey[_key270] = _val271
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype275, _size272) = iprot.readListBegin()
          for _i276 in xrange(_size272):
            _elem277 = {}
            (_ktype279, _vtype280, _size278 ) = iprot.readMapBegin()
            for _i282 in xrange(_size278):
              _key283 = iprot.readString();
              _val284 = Datum()
              _val284.read(iprot)
              _elem277[_key283] = _val284
            iprot.readMapEnd()
            self.records.append(_elem277)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.throttled = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.nextSplitIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ScanResult')
    if self.nextStartKey is not None:
      oprot.writeFieldBegin('nextStartKey', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nextStartKey))
      for kiter285,viter286 in self.nextStartKey.items():
        oprot.writeString(kiter285)
        viter286.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.records))
      for iter287 in self.records:
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(iter287))
        for kiter288,viter289 in iter287.items():
          oprot.writeString(kiter288)
          viter289.write(oprot)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throttled is not None:
      oprot.writeFieldBegin('throttled', TType.BOOL, 3)
      oprot.writeBool(self.throttled)
      oprot.writeFieldEnd()
    if self.nextSplitIndex is not None:
      oprot.writeFieldBegin('nextSplitIndex', TType.I32, 4)
      oprot.writeI32(self.nextSplitIndex)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.nextStartKey)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.throttled)
    value = (value * 31) ^ hash(self.nextSplitIndex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequestItem(object):
  """
  Attributes:
   - action
   - request
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.STRUCT, 'request', (Request, Request.thrift_spec), None, ), # 2
  )

  def __init__(self, action=None, request=None,):
    self.action = action
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.request = Request()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequestItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 2)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.request)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Result(object):
  """
  Attributes:
   - getResult
   - putResult
   - incrementResult
   - removeResult
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'getResult', (GetResult, GetResult.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'putResult', (PutResult, PutResult.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'incrementResult', (IncrementResult, IncrementResult.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'removeResult', (RemoveResult, RemoveResult.thrift_spec), None, ), # 4
  )

  def __init__(self, getResult=None, putResult=None, incrementResult=None, removeResult=None,):
    self.getResult = getResult
    self.putResult = putResult
    self.incrementResult = incrementResult
    self.removeResult = removeResult

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.getResult = GetResult()
          self.getResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.putResult = PutResult()
          self.putResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.incrementResult = IncrementResult()
          self.incrementResult.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.removeResult = RemoveResult()
          self.removeResult.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Result')
    if self.getResult is not None:
      oprot.writeFieldBegin('getResult', TType.STRUCT, 1)
      self.getResult.write(oprot)
      oprot.writeFieldEnd()
    if self.putResult is not None:
      oprot.writeFieldBegin('putResult', TType.STRUCT, 2)
      self.putResult.write(oprot)
      oprot.writeFieldEnd()
    if self.incrementResult is not None:
      oprot.writeFieldBegin('incrementResult', TType.STRUCT, 3)
      self.incrementResult.write(oprot)
      oprot.writeFieldEnd()
    if self.removeResult is not None:
      oprot.writeFieldBegin('removeResult', TType.STRUCT, 4)
      self.removeResult.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.getResult)
    value = (value * 31) ^ hash(self.putResult)
    value = (value * 31) ^ hash(self.incrementResult)
    value = (value * 31) ^ hash(self.removeResult)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResultItem(object):
  """
  Attributes:
   - action: 操作类型
   - success: 是否成功执行，即无异常
   - result: 操作结果，操作成功时被设置
   - serviceException: 操作时发生的异常，操作失败时被设置
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action', None, None, ), # 1
    (2, TType.BOOL, 'success', None, None, ), # 2
    (3, TType.STRUCT, 'result', (Result, Result.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'serviceException', (sds.errors.ttypes.ServiceException, sds.errors.ttypes.ServiceException.thrift_spec), None, ), # 4
  )

  def __init__(self, action=None, success=None, result=None, serviceException=None,):
    self.action = action
    self.success = success
    self.result = result
    self.serviceException = serviceException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = Result()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.serviceException = sds.errors.ttypes.ServiceException()
          self.serviceException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResultItem')
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.I32, 1)
      oprot.writeI32(self.action)
      oprot.writeFieldEnd()
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 2)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.serviceException is not None:
      oprot.writeFieldBegin('serviceException', TType.STRUCT, 4)
      self.serviceException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action)
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.result)
    value = (value * 31) ^ hash(self.serviceException)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchRequest(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchRequestItem, BatchRequestItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype293, _size290) = iprot.readListBegin()
          for _i294 in xrange(_size290):
            _elem295 = BatchRequestItem()
            _elem295.read(iprot)
            self.items.append(_elem295)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchRequest')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter296 in self.items:
        iter296.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.items)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchResult(object):
  """
  Attributes:
   - items
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'items', (TType.STRUCT,(BatchResultItem, BatchResultItem.thrift_spec)), None, ), # 1
  )

  def __init__(self, items=None,):
    self.items = items

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype300, _size297) = iprot.readListBegin()
          for _i301 in xrange(_size297):
            _elem302 = BatchResultItem()
            _elem302.read(iprot)
            self.items.append(_elem302)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchResult')
    if self.items is not None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter303 in self.items:
        iter303.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.items)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EditDatum(object):
  """
  增量操作单元

  Attributes:
   - editType: 增量操作类型
   - datum: 增量操作单元的数据
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'editType', None, None, ), # 1
    (2, TType.STRUCT, 'datum', (Datum, Datum.thrift_spec), None, ), # 2
  )

  def __init__(self, editType=None, datum=None,):
    self.editType = editType
    self.datum = datum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.editType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.datum = Datum()
          self.datum.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EditDatum')
    if self.editType is not None:
      oprot.writeFieldBegin('editType', TType.I32, 1)
      oprot.writeI32(self.editType)
      oprot.writeFieldEnd()
    if self.datum is not None:
      oprot.writeFieldBegin('datum', TType.STRUCT, 2)
      self.datum.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.editType)
    value = (value * 31) ^ hash(self.datum)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RowEdit(object):
  """
  行级别的增量操作

  Attributes:
   - keys: 增量操作行的主键
   - edits: 增量操作行的属性
   - consumeOffset: 增量偏移
   - deleteRow: 是否删除整行
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'keys', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.MAP, 'edits', (TType.STRING,None,TType.STRUCT,(EditDatum, EditDatum.thrift_spec)), None, ), # 2
    (3, TType.I64, 'consumeOffset', None, None, ), # 3
    (4, TType.BOOL, 'deleteRow', None, None, ), # 4
  )

  def __init__(self, keys=None, edits=None, consumeOffset=None, deleteRow=None,):
    self.keys = keys
    self.edits = edits
    self.consumeOffset = consumeOffset
    self.deleteRow = deleteRow

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.keys = {}
          (_ktype305, _vtype306, _size304 ) = iprot.readMapBegin()
          for _i308 in xrange(_size304):
            _key309 = iprot.readString();
            _val310 = Datum()
            _val310.read(iprot)
            self.keys[_key309] = _val310
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.edits = {}
          (_ktype312, _vtype313, _size311 ) = iprot.readMapBegin()
          for _i315 in xrange(_size311):
            _key316 = iprot.readString();
            _val317 = EditDatum()
            _val317.read(iprot)
            self.edits[_key316] = _val317
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.consumeOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteRow = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RowEdit')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keys))
      for kiter318,viter319 in self.keys.items():
        oprot.writeString(kiter318)
        viter319.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edits is not None:
      oprot.writeFieldBegin('edits', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.edits))
      for kiter320,viter321 in self.edits.items():
        oprot.writeString(kiter320)
        viter321.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.consumeOffset is not None:
      oprot.writeFieldBegin('consumeOffset', TType.I64, 3)
      oprot.writeI64(self.consumeOffset)
      oprot.writeFieldEnd()
    if self.deleteRow is not None:
      oprot.writeFieldBegin('deleteRow', TType.BOOL, 4)
      oprot.writeBool(self.deleteRow)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.edits)
    value = (value * 31) ^ hash(self.consumeOffset)
    value = (value * 31) ^ hash(self.deleteRow)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataConsumeRequest(object):
  """
  存量数据的消费请求

  Attributes:
   - tableName: 表名
   - partitionId: 表分区ID
   - subscriberName: 订阅者名字
   - consumeNumber: 消费数量
   - consumeOffset: 消费偏移
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.I32, 'partitionId', None, None, ), # 2
    (3, TType.STRING, 'subscriberName', None, None, ), # 3
    (4, TType.I32, 'consumeNumber', None, None, ), # 4
    (5, TType.MAP, 'consumeOffset', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 5
  )

  def __init__(self, tableName=None, partitionId=None, subscriberName=None, consumeNumber=None, consumeOffset=None,):
    self.tableName = tableName
    self.partitionId = partitionId
    self.subscriberName = subscriberName
    self.consumeNumber = consumeNumber
    self.consumeOffset = consumeOffset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partitionId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.subscriberName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.consumeNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.consumeOffset = {}
          (_ktype323, _vtype324, _size322 ) = iprot.readMapBegin()
          for _i326 in xrange(_size322):
            _key327 = iprot.readString();
            _val328 = Datum()
            _val328.read(iprot)
            self.consumeOffset[_key327] = _val328
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataConsumeRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partitionId is not None:
      oprot.writeFieldBegin('partitionId', TType.I32, 2)
      oprot.writeI32(self.partitionId)
      oprot.writeFieldEnd()
    if self.subscriberName is not None:
      oprot.writeFieldBegin('subscriberName', TType.STRING, 3)
      oprot.writeString(self.subscriberName)
      oprot.writeFieldEnd()
    if self.consumeNumber is not None:
      oprot.writeFieldBegin('consumeNumber', TType.I32, 4)
      oprot.writeI32(self.consumeNumber)
      oprot.writeFieldEnd()
    if self.consumeOffset is not None:
      oprot.writeFieldBegin('consumeOffset', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.consumeOffset))
      for kiter329,viter330 in self.consumeOffset.items():
        oprot.writeString(kiter329)
        viter330.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partitionId)
    value = (value * 31) ^ hash(self.subscriberName)
    value = (value * 31) ^ hash(self.consumeNumber)
    value = (value * 31) ^ hash(self.consumeOffset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataConsumeResult(object):
  """
  Attributes:
   - nextConsumeOffset: 下一个开始消费的存量数据的偏移，NULL表示达到当前表分片的结束位置
   - records: 消费的存量数据
   - keys: 表的主键属性
   - throttled: 是否超过表的qps quota
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'nextConsumeOffset', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'records', (TType.MAP,(TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec))), None, ), # 2
    (3, TType.LIST, 'keys', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'throttled', None, None, ), # 4
  )

  def __init__(self, nextConsumeOffset=None, records=None, keys=None, throttled=None,):
    self.nextConsumeOffset = nextConsumeOffset
    self.records = records
    self.keys = keys
    self.throttled = throttled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.nextConsumeOffset = {}
          (_ktype332, _vtype333, _size331 ) = iprot.readMapBegin()
          for _i335 in xrange(_size331):
            _key336 = iprot.readString();
            _val337 = Datum()
            _val337.read(iprot)
            self.nextConsumeOffset[_key336] = _val337
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype341, _size338) = iprot.readListBegin()
          for _i342 in xrange(_size338):
            _elem343 = {}
            (_ktype345, _vtype346, _size344 ) = iprot.readMapBegin()
            for _i348 in xrange(_size344):
              _key349 = iprot.readString();
              _val350 = Datum()
              _val350.read(iprot)
              _elem343[_key349] = _val350
            iprot.readMapEnd()
            self.records.append(_elem343)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.keys = []
          (_etype354, _size351) = iprot.readListBegin()
          for _i355 in xrange(_size351):
            _elem356 = iprot.readString();
            self.keys.append(_elem356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.throttled = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataConsumeResult')
    if self.nextConsumeOffset is not None:
      oprot.writeFieldBegin('nextConsumeOffset', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nextConsumeOffset))
      for kiter357,viter358 in self.nextConsumeOffset.items():
        oprot.writeString(kiter357)
        viter358.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.records))
      for iter359 in self.records:
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(iter359))
        for kiter360,viter361 in iter359.items():
          oprot.writeString(kiter360)
          viter361.write(oprot)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter362 in self.keys:
        oprot.writeString(iter362)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throttled is not None:
      oprot.writeFieldBegin('throttled', TType.BOOL, 4)
      oprot.writeBool(self.throttled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.nextConsumeOffset)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.throttled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EditConsumeRequest(object):
  """
  增量数据的消费请求

  Attributes:
   - tableName: 表名
   - partitionId: 表分区ID
   - subscriberName: 订阅者名字
   - consumeNumber: 消费数量
   - consumeOffset: 消费偏移
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.I32, 'partitionId', None, None, ), # 2
    (3, TType.STRING, 'subscriberName', None, None, ), # 3
    (4, TType.I32, 'consumeNumber', None, None, ), # 4
    (5, TType.I64, 'consumeOffset', None, -1, ), # 5
  )

  def __init__(self, tableName=None, partitionId=None, subscriberName=None, consumeNumber=None, consumeOffset=thrift_spec[5][4],):
    self.tableName = tableName
    self.partitionId = partitionId
    self.subscriberName = subscriberName
    self.consumeNumber = consumeNumber
    self.consumeOffset = consumeOffset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partitionId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.subscriberName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.consumeNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.consumeOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EditConsumeRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partitionId is not None:
      oprot.writeFieldBegin('partitionId', TType.I32, 2)
      oprot.writeI32(self.partitionId)
      oprot.writeFieldEnd()
    if self.subscriberName is not None:
      oprot.writeFieldBegin('subscriberName', TType.STRING, 3)
      oprot.writeString(self.subscriberName)
      oprot.writeFieldEnd()
    if self.consumeNumber is not None:
      oprot.writeFieldBegin('consumeNumber', TType.I32, 4)
      oprot.writeI32(self.consumeNumber)
      oprot.writeFieldEnd()
    if self.consumeOffset is not None:
      oprot.writeFieldBegin('consumeOffset', TType.I64, 5)
      oprot.writeI64(self.consumeOffset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partitionId)
    value = (value * 31) ^ hash(self.subscriberName)
    value = (value * 31) ^ hash(self.consumeNumber)
    value = (value * 31) ^ hash(self.consumeOffset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EditConsumeResult(object):
  """
  Attributes:
   - nextConsumeOffset: 下一个开始消费的增量数据的偏移，NULL表示达到当前表分片的结束位置
   - rowEdits: 消费的增量数据
   - throttled: 是否超过表的qps quota
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'nextConsumeOffset', None, None, ), # 1
    (2, TType.LIST, 'rowEdits', (TType.STRUCT,(RowEdit, RowEdit.thrift_spec)), None, ), # 2
    (3, TType.BOOL, 'throttled', None, None, ), # 3
  )

  def __init__(self, nextConsumeOffset=None, rowEdits=None, throttled=None,):
    self.nextConsumeOffset = nextConsumeOffset
    self.rowEdits = rowEdits
    self.throttled = throttled

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.nextConsumeOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.rowEdits = []
          (_etype366, _size363) = iprot.readListBegin()
          for _i367 in xrange(_size363):
            _elem368 = RowEdit()
            _elem368.read(iprot)
            self.rowEdits.append(_elem368)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.throttled = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EditConsumeResult')
    if self.nextConsumeOffset is not None:
      oprot.writeFieldBegin('nextConsumeOffset', TType.I64, 1)
      oprot.writeI64(self.nextConsumeOffset)
      oprot.writeFieldEnd()
    if self.rowEdits is not None:
      oprot.writeFieldBegin('rowEdits', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.rowEdits))
      for iter369 in self.rowEdits:
        iter369.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.throttled is not None:
      oprot.writeFieldBegin('throttled', TType.BOOL, 3)
      oprot.writeBool(self.throttled)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.nextConsumeOffset)
    value = (value * 31) ^ hash(self.rowEdits)
    value = (value * 31) ^ hash(self.throttled)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataCommitRequest(object):
  """
  存量数据的消费请求回执

  Attributes:
   - tableName: 表名
   - partitionId: 表分区ID
   - subscriberName: 订阅者名字
   - lastConsumedOffset: 当前消费存量数据的最后偏移
   - commitNumber: 确认消费数量
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.I32, 'partitionId', None, None, ), # 2
    (3, TType.STRING, 'subscriberName', None, None, ), # 3
    (4, TType.MAP, 'lastConsumedOffset', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 4
    (5, TType.I32, 'commitNumber', None, None, ), # 5
  )

  def __init__(self, tableName=None, partitionId=None, subscriberName=None, lastConsumedOffset=None, commitNumber=None,):
    self.tableName = tableName
    self.partitionId = partitionId
    self.subscriberName = subscriberName
    self.lastConsumedOffset = lastConsumedOffset
    self.commitNumber = commitNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partitionId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.subscriberName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.lastConsumedOffset = {}
          (_ktype371, _vtype372, _size370 ) = iprot.readMapBegin()
          for _i374 in xrange(_size370):
            _key375 = iprot.readString();
            _val376 = Datum()
            _val376.read(iprot)
            self.lastConsumedOffset[_key375] = _val376
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.commitNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataCommitRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partitionId is not None:
      oprot.writeFieldBegin('partitionId', TType.I32, 2)
      oprot.writeI32(self.partitionId)
      oprot.writeFieldEnd()
    if self.subscriberName is not None:
      oprot.writeFieldBegin('subscriberName', TType.STRING, 3)
      oprot.writeString(self.subscriberName)
      oprot.writeFieldEnd()
    if self.lastConsumedOffset is not None:
      oprot.writeFieldBegin('lastConsumedOffset', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.lastConsumedOffset))
      for kiter377,viter378 in self.lastConsumedOffset.items():
        oprot.writeString(kiter377)
        viter378.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.commitNumber is not None:
      oprot.writeFieldBegin('commitNumber', TType.I32, 5)
      oprot.writeI32(self.commitNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partitionId)
    value = (value * 31) ^ hash(self.subscriberName)
    value = (value * 31) ^ hash(self.lastConsumedOffset)
    value = (value * 31) ^ hash(self.commitNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataCommitResult(object):
  """
  Attributes:
   - success: 消费请求回执是否被服务器成功接收
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataCommitResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EditCommitRequest(object):
  """
  增量数据的消费请求回执

  Attributes:
   - tableName: 表名
   - partitionId: 表分区ID
   - subscriberName: 订阅者名字
   - lastConsumedOffset: 当前消费增量数据的最后偏移
   - commitNumber: 确认消费数量
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.I32, 'partitionId', None, None, ), # 2
    (3, TType.STRING, 'subscriberName', None, None, ), # 3
    (4, TType.I64, 'lastConsumedOffset', None, None, ), # 4
    (5, TType.I32, 'commitNumber', None, None, ), # 5
  )

  def __init__(self, tableName=None, partitionId=None, subscriberName=None, lastConsumedOffset=None, commitNumber=None,):
    self.tableName = tableName
    self.partitionId = partitionId
    self.subscriberName = subscriberName
    self.lastConsumedOffset = lastConsumedOffset
    self.commitNumber = commitNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partitionId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.subscriberName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.lastConsumedOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.commitNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EditCommitRequest')
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partitionId is not None:
      oprot.writeFieldBegin('partitionId', TType.I32, 2)
      oprot.writeI32(self.partitionId)
      oprot.writeFieldEnd()
    if self.subscriberName is not None:
      oprot.writeFieldBegin('subscriberName', TType.STRING, 3)
      oprot.writeString(self.subscriberName)
      oprot.writeFieldEnd()
    if self.lastConsumedOffset is not None:
      oprot.writeFieldBegin('lastConsumedOffset', TType.I64, 4)
      oprot.writeI64(self.lastConsumedOffset)
      oprot.writeFieldEnd()
    if self.commitNumber is not None:
      oprot.writeFieldBegin('commitNumber', TType.I32, 5)
      oprot.writeI32(self.commitNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.partitionId)
    value = (value * 31) ^ hash(self.subscriberName)
    value = (value * 31) ^ hash(self.lastConsumedOffset)
    value = (value * 31) ^ hash(self.commitNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EditCommitResult(object):
  """
  Attributes:
   - success: 消费请求回执是否被服务器成功接收
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'success', None, None, ), # 1
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EditCommitResult')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 1)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConsumedOffset(object):
  """
  Attributes:
   - consumedDataOffset: 当前存量数据的消费偏移
   - dataConsumeFinished: 存量数据是否消费完毕
   - consumedEditOffset: 当前增量数据的消费偏移
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'consumedDataOffset', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'dataConsumeFinished', None, None, ), # 2
    (3, TType.I64, 'consumedEditOffset', None, None, ), # 3
  )

  def __init__(self, consumedDataOffset=None, dataConsumeFinished=None, consumedEditOffset=None,):
    self.consumedDataOffset = consumedDataOffset
    self.dataConsumeFinished = dataConsumeFinished
    self.consumedEditOffset = consumedEditOffset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.consumedDataOffset = {}
          (_ktype380, _vtype381, _size379 ) = iprot.readMapBegin()
          for _i383 in xrange(_size379):
            _key384 = iprot.readString();
            _val385 = Datum()
            _val385.read(iprot)
            self.consumedDataOffset[_key384] = _val385
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.dataConsumeFinished = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.consumedEditOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConsumedOffset')
    if self.consumedDataOffset is not None:
      oprot.writeFieldBegin('consumedDataOffset', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.consumedDataOffset))
      for kiter386,viter387 in self.consumedDataOffset.items():
        oprot.writeString(kiter386)
        viter387.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.dataConsumeFinished is not None:
      oprot.writeFieldBegin('dataConsumeFinished', TType.BOOL, 2)
      oprot.writeBool(self.dataConsumeFinished)
      oprot.writeFieldEnd()
    if self.consumedEditOffset is not None:
      oprot.writeFieldBegin('consumedEditOffset', TType.I64, 3)
      oprot.writeI64(self.consumedEditOffset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.consumedDataOffset)
    value = (value * 31) ^ hash(self.dataConsumeFinished)
    value = (value * 31) ^ hash(self.consumedEditOffset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommittedOffset(object):
  """
  Attributes:
   - committedDataOffset: 当前存量数据已确认的消费偏移
   - dataCommitFinished: 存量数据是否确认消费完毕
   - committedEditOffset: 当前增量数据已确认的消费偏移
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'committedDataOffset', (TType.STRING,None,TType.STRUCT,(Datum, Datum.thrift_spec)), None, ), # 1
    (2, TType.BOOL, 'dataCommitFinished', None, None, ), # 2
    (3, TType.I64, 'committedEditOffset', None, None, ), # 3
  )

  def __init__(self, committedDataOffset=None, dataCommitFinished=None, committedEditOffset=None,):
    self.committedDataOffset = committedDataOffset
    self.dataCommitFinished = dataCommitFinished
    self.committedEditOffset = committedEditOffset

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.committedDataOffset = {}
          (_ktype389, _vtype390, _size388 ) = iprot.readMapBegin()
          for _i392 in xrange(_size388):
            _key393 = iprot.readString();
            _val394 = Datum()
            _val394.read(iprot)
            self.committedDataOffset[_key393] = _val394
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.dataCommitFinished = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.committedEditOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommittedOffset')
    if self.committedDataOffset is not None:
      oprot.writeFieldBegin('committedDataOffset', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.committedDataOffset))
      for kiter395,viter396 in self.committedDataOffset.items():
        oprot.writeString(kiter395)
        viter396.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.dataCommitFinished is not None:
      oprot.writeFieldBegin('dataCommitFinished', TType.BOOL, 2)
      oprot.writeBool(self.dataCommitFinished)
      oprot.writeFieldEnd()
    if self.committedEditOffset is not None:
      oprot.writeFieldBegin('committedEditOffset', TType.I64, 3)
      oprot.writeI64(self.committedEditOffset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.committedDataOffset)
    value = (value * 31) ^ hash(self.dataCommitFinished)
    value = (value * 31) ^ hash(self.committedEditOffset)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
