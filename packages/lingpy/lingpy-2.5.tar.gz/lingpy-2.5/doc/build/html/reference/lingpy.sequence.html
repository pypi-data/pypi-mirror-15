<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lingpy.sequence package &mdash; LingPy</title>
    
    <link rel="stylesheet" href="../_static/lingpy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="LingPy" href="../index.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />

  </head>
  <body role="document">
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lingpy-sequence-package">
<h1>lingpy.sequence package<a class="headerlink" href="#lingpy-sequence-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-lingpy.sequence.generate">
<span id="lingpy-sequence-generate-module"></span><h2>lingpy.sequence.generate module<a class="headerlink" href="#module-lingpy.sequence.generate" title="Permalink to this headline">¶</a></h2>
<p>Module provides simple basic classes for sequence generation using Markov models.</p>
<dl class="class">
<dt id="lingpy.sequence.generate.MCBasic">
<em class="property">class </em><code class="descclassname">lingpy.sequence.generate.</code><code class="descname">MCBasic</code><span class="sig-paren">(</span><em>seqs</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.generate.MCBasic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Basic class for creating Markov chains from sequence training data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seq</strong> : list</p>
<blockquote class="last">
<div><p>A list of sequences. Sequences are assumed to be tokenized, i.e. they
should be either passed as lists or as tuples.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.sequence.generate.MCBasic.walk">
<code class="descname">walk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.generate.MCBasic.walk" title="Permalink to this definition">¶</a></dt>
<dd><p>Create random sequence from the distribution.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.sequence.generate.MCPhon">
<em class="property">class </em><code class="descclassname">lingpy.sequence.generate.</code><code class="descname">MCPhon</code><span class="sig-paren">(</span><em>words</em>, <em>tokens=False</em>, <em>prostrings=[]</em>, <em>classes=False</em>, <em>class_model=&lt;sca-model &quot;sca&quot;&gt;</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.generate.MCPhon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.sequence.generate.MCBasic" title="lingpy.sequence.generate.MCBasic"><code class="xref py py-class docutils literal"><span class="pre">lingpy.sequence.generate.MCBasic</span></code></a></p>
<p>Class for the creation of phonetic sequences (&#8220;pseudo words&#8221;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>words</strong> : list</p>
<blockquote>
<div><p>List of phonetic sequences. This list can contain tokenized
sequences (lists or tuples), or simple untokenized IPA strings.</p>
</div></blockquote>
<p><strong>tokens</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to True, no tokenization of input sequences is carried out.</p>
</div></blockquote>
<p><strong>prostring</strong> : list (default=[])</p>
<blockquote class="last">
<div><p>List containing the prosodic profiles of the input sequences. If the
list is empty, the profiles are generated automatically.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.sequence.generate.MCPhon.evaluate_string">
<code class="descname">evaluate_string</code><span class="sig-paren">(</span><em>string</em>, <em>tokens=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.generate.MCPhon.evaluate_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.sequence.generate.MCPhon.get_string">
<code class="descname">get_string</code><span class="sig-paren">(</span><em>new=True</em>, <em>tokens=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.generate.MCPhon.get_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a string from the Markov chain created from the training data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new</strong> : bool (default=True)</p>
<blockquote>
<div><p>Determine whether the string created should be different from the
training data or not.</p>
</div></blockquote>
<p><strong>tokens</strong> : bool (default=False)</p>
<blockquote class="last">
<div><p>If set to <em>True</em> he full list of tokens that was internally used to
represent the sequences as a Markov chain is returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lingpy.sequence.sound_classes">
<span id="lingpy-sequence-sound-classes-module"></span><h2>lingpy.sequence.sound_classes module<a class="headerlink" href="#module-lingpy.sequence.sound_classes" title="Permalink to this headline">¶</a></h2>
<p>Module provides various methods for the handling of sound classes.</p>
<dl class="function">
<dt id="lingpy.sequence.sound_classes.asjp2tokens">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">asjp2tokens</code><span class="sig-paren">(</span><em>seq</em>, <em>merge_vowels=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.asjp2tokens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.bigrams">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">bigrams</code><span class="sig-paren">(</span><em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.bigrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a given sequence into a sequence of bigrams.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.check_tokens">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">check_tokens</code><span class="sig-paren">(</span><em>tokens</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.check_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Function checks whether tokens are given in a consistent input format.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.class2tokens">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">class2tokens</code><span class="sig-paren">(</span><em>tokens</em>, <em>classes</em>, <em>gap_char='-'</em>, <em>local=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.class2tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn aligned sound-class sequences into an aligned sequences of IPA tokens.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tokens</strong> : list</p>
<blockquote>
<div><p>The list of tokens corresponding to the unaligned IPA string.</p>
</div></blockquote>
<p><strong>classes</strong> : string or list</p>
<blockquote>
<div><p>The aligned class string.</p>
</div></blockquote>
<p><strong>gap_char</strong> : string (default=&#8221;-&#8221;)</p>
<blockquote>
<div><p>The character which indicates gaps in the output string.</p>
</div></blockquote>
<p><strong>local</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <em>True</em> a local alignment with prefix and suffix can be
converted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alignment</strong> : list</p>
<blockquote class="last">
<div><p>A list of tokens with gaps at the positions where they occured in the
alignment of the class string.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.sequence.sound_classes.ipa2tokens" title="lingpy.sequence.sound_classes.ipa2tokens"><code class="xref py py-obj docutils literal"><span class="pre">ipa2tokens</span></code></a>, <a class="reference internal" href="#lingpy.sequence.sound_classes.tokens2class" title="lingpy.sequence.sound_classes.tokens2class"><code class="xref py py-obj docutils literal"><span class="pre">tokens2class</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span> <span class="o">=</span> <span class="n">ipa2tokens</span><span class="p">(</span><span class="s1">&#39;t͡sɔyɡə&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aligned_sequence</span> <span class="o">=</span> <span class="s1">&#39;CU-KE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">class2tokens</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="n">aligned_sequence</span><span class="p">))</span>
<span class="go">t͡s, ɔy, -, ɡ, ə</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.fourgrams">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">fourgrams</code><span class="sig-paren">(</span><em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.fourgrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a given sequence into a sequence of trigrams.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.get_all_ngrams">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">get_all_ngrams</code><span class="sig-paren">(</span><em>sequence</em>, <em>sort=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.get_all_ngrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns all possible n-grams of a given sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sequence</strong> : list or str</p>
<blockquote>
<div><p>The sequence that shall be converted into it&#8217;s ngram-representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : list</p>
<blockquote class="last">
<div><p>A list of all ngrams of the input word, sorted in decreasing order of
length.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_all_ngrams</span><span class="p">(</span><span class="s1">&#39;abcde&#39;</span><span class="p">)</span>
<span class="go">[&#39;abcde&#39;, &#39;bcde&#39;, &#39;abcd&#39;, &#39;cde&#39;, &#39;abc&#39;, &#39;bcd&#39;, &#39;ab&#39;, &#39;de&#39;, &#39;cd&#39;, &#39;bc&#39;, &#39;a&#39;, &#39;e&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.get_n_ngrams">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">get_n_ngrams</code><span class="sig-paren">(</span><em>sequence</em>, <em>ngram=4</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.get_n_ngrams" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a given sequence into a sequence of ngrams.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.ipa2tokens">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">ipa2tokens</code><span class="sig-paren">(</span><em>istring</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.ipa2tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Tokenize IPA-encoded strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seq</strong> : str</p>
<blockquote>
<div><p>The input sequence that shall be tokenized.</p>
</div></blockquote>
<p><strong>diacritics</strong> : {str, None} (default=None)</p>
<blockquote>
<div><p>A string containing all diacritics which shall be considered in the
respective analysis. When set to <em>None</em>, the default diacritic string
will be used.</p>
</div></blockquote>
<p><strong>vowels</strong> : {str, None} (default=None)</p>
<blockquote>
<div><p>A string containing all vowel symbols which shall be considered in the
respective analysis. When set to <em>None</em>, the default vowel string will
be used.</p>
</div></blockquote>
<p><strong>tones</strong> : {str, None} (default=None)</p>
<blockquote>
<div><p>A string indicating all tone letter symbals which shall be considered
in the respective analysis. When set to <em>None</em>, the default tone string
will be used.</p>
</div></blockquote>
<p><strong>combiners</strong> : str (default=&#8221;͜͡&#8221;)</p>
<blockquote>
<div><p>A string with characters that are used to combine two separate
characters (compare affricates such as t͡s).</p>
</div></blockquote>
<p><strong>breaks</strong> : str (default=&#8221;-.&#8221;)</p>
<blockquote>
<div><p>A string containing the characters that indicate that a new token
starts right after them. These can be used to indicate that two
consecutive vowels should not be treated as diphtongs or for diacritics
that are put before the following letter.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=False)</p>
<blockquote>
<div><p>Indicate, whether vowels should be merged into diphtongs
(default=True), or whether each vowel symbol should be considered
separately.</p>
</div></blockquote>
<p><strong>merge_geminates</strong> : bool (default=False)</p>
<blockquote>
<div><p>Indicate, whether identical symbols should be merged into one token, or
rather be kept separate.</p>
</div></blockquote>
<p><strong>expand_nasals</strong> : bool (default=False)</p>
<p><strong>semi_diacritics: str (default=&#8217;&#8216;)</strong> :</p>
<blockquote>
<div><p>Indicate which symbols shall be treated as &#8220;semi-diacritics&#8221;, that is,
as symbols which can occur on their own, but which eventually, when
preceded by a consonant, will form clusters with it. If you want to
disable this features, just set the keyword to an empty string.</p>
</div></blockquote>
<p><strong>clean_string</strong> : bool (default=False)</p>
<blockquote>
<div><p>Conduct a rough string-cleaning strategy by which all items between
brackets are removed along with the brackets, and</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tokens</strong> : list</p>
<blockquote class="last">
<div><p>A list of IPA tokens.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.sequence.sound_classes.tokens2class" title="lingpy.sequence.sound_classes.tokens2class"><code class="xref py py-obj docutils literal"><span class="pre">tokens2class</span></code></a>, <a class="reference internal" href="#lingpy.sequence.sound_classes.class2tokens" title="lingpy.sequence.sound_classes.class2tokens"><code class="xref py py-obj docutils literal"><span class="pre">class2tokens</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myseq</span> <span class="o">=</span> <span class="s1">&#39;t͡sɔyɡə&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipa2tokens</span><span class="p">(</span><span class="n">myseq</span><span class="p">)</span>
<span class="go">[&#39;t͡s&#39;, &#39;ɔy&#39;, &#39;ɡ&#39;, &#39;ə&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.ono_parse">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">ono_parse</code><span class="sig-paren">(</span><em>word</em>, <em>output=''</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.ono_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a rough onset-nucleus-offset parse of a word in IPA.</p>
<p class="rubric">Notes</p>
<p>Method is an approximation and not supposed to do without flaws. It is,
however, rather helpful in most instances. It defines a so far simple model
in which 7 different contexts for each word are distinguished:</p>
<ul class="simple">
<li>&#8220;#&#8221;: onset cluster in a word&#8217;s initial</li>
<li>&#8220;C&#8221;: onset cluster in a word&#8217;s non-initial</li>
<li>&#8220;V&#8221;: nucleus vowel in a word&#8217;s initial syllable</li>
<li>&#8220;v&#8221;: nucleus vowel in a word&#8217;s non-initial and non-final syllable</li>
<li>&#8220;&gt;&#8221;: nucleus vowel in a word&#8217;s final syllable</li>
<li>&#8220;c&#8221;: offset cluster in a word&#8217;s non-final syllable</li>
<li>&#8220;$&#8221;: offset cluster in a word&#8217;s final syllable</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.pgrams">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">pgrams</code><span class="sig-paren">(</span><em>sequence</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.pgrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a given sequence into bigrams consisting of prosodic string symbols and the
tokens of the original sequence.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.pid">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">pid</code><span class="sig-paren">(</span><em>almA</em>, <em>almB</em>, <em>mode=2</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Percentage Identity (PID) score for aligned sequence pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>almA, almB</strong> : string or list</p>
<blockquote>
<div><p>The aligned sequences which can be either a string or a list.</p>
</div></blockquote>
<p><strong>mode</strong> : { 1, 2, 3, 4, 5 }</p>
<blockquote>
<div><p>Indicate which of the four possible PID scores described in <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Raghava2006"><span class="pre">Raghava2006</span></a></code>
should be calculated, the fifth possibility is added for linguistic
purposes:</p>
<ol class="arabic simple">
<li>identical positions / (aligned positions + internal gap positions),</li>
<li>identical positions / aligned positions,</li>
<li>identical positions / shortest sequence, or</li>
<li>identical positions / shortest sequence (including internal gap
pos.)</li>
<li>identical positions / (aligned positions + 2 * number of gaps)</li>
</ol>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>The PID score of the given alignment as a floating point number between
0 and 1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">lingpy.compare.Multiple.get_pid</span></code>, <code class="xref py py-obj docutils literal"></code></p>
</div>
<p class="rubric">Notes</p>
<p>The PID score is a common measure for the diversity of a given alignment.
The implementation employed by LingPy follows the description of
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Raghava2006"><span class="pre">Raghava2006</span></a></code> where four different variants of PID scores are
distinguished. Essentially, the PID score is based on the comparison of
identical residue pairs with the total number of residue pairs in a given
alignment.</p>
<p class="rubric">Examples</p>
<p>Load an alignment from the test suite.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="n">PSA</span><span class="p">(</span><span class="n">get_file</span><span class="p">(</span><span class="s1">&#39;test.psa&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Extract the alignments of the first aligned sequence pair.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">almA</span><span class="p">,</span><span class="n">almB</span><span class="p">,</span><span class="n">score</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">alignments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Calculate the PID score of the alignment.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pid</span><span class="p">(</span><span class="n">almA</span><span class="p">,</span><span class="n">almB</span><span class="p">)</span>
<span class="go">0.44444444444444442</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.prosodic_string">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">prosodic_string</code><span class="sig-paren">(</span><em>string</em>, <em>_output=True</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.prosodic_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a prosodic string of the sonority profile of a sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seq</strong> : list</p>
<blockquote>
<div><p>A list of integers indicating the sonority of the tokens of the
underlying sequence.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>prostring</strong> : string</p>
<blockquote class="last">
<div><p>A prosodic string corresponding to the sonority profile of the
underlying sequence.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A prosodic string is a sequence of specific characters which indicating
their resprective prosodic context (see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code> or
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code> for a detailed description).
In contrast to the previous model, the current implementation allows for a
more fine-graded distinction between different prosodic segments. The
current scheme distinguishes 9 prosodic positions:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">A</span></code>: sequence-initial consonant</li>
<li><code class="docutils literal"><span class="pre">B</span></code>: syllable-initial, non-sequence initial consonant in a context of
ascending sonority</li>
<li><code class="docutils literal"><span class="pre">C</span></code>: non-syllable, non-initial consonant in ascending sonority context</li>
<li><code class="docutils literal"><span class="pre">L</span></code>: non-syllable-final consonant in descending environment</li>
<li><code class="docutils literal"><span class="pre">M</span></code>: syllable-final consonant in descending environment</li>
<li><code class="docutils literal"><span class="pre">N</span></code>: word-final consonant</li>
<li><code class="docutils literal"><span class="pre">X</span></code>: first vowel in a word</li>
<li><code class="docutils literal"><span class="pre">Y</span></code>: non-final vowel in a word</li>
<li><code class="docutils literal"><span class="pre">Z</span></code>: vowel occuring in the last position of a word</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prosodic_string</span><span class="p">(</span><span class="n">ipa2tokens</span><span class="p">(</span><span class="s1">&#39;t͡sɔyɡə&#39;</span><span class="p">)</span>
<span class="go">&#39;AXBZ&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.prosodic_weights">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">prosodic_weights</code><span class="sig-paren">(</span><em>prostring</em>, <em>_transform={}</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.prosodic_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate prosodic weights for each position of a sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>prostring</strong> : string</p>
<blockquote>
<div><p>A prosodic string as it is returned by <a class="reference internal" href="#lingpy.sequence.sound_classes.prosodic_string" title="lingpy.sequence.sound_classes.prosodic_string"><code class="xref py py-func docutils literal"><span class="pre">prosodic_string()</span></code></a>.</p>
</div></blockquote>
<p><strong>_transform</strong> : dict</p>
<blockquote>
<div><p>A dictionary that determines how prosodic strings should be transformed
into prosodic weights. Use this dictionary to adjust the prosodic
strings to your own user-defined prosodic weight schema.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>weights</strong> : list</p>
<blockquote class="last">
<div><p>A list of floats reflecting the modification of the weight for each position.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.sequence.sound_classes.prosodic_string" title="lingpy.sequence.sound_classes.prosodic_string"><code class="xref py py-obj docutils literal"><span class="pre">prosodic_string</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Prosodic weights are specific scaling factors which decrease or increase
the gap score of a given segment in alignment analyses (see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code> or
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code> for a detailed description).</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prostring</span> <span class="o">=</span> <span class="s1">&#39;#vC&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prosodic_weights</span><span class="p">(</span><span class="n">prostring</span><span class="p">)</span>
<span class="go">[2.0, 1.3, 1.5, 0.7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.sampa2uni">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">sampa2uni</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.sampa2uni" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert sequence in IPA-sampa-format to IPA-unicode.</p>
<p class="rubric">Notes</p>
<p>This function is based on code taken from Peter Kleiweg
(<a class="reference external" href="http://www.let.rug.nl/~kleiweg/L04/devel/python/xsampa.html">http://www.let.rug.nl/~kleiweg/L04/devel/python/xsampa.html</a>).</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.syllabify">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">syllabify</code><span class="sig-paren">(</span><em>seq</em>, <em>output='flat'</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.syllabify" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a simple syllabification of a sequence, using sonority as a proxy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>output: {&#8220;flat&#8221;, &#8220;breakpoints&#8221;, &#8220;nested&#8221;} (default=&#8221;flat&#8221;)</strong> :</p>
<blockquote>
<div><p>Define how to output the syllabification. Select between:
* &#8220;flat&#8221;: A syllable separator is introduced to mark the syllable boundaries
* &#8220;breakpoins&#8221;: A tuple consisting of indices that slice the original sequence into syllables is returned.
* &#8220;nested&#8221;: A nested list reflecting the syllable structure is returned.</p>
</div></blockquote>
<p><strong>sep</strong> : str (default=&#8221;◦&#8221;)</p>
<blockquote>
<div><p>Select your preferred syllable separator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>syllable</strong> : list</p>
<blockquote class="last">
<div><p>Either a flat list containing a morpheme separator, or a nested list,
reflecting the syllable structure, or a list of tuples containing the
indices indicating where the input sequence should be sliced in order
to split it into syllables.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>When analyzing the sequence, we start a new syllable in all cases where we
reach a deepest point in the sonority hierarchy of the sonority profile of
the sequence. When passing an aligned string to this function, the gaps
will be ignored when computing boundaries, but later on re-introduced, if
the alignment is passed in segmented form.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.token2class">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">token2class</code><span class="sig-paren">(</span><em>token</em>, <em>model</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.token2class" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a single token into a sound-class.</p>
<dl class="docutils">
<dt>tokens</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>A token (IPA-string).</dd>
<dt>model</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a></span><dd>A <a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a> object.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>c</strong> : str</p>
<blockquote class="last">
<div><p>The corresponding sound-class value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.tokens2class">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">tokens2class</code><span class="sig-paren">(</span><em>tstring</em>, <em>model</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.tokens2class" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert tokenized IPA strings into their respective class strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tokens</strong> : list</p>
<blockquote>
<div><p>A list of tokens as they are returned from <a class="reference internal" href="#lingpy.sequence.sound_classes.ipa2tokens" title="lingpy.sequence.sound_classes.ipa2tokens"><code class="xref py py-func docutils literal"><span class="pre">ipa2tokens()</span></code></a>.</p>
</div></blockquote>
<p><strong>model</strong> : <a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a></p>
<blockquote>
<div><p>A <a class="reference internal" href="lingpy.data.html#lingpy.data.model.Model" title="lingpy.data.model.Model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a> object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>classes</strong> : string</p>
<blockquote class="last">
<div><p>A sound-class representation of the tokenized IPA string.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.sequence.sound_classes.ipa2tokens" title="lingpy.sequence.sound_classes.ipa2tokens"><code class="xref py py-obj docutils literal"><span class="pre">ipa2tokens</span></code></a>, <a class="reference internal" href="#lingpy.sequence.sound_classes.class2tokens" title="lingpy.sequence.sound_classes.class2tokens"><code class="xref py py-obj docutils literal"><span class="pre">class2tokens</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span> <span class="o">=</span> <span class="n">ipa2tokens</span><span class="p">(</span><span class="s1">&#39;t͡sɔyɡə&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classes</span> <span class="o">=</span> <span class="n">tokens2class</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="s1">&#39;sca&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
<span class="go">CUKE</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.tokens2morphemes">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">tokens2morphemes</code><span class="sig-paren">(</span><em>tokens</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.tokens2morphemes" title="Permalink to this definition">¶</a></dt>
<dd><p>Function splits a list of tokens into subsequent lists of morphemes if the list
contains morpheme separators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sep</strong> : str (default=&#8221;◦&#8221;)</p>
<blockquote>
<div><p>Select your morpheme separator.</p>
</div></blockquote>
<p><strong>word_sep: str (default=&#8221;_&#8221;)</strong> :</p>
<blockquote>
<div><p>Select your word separator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>morphemes</strong> : list</p>
<blockquote class="last">
<div><p>A nested list of the original segments split into morphemes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lingpy.sequence.sound_classes.trigrams">
<code class="descclassname">lingpy.sequence.sound_classes.</code><code class="descname">trigrams</code><span class="sig-paren">(</span><em>sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.sequence.sound_classes.trigrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a given sequence into a sequence of trigrams.</p>
</dd></dl>

</div>
<div class="section" id="module-lingpy.sequence">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lingpy.sequence" title="Permalink to this headline">¶</a></h2>
<p>Module provides methods and functions for dealing with linguistic sequences.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy-logo.svg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">lingpy.sequence package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-lingpy.sequence.generate">lingpy.sequence.generate module</a></li>
<li><a class="reference internal" href="#module-lingpy.sequence.sound_classes">lingpy.sequence.sound_classes module</a></li>
<li><a class="reference internal" href="#module-lingpy.sequence">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/lingpy.sequence.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>
 <div id="footer" style="align-items:center;padding-top:5px;padding-left:0px;display:flex;justify-content:space-between;">

   <div>
     <a href="http://ssh.mpg.de"><img width="60px" src="../_static/minerva.png" alt="MPG-SSH" /></a>
   </div>
  <div>
    <a href="http://dfg.de/"><img width="80px" src="../_static/dfg_logo_schwarz.jpg" alt="DFG" /></a>
  </div>

  <div style="max-width:300px;">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated
    on May 17, 2016<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">Creative
      Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a> </p>
  </div>

  <div>
    <a href="http://erc.europa.eu/"><img width="80px" src="http://quanthistling.info/theme/qhl/images/logo_erc.png" alt="ERC" /></a>
  </div>
  <div style="max-width:150px;text-align:right;">
    <a href="http://github.com/lingpy/lingpy/">Application source on</a> 
    <a href="https://github.com/"><img width="100px" src="../_static/GitHub_Logo.png" alt="github logo" /></a>
</div>
</div>

  </body>
</html>