<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lingpy.basic package &mdash; LingPy</title>
    
    <link rel="stylesheet" href="../_static/lingpy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="LingPy" href="../index.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />

  </head>
  <body role="document">
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lingpy-basic-package">
<h1>lingpy.basic package<a class="headerlink" href="#lingpy-basic-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-lingpy.basic.ops">
<span id="lingpy-basic-ops-module"></span><h2>lingpy.basic.ops module<a class="headerlink" href="#module-lingpy.basic.ops" title="Permalink to this headline">¶</a></h2>
<p>Module provides basic operations on Wordlist-Objects.</p>
<dl class="function">
<dt id="lingpy.basic.ops.calculate_data">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">calculate_data</code><span class="sig-paren">(</span><em>wordlist</em>, <em>data</em>, <em>taxa='taxa'</em>, <em>concepts='concepts'</em>, <em>ref='cogid'</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.calculate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Manipulate a wordlist object by adding different kinds of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : str</p>
<blockquote class="last">
<div><p>The type of data that shall be calculated. Currently supports</p>
<ul class="simple">
<li>&#8220;tree&#8221;: calculate a reference tree based on shared cognates</li>
<li>&#8220;dst&#8221;: get distances between taxa based on shared cognates</li>
<li>&#8220;cluster&#8221;: cluster the taxa into groups using different methods</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.clean_taxnames">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">clean_taxnames</code><span class="sig-paren">(</span><em>wordlist</em>, <em>column='doculect'</em>, <em>f=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.clean_taxnames" title="Permalink to this definition">¶</a></dt>
<dd><p>Function cleans taxon names in order to make sure they can be used in Newick files.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.coverage">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">coverage</code><span class="sig-paren">(</span><em>wordlist</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the average coverage of a wordlist.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.get_score">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">get_score</code><span class="sig-paren">(</span><em>wl</em>, <em>ref</em>, <em>mode</em>, <em>taxA</em>, <em>taxB</em>, <em>concepts_attr='concepts'</em>, <em>ignore_missing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.get_score" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.renumber">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">renumber</code><span class="sig-paren">(</span><em>wordlist</em>, <em>source</em>, <em>target=''</em>, <em>override=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Create numerical identifiers from string identifiers.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.triple2tsv">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">triple2tsv</code><span class="sig-paren">(</span><em>triples_or_fname</em>, <em>output='table'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.triple2tsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Function reads in a triple file and converts it to a tabular data structure.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.tsv2triple">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">tsv2triple</code><span class="sig-paren">(</span><em>wordlist</em>, <em>outfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.tsv2triple" title="Permalink to this definition">¶</a></dt>
<dd><p>Function converts a wordlist to a triple data structure.</p>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The basic values of which the triples consist are:</dt>
<dd><ul class="first last simple">
<li>ID (the ID in the TSV file)</li>
<li>COLUMN (the column in the TSV file)</li>
<li>VALUE (the entry in the TSV file)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.wl2dict">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">wl2dict</code><span class="sig-paren">(</span><em>wordlist</em>, <em>sections</em>, <em>entries</em>, <em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.wl2dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wordlist to a complex dictionary with headings as keys.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.wl2dst">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">wl2dst</code><span class="sig-paren">(</span><em>wl</em>, <em>taxa='taxa'</em>, <em>concepts='concepts'</em>, <em>ref='cogid'</em>, <em>refB=''</em>, <em>mode='swadesh'</em>, <em>ignore_missing=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.wl2dst" title="Permalink to this definition">¶</a></dt>
<dd><p>Function converts wordlist to distance matrix.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.wl2multistate">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">wl2multistate</code><span class="sig-paren">(</span><em>wordlist</em>, <em>ref</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.wl2multistate" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function converts a wordlist to multistate format (compatible with PAUP).</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.basic.ops.wl2qlc">
<code class="descclassname">lingpy.basic.ops.</code><code class="descname">wl2qlc</code><span class="sig-paren">(</span><em>header</em>, <em>data</em>, <em>filename=''</em>, <em>formatter='concept'</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.ops.wl2qlc" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the basic data of a wordlist to file.</p>
</dd></dl>

</div>
<div class="section" id="module-lingpy.basic.parser">
<span id="lingpy-basic-parser-module"></span><h2>lingpy.basic.parser module<a class="headerlink" href="#module-lingpy.basic.parser" title="Permalink to this headline">¶</a></h2>
<p>Basic parser for text files in QLC format.</p>
<dl class="class">
<dt id="lingpy.basic.parser.QLCParser">
<em class="property">class </em><code class="descclassname">lingpy.basic.parser.</code><code class="descname">QLCParser</code><span class="sig-paren">(</span><em>filename</em>, <em>conf=''</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.parser.QLCParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Basic class for the handling of text files in QLC format.</p>
<dl class="method">
<dt id="lingpy.basic.parser.QLCParser.add_entries">
<code class="descname">add_entries</code><span class="sig-paren">(</span><em>entry</em>, <em>source</em>, <em>function</em>, <em>override=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.parser.QLCParser.add_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new entry-types to the word list by modifying given ones.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>entry</strong> : string</p>
<blockquote>
<div><p>A string specifying the name of the new entry-type to be added to the
word list.</p>
</div></blockquote>
<p><strong>source</strong> : string</p>
<blockquote>
<div><p>A string specifying the basic entry-type that shall be modified. If
multiple entry-types shall be used to create a new entry, they
should be passed in a simple string separated by a comma.</p>
</div></blockquote>
<p><strong>function</strong> : function</p>
<blockquote>
<div><p>A function which is used to convert the source into the target
value.</p>
</div></blockquote>
<p><strong>keywords</strong> : {dict}</p>
<blockquote class="last">
<div><p>A dictionary of keywords that are passed as parameters to the
function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method can be used to add new entry-types to the data by
converting given ones. There are a lot of possibilities for adding new
entries, but the most basic procedure is to use an existing entry-type
and to modify it with help of a function.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.parser.QLCParser.pickle">
<code class="descname">pickle</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.parser.QLCParser.pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the QLCParser instance in a pickle file.</p>
<p class="rubric">Notes</p>
<p>The function stores a binary file called <code class="docutils literal"><span class="pre">FILENAME.pkl</span></code> with <code class="docutils literal"><span class="pre">FILENAME</span></code>
corresponding to the name of the original file in the
<a class="reference external" href="https://github.com/ActiveState/appdirs#some-example-output">user cache dir</a>
for lingpy on your system.
To restore the instance from the pickle call
<a class="reference internal" href="#lingpy.basic.parser.QLCParser.unpickle" title="lingpy.basic.parser.QLCParser.unpickle"><code class="xref py py-meth docutils literal"><span class="pre">unpickle()</span></code></a>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lingpy.basic.parser.QLCParser.unpickle">
<em class="property">static </em><code class="descname">unpickle</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.parser.QLCParser.unpickle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.basic.parser.QLCParserWithRowsAndCols">
<em class="property">class </em><code class="descclassname">lingpy.basic.parser.</code><code class="descname">QLCParserWithRowsAndCols</code><span class="sig-paren">(</span><em>filename</em>, <em>row</em>, <em>col</em>, <em>conf</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.parser.QLCParserWithRowsAndCols" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.basic.parser.QLCParser" title="lingpy.basic.parser.QLCParser"><code class="xref py py-class docutils literal"><span class="pre">lingpy.basic.parser.QLCParser</span></code></a></p>
<dl class="method">
<dt id="lingpy.basic.parser.QLCParserWithRowsAndCols.get_entries">
<code class="descname">get_entries</code><span class="sig-paren">(</span><em>entry</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.parser.QLCParserWithRowsAndCols.get_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all entries matching the given entry-type as a two-dimensional list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>entry</strong> : string</p>
<blockquote class="last">
<div><p>The entry-type of the data that shall be returned in tabular
format.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lingpy.basic.tree">
<span id="lingpy-basic-tree-module"></span><h2>lingpy.basic.tree module<a class="headerlink" href="#module-lingpy.basic.tree" title="Permalink to this headline">¶</a></h2>
<p>Basic module for the handling of language trees.</p>
<dl class="class">
<dt id="lingpy.basic.tree.Tree">
<em class="property">class </em><code class="descclassname">lingpy.basic.tree.</code><code class="descname">Tree</code><span class="sig-paren">(</span><em>tree</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.tree.Tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingpy.thirdparty.cogent.html#lingpy.thirdparty.cogent.tree.PhyloNode" title="lingpy.thirdparty.cogent.tree.PhyloNode"><code class="xref py py-class docutils literal"><span class="pre">lingpy.thirdparty.cogent.tree.PhyloNode</span></code></a></p>
<p>Basic class for the handling of phylogenetic trees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tree</strong> : {str file list}</p>
<blockquote>
<div><p>A string or a file containing trees in Newick format. As an
alternative, you can also simply pass a list containing taxon names. In
that case, a random tree will be created from the list of taxa.</p>
</div></blockquote>
<p><strong>branch_lengths</strong> : bool (default=False)</p>
<blockquote class="last">
<div><p>When set to <em>True</em>, and a list of taxa is passed instead of a Newick
string or a file containing a Newick string, a random tree with random
branch lengths will be created with the branch lengths being in order
of the maximum number of the total number of internal branches.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.basic.tree.Tree.getDistanceToRoot">
<code class="descname">getDistanceToRoot</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.tree.Tree.getDistanceToRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance from the given node to the root.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>node</strong> : str</p>
<blockquote>
<div><p>The name of a given node in the tree.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>distance</strong> : int</p>
<blockquote class="last">
<div><p>The distance of the given node to the root of the tree.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.tree.Tree.get_distance">
<code class="descname">get_distance</code><span class="sig-paren">(</span><em>other</em>, <em>distance='grf'</em>, <em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.tree.Tree.get_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns the Robinson Fould distance between the two trees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>other</strong> : lingpy.basic.tree.Tree</p>
<blockquote>
<div><p>A tree object. It should have the same number of taxa as the
intitial tree.</p>
</div></blockquote>
<p><strong>distance</strong> : { &#8220;grf&#8221;, &#8220;rf&#8221;, &#8220;branch&#8221;, &#8220;symmetric&#8221;} (default=&#8221;grf&#8221;)</p>
<blockquote class="last">
<div><p>The distance which shall be calculated. Select between:</p>
<ul>
<li><p class="first">&#8220;grf&#8221;: the generalized Robinson Fould Distance</p>
</li>
<li><p class="first">&#8220;rf&#8221;: the Robinson Fould Distance</p>
</li>
<li><p class="first">&#8220;branch&#8221;: the distance in terms of branch lengths</p>
</li>
<li><dl class="first docutils">
<dt>&#8220;symmetric&#8221;: the symmetric difference between all partitions of</dt>
<dd><p class="first last">the trees</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.basic.tree.random_tree">
<code class="descclassname">lingpy.basic.tree.</code><code class="descname">random_tree</code><span class="sig-paren">(</span><em>taxa</em>, <em>branch_lengths=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.tree.random_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a random tree from a list of taxa.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>taxa</strong> : list</p>
<blockquote>
<div><p>The list containing the names of the taxa from which the tree will be
created.</p>
</div></blockquote>
<p><strong>branch_lengths</strong> : bool (default=False)</p>
<blockquote>
<div><p>When set to <em>True</em>, a random tree with random branch lengths will be
created with the branch lengths being in order of the maximum number of
the total number of internal branches.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tree_string</strong> : str</p>
<blockquote class="last">
<div><p>A string representation of the random tree in Newick format.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-lingpy.basic.wordlist">
<span id="lingpy-basic-wordlist-module"></span><h2>lingpy.basic.wordlist module<a class="headerlink" href="#module-lingpy.basic.wordlist" title="Permalink to this headline">¶</a></h2>
<p>This module provides a basic class for the handling of word lists.</p>
<dl class="class">
<dt id="lingpy.basic.wordlist.Wordlist">
<em class="property">class </em><code class="descclassname">lingpy.basic.wordlist.</code><code class="descname">Wordlist</code><span class="sig-paren">(</span><em>filename</em>, <em>row='concept'</em>, <em>col='doculect'</em>, <em>conf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.basic.parser.QLCParserWithRowsAndCols" title="lingpy.basic.parser.QLCParserWithRowsAndCols"><code class="xref py py-class docutils literal"><span class="pre">lingpy.basic.parser.QLCParserWithRowsAndCols</span></code></a></p>
<p>Basic class for the handling of multilingual word lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : { string, dict }</p>
<blockquote>
<div><p>The input file that contains the data. Otherwise a dictionary with
consecutive integers as keys and lists as values with the key 0
specifying the header.</p>
</div></blockquote>
<p><strong>row</strong> : str (default = &#8220;concept&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the row that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>col</strong> : str (default = &#8220;doculect&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the column that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>conf</strong> : string (default=&#8217;&#8216;)</p>
<blockquote class="last">
<div><p>A string defining the path to the configuration file (more information
in the notes).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A word list is created from a dictionary containing the data. 
The idea is a three-dimensional representation of (linguistic) data.
The first dimension is called <strong>col</strong> (<em>column</em>, usually &#8220;language&#8221;), the
second one is called <strong>row</strong> (<em>row</em>, usually &#8220;concept&#8221;), the third is
called <strong>entry</strong>, and in contrast to the first two dimensions, which have
to consist of unique items, it contains flexible values, such as &#8220;ipa&#8221;
(phonetic sequence), &#8220;cogid&#8221; (identifier for cognate sets), &#8220;tokens&#8221;
(tokenized representation of phonetic sequences). The LingPy website offers
some tutorials for word lists which we recommend to read in case you are
looking for more information.</p>
<p>A couple of methods is provided along with the word list class in order to
access the multi-dimensional input data. The main idea is to provide an
easy way to access two-dimensional slices of the data by specifying which
entry type should be returned. Thus, if a word list consists not only of
simple orthographical entries but also of IPA encoded phonetic
transcriptions, both the orthographical source and the IPA transcriptions
can be easily accessed as two separate two-dimensional lists.</p>
<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.add_entries">
<code class="descname">add_entries</code><span class="sig-paren">(</span><em>entry</em>, <em>source</em>, <em>function</em>, <em>override=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.add_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new entry-types to the word list by modifying given ones.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>entry</strong> : string</p>
<blockquote>
<div><p>A string specifying the name of the new entry-type to be added to the
word list.</p>
</div></blockquote>
<p><strong>source</strong> : string</p>
<blockquote>
<div><p>A string specifying the basic entry-type that shall be modified. If
multiple entry-types shall be used to create a new entry, they
should be passed in a simple string separated by a comma.</p>
</div></blockquote>
<p><strong>function</strong> : function</p>
<blockquote>
<div><p>A function which is used to convert the source into the target
value.</p>
</div></blockquote>
<p><strong>keywords</strong> : {dict}</p>
<blockquote class="last">
<div><p>A dictionary of keywords that are passed as parameters to the
function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method can be used to add new entry-types to the data by
converting given ones. There are a lot of possibilities for adding new
entries, but the most basic procedure is to use an existing entry-type
and to modify it with help of a function.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>data</em>, <em>taxa='taxa'</em>, <em>concepts='concepts'</em>, <em>ref='cogid'</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculates specific data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : str</p>
<blockquote class="last">
<div><p>The type of data that shall be calculated. Currently supports</p>
<ul class="simple">
<li>&#8220;tree&#8221;: calculate a reference tree based on shared cognates</li>
<li>&#8220;dst&#8221;: get distances between taxa based on shared cognates</li>
<li>&#8220;cluster&#8221;: cluster the taxa into groups using different methods</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.coverage">
<code class="descname">coverage</code><span class="sig-paren">(</span><em>stats='absolute'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Function determines the coverage of a wordlist.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.export">
<code class="descname">export</code><span class="sig-paren">(</span><em>fileformat</em>, <em>sections=None</em>, <em>entries=None</em>, <em>entry_sep=''</em>, <em>item_sep=''</em>, <em>template=''</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the wordlist to specific fileformats.</p>
<p class="rubric">Notes</p>
<p>The difference between export and output is that the latter mostly
serves for internal purposes and formats, while the former serves for
publication of data, using specific, nested statements to create, for
example, HTML or LaTeX files from the wordlist data.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.get_dict">
<code class="descname">get_dict</code><span class="sig-paren">(</span><em>col=''</em>, <em>row=''</em>, <em>entry=''</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.get_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns dictionaries of the cells matched by the indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>col</strong> : string (default=&#8221;&#8221;)</p>
<blockquote>
<div><p>The column index evaluated by the method. It should contain one of the
values in the row of the
<a class="reference internal" href="#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal"><span class="pre">Wordlist</span></code></a> instance, usually a
taxon (language) name.</p>
</div></blockquote>
<p><strong>row</strong> : string (default=&#8221;&#8221;)</p>
<blockquote>
<div><p>The row index evaluated by the method. It should contain one of the
values in the row of the
<a class="reference internal" href="#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal"><span class="pre">Wordlist</span></code></a> instance, usually a
taxon (language) name.</p>
</div></blockquote>
<p><strong>entry</strong> : string (default=&#8221;&#8221;)</p>
<blockquote>
<div><p>The index for the entry evaluated by the method. It can be used to specify
the datatype of the rows or columns selected. As a default, the
indices of the entries are returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>entries</strong> : dict</p>
<blockquote class="last">
<div><p>A dictionary of keys and values specifying the selected part of the
data. Typically, this can be a dictionary of a given language with
keys for the concept and values as specified in the &#8220;entry&#8221;
keyword.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.basic.wordlist.Wordlist.get_list" title="lingpy.basic.wordlist.Wordlist.get_list"><code class="xref py py-obj docutils literal"><span class="pre">Wordlist.get_list</span></code></a>, <a class="reference internal" href="#lingpy.basic.wordlist.Wordlist.add_entries" title="lingpy.basic.wordlist.Wordlist.add_entries"><code class="xref py py-obj docutils literal"><span class="pre">Wordlist.add_entries</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The &#8220;col&#8221; and &#8220;row&#8221; keywords in the function are all aliased according
to the description in the <code class="docutils literal"><span class="pre">wordlist.rc</span></code> file. Thus, instead of
using these attributes, the aliases can also be taken. For selecting a
language, one may type something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Wordlist</span><span class="o">.</span><span class="n">get_dict</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;LANGUAGE&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and for the selection of a concept, one may type something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Wordlist</span><span class="o">.</span><span class="n">get_dict</span><span class="p">(</span><span class="n">concept</span><span class="o">=</span><span class="s1">&#39;CONCEPT&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>See the examples below for details.</p>
<p class="rubric">Examples</p>
<p>Load the <code class="docutils literal"><span class="pre">harry_potter.csv</span></code> file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span> <span class="o">=</span> <span class="n">Wordlist</span><span class="p">(</span><span class="s1">&#39;harry_potter.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Select all IPA-entries for the language &#8220;German&#8221;:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="o">.</span><span class="n">get_dict</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;German&#39;</span><span class="p">,</span><span class="n">entry</span><span class="o">=</span><span class="s1">&#39;ipa&#39;</span><span class="p">)</span>
<span class="go">{&#39;Harry&#39;: [&#39;haralt&#39;], &#39;hand&#39;: [&#39;hant&#39;], &#39;leg&#39;: [&#39;bain&#39;]}</span>
</pre></div>
</div>
<p>Select all words (orthographical representation) for the concept
&#8220;Harry&#8221;:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="o">.</span><span class="n">get_dict</span><span class="p">(</span><span class="n">concept</span><span class="o">=</span><span class="s2">&quot;Harry&quot;</span><span class="p">,</span><span class="n">entry</span><span class="o">=</span><span class="s2">&quot;words&quot;</span><span class="p">)</span>
<span class="go">{&#39;English&#39;: [&#39;hæri&#39;], &#39;German&#39;: [&#39;haralt&#39;], &#39;Russian&#39;: [&#39;gari&#39;],             &#39;Ukrainian&#39;: [&#39;gari&#39;]}</span>
</pre></div>
</div>
<p>Note that the values of the dictionary that is returned are always
lists, since it is possible that the original file contains synonyms
(multiple words corresponding to the same concept).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.get_etymdict">
<code class="descname">get_etymdict</code><span class="sig-paren">(</span><em>ref='cogid'</em>, <em>entry=''</em>, <em>modify_ref=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.get_etymdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an etymological dictionary representation of the word list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref</strong> : string (default = &#8220;cogid&#8221;)</p>
<blockquote>
<div><p>The reference entry which is used to store the cognate ids.</p>
</div></blockquote>
<p><strong>entry</strong> : string (default = &#8216;&#8217;)</p>
<blockquote>
<div><p>The entry-type which shall be selected.</p>
</div></blockquote>
<p><strong>modify_ref</strong> : function (default=False)</p>
<blockquote>
<div><p>Use a function to modify the reference. If your cognate identifiers
are numerical, for example, and negative values are assigned as
loans, but you want to suppress this behaviour, just set this
keyword to &#8220;abs&#8221;, and all cognate IDs will be converted to their
absolute value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>etym_dict</strong> : dict</p>
<blockquote class="last">
<div><p>An etymological dictionary representation of the data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In contrast to the word-list representation of the data, an
etymological dictionary representation sorts the counterparts according to
the cognate sets of which they are reflexes. If more than one cognate
ID are assigned to an entry, for example in cases of fuzzy cognate IDs
or partial cognate IDs, the etymological dictionary will return one
cognate set for each of the IDs.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.get_list">
<code class="descname">get_list</code><span class="sig-paren">(</span><em>row=''</em>, <em>col=''</em>, <em>entry=''</em>, <em>flat=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.get_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns lists of rows and columns specified by their name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>row: string (default = &#8216;&#8217;)</strong> :</p>
<blockquote>
<div><p>The row name whose entries are selected from the data.</p>
</div></blockquote>
<p><strong>col</strong> : string (default = &#8216;&#8217;)</p>
<blockquote>
<div><p>The column name whose entries are selected from the data.</p>
</div></blockquote>
<p><strong>entry: string (default = &#8216;&#8217;)</strong> :</p>
<blockquote>
<div><p>The entry-type which is selected from the data.</p>
</div></blockquote>
<p><strong>flat</strong> : bool (default = False)</p>
<blockquote>
<div><p>Specify whether the returned list should be one- or
two-dimensional, or whether it should contain gaps or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> : list</p>
<blockquote class="last">
<div><p>A list representing the selected part of the
data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.basic.wordlist.Wordlist.get_list" title="lingpy.basic.wordlist.Wordlist.get_list"><code class="xref py py-obj docutils literal"><span class="pre">Wordlist.get_list</span></code></a>, <a class="reference internal" href="#lingpy.basic.wordlist.Wordlist.add_entries" title="lingpy.basic.wordlist.Wordlist.add_entries"><code class="xref py py-obj docutils literal"><span class="pre">Wordlist.add_entries</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The &#8216;col&#8217; and &#8216;row&#8217; keywords in the function are all aliased according
to the description in the <code class="docutils literal"><span class="pre">wordlist.rc</span></code> file. Thus, instead of
using these attributes, the aliases can also be taken. For selecting a
language, one may type something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Wordlist</span><span class="o">.</span><span class="n">get_list</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;LANGUAGE&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and for the selection of a concept, one may type something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Wordlist</span><span class="o">.</span><span class="n">get_list</span><span class="p">(</span><span class="n">concept</span><span class="o">=</span><span class="s1">&#39;CONCEPT&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>See the examples below for details.</p>
<p class="rubric">Examples</p>
<p>Load the <code class="docutils literal"><span class="pre">harry_potter.csv</span></code> file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span> <span class="o">=</span> <span class="n">Wordlist</span><span class="p">(</span><span class="s1">&#39;harry_potter.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Select all IPA-entries for the language &#8220;German&#8221;:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="o">.</span><span class="n">get_list</span><span class="p">(</span><span class="n">language</span><span class="o">=</span><span class="s1">&#39;German&#39;</span><span class="p">,</span><span class="n">entry</span><span class="o">=</span><span class="s1">&#39;ipa&#39;</span>
<span class="go">[&#39;bain&#39;, &#39;hant&#39;, &#39;haralt&#39;]</span>
</pre></div>
</div>
<p>Note that this function returns 0 for missing values (concepts that
don&#8217;t have a word in the given language). If one wants to avoid this,
the &#8216;flat&#8217; keyword should be set to <em>True</em>.</p>
<p>Select all words (orthographical representation) for the concept
&#8220;Harry&#8221;:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="o">.</span><span class="n">get_list</span><span class="p">(</span><span class="n">concept</span><span class="o">=</span><span class="s2">&quot;Harry&quot;</span><span class="p">,</span><span class="n">entry</span><span class="o">=</span><span class="s2">&quot;words&quot;</span><span class="p">)</span>
<span class="go">[[&#39;Harry&#39;, &#39;Harald&#39;, &#39;Гари&#39;, &#39;Гарi&#39;]]</span>
</pre></div>
</div>
<p>Note that the values of the list that is returned are always
two-dimensional
lists, since it is possible that the original file contains synonyms
(multiple words corresponding to the same concept). If one wants to
have a flat representation of the entries, the &#8216;flat&#8217; keyword should be
set to <em>True</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl</span><span class="o">.</span><span class="n">get_list</span><span class="p">(</span><span class="n">concept</span><span class="o">=</span><span class="s2">&quot;Harry&quot;</span><span class="p">,</span><span class="n">entry</span><span class="o">=</span><span class="s2">&quot;words&quot;</span><span class="p">,</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;hæri&#39;, &#39;haralt&#39;, &#39;gari&#39;, &#39;hari&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.get_paps">
<code class="descname">get_paps</code><span class="sig-paren">(</span><em>ref='cogid'</em>, <em>entry='concept'</em>, <em>missing=0</em>, <em>modify_ref=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.get_paps" title="Permalink to this definition">¶</a></dt>
<dd><p>Function returns a list of present-absent-patterns of a given word list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref</strong> : string (default = &#8220;cogid&#8221;)</p>
<blockquote>
<div><p>The reference entry which is used to store the cognate ids.</p>
</div></blockquote>
<p><strong>entry</strong> : string (default = &#8220;concept&#8221;)</p>
<blockquote>
<div><p>The field which is used to check for missing data.</p>
</div></blockquote>
<p><strong>missing</strong> : string,int (default = 0)</p>
<blockquote class="last">
<div><p>The marker for missing items.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.output">
<code class="descname">output</code><span class="sig-paren">(</span><em>fileformat</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write wordlist to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileformat</strong> : {&#8220;tsv&#8221;,&#8221;tre&#8221;,&#8221;nwk&#8221;,&#8221;dst&#8221;, &#8220;taxa&#8221;, &#8220;starling&#8221;, &#8220;paps.nex&#8221;, &#8220;paps.csv&#8221;}</p>
<blockquote>
<div><p>The format that is written to file. This corresponds to the file
extension, thus &#8216;tsv&#8217; creates a file in extended tsv-format, &#8216;dst&#8217; creates
a file in Phylip-distance format, etc.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Specify the name of the output file (defaults to a filename that
indicates the creation date).</p>
</div></blockquote>
<p><strong>subset</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return only a subset of the data. Which subset
is specified in the keywords &#8216;cols&#8217; and &#8216;rows&#8217;.</p>
</div></blockquote>
<p><strong>cols</strong> : list</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, specify the columns that shall be
written to the csv-file.</p>
</div></blockquote>
<p><strong>rows</strong> : dict</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, use a dictionary consisting of keys
that specify a column and values that give a Python-statement in
raw text, such as, e.g., &#8220;== &#8216;hand&#8217;&#8221;. The content of the specified
column will then be checked against statement passed in the
dictionary, and if it is evaluated to c{True}, the respective row
will be written to file.</p>
</div></blockquote>
<p><strong>ref</strong> : str</p>
<blockquote>
<div><p>Name of the column that contains the cognate IDs if &#8216;starling&#8217; is
chosen as an output format.</p>
</div></blockquote>
<p><strong>missing</strong> : { str, int } (default=0)</p>
<blockquote>
<div><p>If &#8216;paps.nex&#8217; or &#8216;paps.csv&#8217; is chosen as fileformat, this character
will be inserted as an indicator of missing data.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : {&#8216;neighbor&#8217;, &#8216;upgma&#8217;}</p>
<blockquote>
<div><p>If no tree has been calculated and &#8216;tre&#8217; or &#8216;nwk&#8217; is chosen as
output format, the method that is used to calculate the tree.</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The threshold that is used to carry out a flat cluster analysis if
&#8216;groups&#8217; or &#8216;cluster&#8217; is chosen as output format.</p>
</div></blockquote>
<p><strong>ignore</strong> : { list, &#8220;all&#8221; }</p>
<blockquote>
<div><p>Modifies the output format in &#8220;tsv&#8221; output and allows to ignore
certain blocks in extended &#8220;tsv&#8221;, like &#8220;msa&#8221;, &#8220;taxa&#8221;, &#8220;json&#8221;, etc.,
which should be passed as a list. If you choose &#8220;all&#8221; as a plain
string and not a list, this will ignore all additional blocks and
output only plain &#8220;tsv&#8221;.</p>
</div></blockquote>
<p><strong>prettify</strong> : bool (default=True)</p>
<blockquote class="last">
<div><p>Inserts comment characters between concepts in the &#8220;tsv&#8221; file
output format, which makes it easier to see blocks of words
denoting the same concept. Switching this off will output the file
in plain &#8220;tsv&#8221;.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.basic.wordlist.Wordlist.renumber">
<code class="descname">renumber</code><span class="sig-paren">(</span><em>source</em>, <em>target=''</em>, <em>override=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.Wordlist.renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber a given set of string identifiers by replacing the ids by integers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>source</strong> : str</p>
<blockquote>
<div><p>The source column to be manipulated.</p>
</div></blockquote>
<p><strong>target</strong> : str (default=&#8217;&#8216;)</p>
<blockquote>
<div><p>The name of the target colummn. If no name is chosen, the target
column will be manipulated by adding &#8220;id&#8221; to the name of the source
column.</p>
</div></blockquote>
<p><strong>override</strong> : bool (default=False)</p>
<blockquote class="last">
<div><p>Force to overwrite the data if the target column already exists.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In addition to a new column, an further entry is added to the &#8220;_meta&#8221;
attribute of the wordlist by which newly coined ids can be retrieved
from the former string attributes. This attribute is called
&#8220;source2target&#8221; and can be accessed either via the &#8220;_meta&#8221; dictionary
or directly as an attribute of the wordlist.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.basic.wordlist.get_wordlist">
<code class="descclassname">lingpy.basic.wordlist.</code><code class="descname">get_wordlist</code><span class="sig-paren">(</span><em>path</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.wordlist.get_wordlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a wordlist from a normal CSV file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>path</strong> : str</p>
<blockquote>
<div><p>The path to your CSV file.</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>The delimiter in the CSV file.</p>
</div></blockquote>
<p><strong>quotechar</strong> : str</p>
<blockquote>
<div><p>The quote character in your data.</p>
</div></blockquote>
<p><strong>row</strong> : str (default = &#8220;concept&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the row that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>col</strong> : str (default = &#8220;doculect&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the column that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>conf</strong> : string (default=&#8217;&#8216;)</p>
<blockquote class="last">
<div><p>A string defining the path to the configuration file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function returns a <a class="reference internal" href="#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal"><span class="pre">Wordlist</span></code></a> object.
In contrast to the normal way to load a wordlist from a tab-separated file,
however, this allows to directly load a wordlist from any &#8220;normal&#8221;
csv-file, with your own specified delimiters and quote characters. If the
first cell in the first row of your CSV file is not named &#8220;ID&#8221;, the integer
identifiers, which are required by LingPy will be automatically created.</p>
</dd></dl>

</div>
<div class="section" id="module-lingpy.basic.workflow">
<span id="lingpy-basic-workflow-module"></span><h2>lingpy.basic.workflow module<a class="headerlink" href="#module-lingpy.basic.workflow" title="Permalink to this headline">¶</a></h2>
<p>Package provides generic workflow modules for LingPy.</p>
<dl class="class">
<dt id="lingpy.basic.workflow.Workflow">
<em class="property">class </em><code class="descclassname">lingpy.basic.workflow.</code><code class="descname">Workflow</code><span class="sig-paren">(</span><em>infile</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.workflow.Workflow" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Class provides access to generic workflows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>infile</strong> : str</p>
<blockquote class="last">
<div><p>A tsv-file providing the input data for the given workflow.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.basic.workflow.Workflow.cognate_detection">
<code class="descname">cognate_detection</code><span class="sig-paren">(</span><em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.basic.workflow.Workflow.cognate_detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Method runs a cognate detection analysis.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-lingpy.basic">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lingpy.basic" title="Permalink to this headline">¶</a></h2>
<p>This module provides basic classes for the handling of linguistic data.</p>
<p>The basic idea is to provide classes that allow the user to handle basic
linguistic datatypes (spreadsheets, wordlists) in a consistent way.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy-logo.svg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">lingpy.basic package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-lingpy.basic.ops">lingpy.basic.ops module</a></li>
<li><a class="reference internal" href="#module-lingpy.basic.parser">lingpy.basic.parser module</a></li>
<li><a class="reference internal" href="#module-lingpy.basic.tree">lingpy.basic.tree module</a></li>
<li><a class="reference internal" href="#module-lingpy.basic.wordlist">lingpy.basic.wordlist module</a></li>
<li><a class="reference internal" href="#module-lingpy.basic.workflow">lingpy.basic.workflow module</a></li>
<li><a class="reference internal" href="#module-lingpy.basic">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/lingpy.basic.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>
 <div id="footer" style="align-items:center;padding-top:5px;padding-left:0px;display:flex;justify-content:space-between;">

   <div>
     <a href="http://ssh.mpg.de"><img width="60px" src="../_static/minerva.png" alt="MPG-SSH" /></a>
   </div>
  <div>
    <a href="http://dfg.de/"><img width="80px" src="../_static/dfg_logo_schwarz.jpg" alt="DFG" /></a>
  </div>

  <div style="max-width:300px;">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated
    on May 17, 2016<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">Creative
      Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a> </p>
  </div>

  <div>
    <a href="http://erc.europa.eu/"><img width="80px" src="http://quanthistling.info/theme/qhl/images/logo_erc.png" alt="ERC" /></a>
  </div>
  <div style="max-width:150px;text-align:right;">
    <a href="http://github.com/lingpy/lingpy/">Application source on</a> 
    <a href="https://github.com/"><img width="100px" src="../_static/GitHub_Logo.png" alt="github logo" /></a>
</div>
</div>

  </body>
</html>