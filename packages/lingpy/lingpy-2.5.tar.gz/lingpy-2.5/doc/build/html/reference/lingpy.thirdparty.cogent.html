<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lingpy.thirdparty.cogent package &mdash; LingPy</title>
    
    <link rel="stylesheet" href="../_static/lingpy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="LingPy" href="../index.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />

  </head>
  <body role="document">
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lingpy-thirdparty-cogent-package">
<h1>lingpy.thirdparty.cogent package<a class="headerlink" href="#lingpy-thirdparty-cogent-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-lingpy.thirdparty.cogent.newick">
<span id="lingpy-thirdparty-cogent-newick-module"></span><h2>lingpy.thirdparty.cogent.newick module<a class="headerlink" href="#module-lingpy.thirdparty.cogent.newick" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Newick format with all features as per the specs at:</dt>
<dd><a class="reference external" href="http://evolution.genetics.washington.edu/phylip/newick_doc.html">http://evolution.genetics.washington.edu/phylip/newick_doc.html</a>
<a class="reference external" href="http://evolution.genetics.washington.edu/phylip/newicktree.html">http://evolution.genetics.washington.edu/phylip/newicktree.html</a></dd>
<dt>ie:</dt>
<dd>Unquoted label underscore munging
Quoted labels
Inner node labels
Lengths
[ ... ] Comments (discarded)
Unlabeled tips</dd>
<dt>also:</dt>
<dd>Double quotes can be used.
Spaces and quote marks are OK inside unquoted labels.</dd>
</dl>
<dl class="exception">
<dt id="lingpy.thirdparty.cogent.newick.TreeParseError">
<em class="property">exception </em><code class="descclassname">lingpy.thirdparty.cogent.newick.</code><code class="descname">TreeParseError</code><a class="headerlink" href="#lingpy.thirdparty.cogent.newick.TreeParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">ValueError</span></code></p>
</dd></dl>

<dl class="function">
<dt id="lingpy.thirdparty.cogent.newick.parse_string">
<code class="descclassname">lingpy.thirdparty.cogent.newick.</code><code class="descname">parse_string</code><span class="sig-paren">(</span><em>text</em>, <em>constructor</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.newick.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a Newick-format string, using specified constructor for tree.</p>
<p>Calls constructor(children, name, attributes)</p>
<p>Note: underscore_unmunge, if True, replaces underscores with spaces in
the data that&#8217;s read in. This is part of the Newick format, but it is
often useful to suppress this behavior.</p>
</dd></dl>

</div>
<div class="section" id="module-lingpy.thirdparty.cogent.tree">
<span id="lingpy-thirdparty-cogent-tree-module"></span><h2>lingpy.thirdparty.cogent.tree module<a class="headerlink" href="#module-lingpy.thirdparty.cogent.tree" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lingpy.thirdparty.cogent.tree.LoadTree">
<code class="descclassname">lingpy.thirdparty.cogent.tree.</code><code class="descname">LoadTree</code><span class="sig-paren">(</span><em>filename=None</em>, <em>treestring=None</em>, <em>tip_names=None</em>, <em>underscore_unmunge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.LoadTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for tree.</p>
<dl class="docutils">
<dt>Arguments, use only one of:</dt>
<dd><ul class="first last simple">
<li>filename: a file containing a newick or xml formatted tree.</li>
<li>treestring: a newick or xml formatted tree string.</li>
<li>tip_names: a list of tip names.</li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Underscore_unmunging is turned off by default, although it is part
of the Newick format. Set underscore_unmunge to True to replace underscores
with spaces in all names read.</p>
</dd></dl>

<dl class="class">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode">
<em class="property">class </em><code class="descclassname">lingpy.thirdparty.cogent.tree.</code><code class="descname">PhyloNode</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.thirdparty.cogent.tree.TreeNode" title="lingpy.thirdparty.cogent.tree.TreeNode"><code class="xref py py-class docutils literal"><span class="pre">lingpy.thirdparty.cogent.tree.TreeNode</span></code></a></p>
<dl class="attribute">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.Length">
<code class="descname">Length</code><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.Length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.balanced">
<code class="descname">balanced</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.balanced" title="Permalink to this definition">¶</a></dt>
<dd><p>Tree &#8216;rooted&#8217; here with no neighbour having &gt; 50% of the edges.</p>
<p class="rubric">Notes</p>
<p>Using a balanced tree can substantially improve performance of
the likelihood calculations. Note that the resulting tree has a
different orientation with the effect that specifying clades or
stems for model parameterisation should be done using the
&#8216;outgroup_name&#8217; argument.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.bifurcating">
<code class="descname">bifurcating</code><span class="sig-paren">(</span><em>constructor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.bifurcating" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.compareByPartitions">
<code class="descname">compareByPartitions</code><span class="sig-paren">(</span><em>other</em>, <em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.compareByPartitions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns branch length between self and other.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.getDistances">
<code class="descname">getDistances</code><span class="sig-paren">(</span><em>endpoints=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.getDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix as a dictionary.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd>Grabs the branch lengths (evolutionary distances) as
a complete matrix (i.e. a,b and b,a).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.getNewick">
<code class="descname">getNewick</code><span class="sig-paren">(</span><em>with_distances=False</em>, <em>semicolon=True</em>, <em>escape_name=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.getNewick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.prune">
<code class="descname">prune</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs correct tree after nodes have been removed.</p>
<p>Internal nodes with only one child will be removed and new connections
and Branch lengths will be made to reflect change.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.rootAtMidpoint">
<code class="descname">rootAtMidpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.rootAtMidpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>return a new tree rooted at midpoint of the two tips farthest apart</p>
<p>this fn doesn&#8217;t preserve the internal node naming or structure,
but does keep tip to tip distances correct.  uses unrootedDeepcopy()</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.rootedAt">
<code class="descname">rootedAt</code><span class="sig-paren">(</span><em>edge_name</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.rootedAt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new tree rooted at the provided node.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd>This can be useful for drawing unrooted trees with an orientation
that reflects knowledge of the true root location.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.rootedWithTip">
<code class="descname">rootedWithTip</code><span class="sig-paren">(</span><em>outgroup_name</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.rootedWithTip" title="Permalink to this definition">¶</a></dt>
<dd><p>A new tree with the named tip as one of the root&#8217;s children</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.sameTopology">
<code class="descname">sameTopology</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.sameTopology" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether two trees have the same topology.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.scaleBranchLengths">
<code class="descname">scaleBranchLengths</code><span class="sig-paren">(</span><em>max_length=100</em>, <em>ultrametric=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.scaleBranchLengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales BranchLengths in place to integers for ascii output.</p>
<p>Warning: tree might not be exactly the length you specify.</p>
<p>Set ultrametric=True if you want all the root-tip distances to end
up precisely the same.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.setTipDistances">
<code class="descname">setTipDistances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.setTipDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets distance from each node to the most distant tip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.tipToTipDistances">
<code class="descname">tipToTipDistances</code><span class="sig-paren">(</span><em>endpoints=None</em>, <em>default_length=1</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.tipToTipDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns distance matrix between all pairs of tips, and a tip order.</p>
<p>Warning: .__start and .__stop added to self and its descendants.</p>
<p>tip_order contains the actual node objects, not their names (may be
confusing in some cases).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.totalDescendingBranchLength">
<code class="descname">totalDescendingBranchLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.totalDescendingBranchLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns total descending branch length from self</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.unrooted">
<code class="descname">unrooted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.unrooted" title="Permalink to this definition">¶</a></dt>
<dd><p>A tree with at least 3 children at the root.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.PhyloNode.unrootedDeepcopy">
<code class="descname">unrootedDeepcopy</code><span class="sig-paren">(</span><em>constructor=None</em>, <em>parent=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.PhyloNode.unrootedDeepcopy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.thirdparty.cogent.tree.TreeBuilder">
<em class="property">class </em><code class="descclassname">lingpy.thirdparty.cogent.tree.</code><code class="descname">TreeBuilder</code><span class="sig-paren">(</span><em>mutable=False</em>, <em>constructor=&lt;class 'lingpy.thirdparty.cogent.tree.PhyloNode'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeBuilder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeBuilder.createEdge">
<code class="descname">createEdge</code><span class="sig-paren">(</span><em>children</em>, <em>name</em>, <em>params</em>, <em>nameLoaded=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeBuilder.createEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for newick parser</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeBuilder.edgeFromEdge">
<code class="descname">edgeFromEdge</code><span class="sig-paren">(</span><em>edge</em>, <em>children</em>, <em>params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeBuilder.edgeFromEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for tree-to-tree transforms like getSubTree</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="lingpy.thirdparty.cogent.tree.TreeError">
<em class="property">exception </em><code class="descclassname">lingpy.thirdparty.cogent.tree.</code><code class="descname">TreeError</code><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="class">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode">
<em class="property">class </em><code class="descclassname">lingpy.thirdparty.cogent.tree.</code><code class="descname">TreeNode</code><span class="sig-paren">(</span><em>Name=None</em>, <em>Children=None</em>, <em>Parent=None</em>, <em>Params=None</em>, <em>NameLoaded=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Store information about a tree node. Mutable.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd>Name: label for the node, assumed to be unique.
Children: list of the node&#8217;s children.
Params: dict containing arbitrary parameters for the node.
NameLoaded: ?</dd>
</dl>
<dl class="attribute">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.Parent">
<code class="descname">Parent</code><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.Parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor for parent.</p>
<p>If using an algorithm that accesses Parent a lot, it will be much
faster to access self._parent directly, but don&#8217;t do it if mutating
self._parent! (or, if you must, remember to clean up the refs).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.ancestors">
<code class="descname">ancestors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.ancestors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all ancestors back to the root. Dynamically calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends i to self.Children, in-place, cleaning up refs.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.asciiArt">
<code class="descname">asciiArt</code><span class="sig-paren">(</span><em>show_internal=True</em>, <em>compact=False</em>, <em>labels=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.asciiArt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string containing an ascii drawing of the tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>show_internal: bool</strong> :</p>
<blockquote>
<div><p>includes internal edge names.</p>
</div></blockquote>
<p><strong>compact: bool</strong> :</p>
<blockquote>
<div><p>use exactly one line per tip.</p>
</div></blockquote>
<p><strong>labels: {bool, list}</strong> :</p>
<blockquote class="last">
<div><p>specify specific labels for all nodes in the tree.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The labels-keyword was added to the function by JML.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.childGroups">
<code class="descname">childGroups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.childGroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list containing lists of children sharing a state.</p>
<p>In other words, returns runs of tip and nontip children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.compareByNames">
<code class="descname">compareByNames</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.compareByNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality test for trees by name</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.compareBySubsets">
<code class="descname">compareBySubsets</code><span class="sig-paren">(</span><em>other</em>, <em>exclude_absent_taxa=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.compareBySubsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns fraction of overlapping subsets where self and other differ.</p>
<p>Other is expected to be a tree object compatible with PhyloNode.</p>
<p class="rubric">Notes</p>
<p>Names present in only one of the two trees will count as 
mismatches: if you don&#8217;t want this behavior, strip out the non-matching
tips first.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.compareName">
<code class="descname">compareName</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.compareName" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares TreeNode by name</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>memo=None</em>, <em>_nil=[]</em>, <em>constructor='ignored'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of self using an iterative approach</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.copyRecursive">
<code class="descname">copyRecursive</code><span class="sig-paren">(</span><em>memo=None</em>, <em>_nil=[]</em>, <em>constructor='ignored'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.copyRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns copy of self&#8217;s structure, including shallow copy of attrs.</p>
<p>constructor is ignored; required to support old tree unit tests.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.copyTopology">
<code class="descname">copyTopology</code><span class="sig-paren">(</span><em>constructor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.copyTopology" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies only the topology and labels of a tree, not any extra data.</p>
<p>Useful when you want another copy of the tree with the same structure
and labels, but want to e.g. assign different branch lengths and
environments. Does not use deepcopy from the copy module, so _much_
faster than the copy() method.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><em>memo=None</em>, <em>_nil=[]</em>, <em>constructor='ignored'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of self using an iterative approach</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.descendantArray">
<code class="descname">descendantArray</code><span class="sig-paren">(</span><em>tip_list=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.descendantArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns numpy array with nodes in rows and descendants in columns.</p>
<p>A value of 1 indicates that the decendant is a descendant of that node/
A value of 0 indicates that it is not</p>
<p>Also returns a list of nodes in the same order as they are listed
in the array.</p>
<p>tip_list is a list of the names of the tips that will be considered,
in the order they will appear as columns in the final array. Internal
nodes will appear as rows in preorder traversal order.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends self.Children by items, in-place, cleaning up refs.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getConnectingEdges">
<code class="descname">getConnectingEdges</code><span class="sig-paren">(</span><em>name1</em>, <em>name2</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getConnectingEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of edges connecting two nodes</p>
<p>includes self and other in the list</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getConnectingNode">
<code class="descname">getConnectingNode</code><span class="sig-paren">(</span><em>name1</em>, <em>name2</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getConnectingNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the last common ancestor of the two named edges.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getDistances">
<code class="descname">getDistances</code><span class="sig-paren">(</span><em>endpoints=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>The distance matrix as a dictionary.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd>Grabs the branch lengths (evolutionary distances) as
a complete matrix (i.e. a,b and b,a).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getEdgeNames">
<code class="descname">getEdgeNames</code><span class="sig-paren">(</span><em>tip1name</em>, <em>tip2name</em>, <em>getclade</em>, <em>getstem</em>, <em>outgroup_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getEdgeNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of stem and/or sub tree (clade) edge name(s).
This is done by finding the common intersection, and then getting
the list of names. If the clade traverses the root, then use the
outgroup_name argument to ensure valid specification.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last simple">
<li>tip1/2name: edge 1/2 names</li>
<li>getstem: whether the name of the clade stem edge is returned.</li>
<li>getclade: whether the names of the edges within the clade are
returned</li>
<li>outgroup_name: if provided the calculation is done on a version of
the tree re-rooted relative to the provided tip.</li>
</ul>
</dd>
<dt>Usage:</dt>
<dd>The returned list can be used to specify subtrees for special
parameterisation. For instance, say you want to allow the primates
to have a different value of a particular parameter. In this case,
provide the results of this method to the parameter controller
method <cite>setParamRule()</cite> along with the parameter name etc..</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getEdgeVector">
<code class="descname">getEdgeVector</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getEdgeVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect the list of edges in postfix order</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getMaxTipTipDistance">
<code class="descname">getMaxTipTipDistance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getMaxTipTipDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the max tip tip distance between any pair of tips</p>
<p>Returns (dist, tip_names, internal_node)</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNewick">
<code class="descname">getNewick</code><span class="sig-paren">(</span><em>with_distances=False</em>, <em>semicolon=True</em>, <em>escape_name=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNewick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the newick string for this tree.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last">
<li><p class="first">with_distances: whether branch lengths are included.</p>
</li>
<li><p class="first">semicolon: end tree string with a semicolon</p>
</li>
<li><dl class="first docutils">
<dt>escape_name: if any of these characters []&#8217;&#8221;(),:;_ exist in a</dt>
<dd><p class="first last">nodes name, wrap the name in single quotes</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>NOTE: This method returns the Newick representation of this node
and its descendents. This method is a modification of an implementation
by Zongzhi Liu</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNewickRecursive">
<code class="descname">getNewickRecursive</code><span class="sig-paren">(</span><em>with_distances=False</em>, <em>semicolon=True</em>, <em>escape_name=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNewickRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the newick string for this edge.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last">
<li><p class="first">with_distances: whether branch lengths are included.</p>
</li>
<li><p class="first">semicolon: end tree string with a semicolon</p>
</li>
<li><dl class="first docutils">
<dt>escape_name: if any of these characters []&#8217;&#8221;(),:;_ exist in a</dt>
<dd><p class="first last">nodes name, wrap the name in single quotes</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNodeMatchingName">
<code class="descname">getNodeMatchingName</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNodeMatchingName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNodeNames">
<code class="descname">getNodeNames</code><span class="sig-paren">(</span><em>includeself=True</em>, <em>tipsonly=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNodeNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of edges from this edge - may or may not include self.
This node (or first connection) will be the first, and then they will
be listed in the natural traverse order.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getNodesDict">
<code class="descname">getNodesDict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getNodesDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dict keyed by node name, value is node</p>
<p>Will raise TreeError if non-unique names are encountered</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getParamValue">
<code class="descname">getParamValue</code><span class="sig-paren">(</span><em>param</em>, <em>edge</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getParamValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the parameter value for named edge</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getSubTree">
<code class="descname">getSubTree</code><span class="sig-paren">(</span><em>name_list</em>, <em>ignore_missing=False</em>, <em>keep_root=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getSubTree" title="Permalink to this definition">¶</a></dt>
<dd><p>A new instance of a sub tree that contains all the otus that are
listed in name_list.</p>
<p>ignore_missing: if False, getSubTree will raise a ValueError if 
name_list contains names that aren&#8217;t nodes in the tree</p>
<p>keep_root: if False, the root of the subtree will be the last common
ancestor of all nodes kept in the subtree. Root to tip distance is
then (possibly) different from the original tree
If True, the root to tip distance remains constant, but root may only
have one child node.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.getTipNames">
<code class="descname">getTipNames</code><span class="sig-paren">(</span><em>includeself=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.getTipNames" title="Permalink to this definition">¶</a></dt>
<dd><p>return the list of the names of all tips contained by this edge</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.get_LCA">
<code class="descname">get_LCA</code><span class="sig-paren">(</span><em>*nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.get_LCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Find lowest common ancestor of a given number of nodes.</p>
<p class="rubric">Notes</p>
<p>This function is supposed to yield the same output as
lowestCommonAncestor does. It was added in order to overcome certain
problems in the original function, resulting from attributes added to a
PhyloNode-object that make the use at time unsecure. Furthermore, it
works with an arbitrary list of nodes (including tips and internal
nodes).</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.indexInParent">
<code class="descname">indexInParent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.indexInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns index of self in parent.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>index</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts an item at specified position in self.Children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.isRoot">
<code class="descname">isRoot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the current is a root, i.e. has no parent.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.isTip">
<code class="descname">isTip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.isTip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the current node is a tip, i.e. has no children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.isroot">
<code class="descname">isroot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.isroot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if root of a tree, i.e. no parent.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.istip">
<code class="descname">istip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.istip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if is tip, i.e. no children.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.iterNontips">
<code class="descname">iterNontips</code><span class="sig-paren">(</span><em>include_self=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.iterNontips" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over nontips descended from self, [] if none.</p>
<p>include_self, if True (default is False), will return the current
node as part of the list of nontips if it is a nontip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.iterTips">
<code class="descname">iterTips</code><span class="sig-paren">(</span><em>include_self=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.iterTips" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over tips descended from self, [] if self is a tip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.lastCommonAncestor">
<code class="descname">lastCommonAncestor</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.lastCommonAncestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds last common ancestor of self and other, or None.</p>
<p>Always tests by identity.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.lca">
<code class="descname">lca</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.lca" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds last common ancestor of self and other, or None.</p>
<p>Always tests by identity.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.levelorder">
<code class="descname">levelorder</code><span class="sig-paren">(</span><em>include_self=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.levelorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs levelorder iteration over tree</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.lowestCommonAncestor">
<code class="descname">lowestCommonAncestor</code><span class="sig-paren">(</span><em>tipnames</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.lowestCommonAncestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowest common ancestor for a list of tipnames</p>
<p>This should be around O(H sqrt(n)), where H is height and n is the
number of tips passed in.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.makeTreeArray">
<code class="descname">makeTreeArray</code><span class="sig-paren">(</span><em>dec_list=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.makeTreeArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes an array with nodes in rows and descendants in columns.</p>
<p>A value of 1 indicates that the decendant is a descendant of that node/
A value of 0 indicates that it is not</p>
<p>also returns a list of nodes in the same order as they are listed
in the array</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.maxTipTipDistance">
<code class="descname">maxTipTipDistance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.maxTipTipDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the max distance between any pair of tips</p>
<p>Also returns the tip names  that it is between as a tuple</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.nameUnnamedNodes">
<code class="descname">nameUnnamedNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.nameUnnamedNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the Data property of unnamed nodes to an arbitrary value</p>
<p>Internal nodes are often unnamed and so this function assigns a
value for referencing.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.nonTipChildren">
<code class="descname">nonTipChildren</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.nonTipChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns direct children in self that have descendants.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.nontips">
<code class="descname">nontips</code><span class="sig-paren">(</span><em>include_self=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.nontips" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns nontips descended from self.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns and deletes child of self at index (default: -1)</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.postorder">
<code class="descname">postorder</code><span class="sig-paren">(</span><em>include_self=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.postorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs postorder iteration over tree.</p>
<p>This is somewhat inelegant compared to saving the node and its index
on the stack, but is 30% faster in the average case and 3x faster in
the worst case (for a comb tree).</p>
<p>Zongzhi Liu&#8217;s slower but more compact version is:</p>
<dl class="docutils">
<dt>def postorder_zongzhi(self):</dt>
<dd><p class="first">stack = [[self, 0]]
while stack:</p>
<blockquote class="last">
<div><p>curr, child_idx = stack[-1]
if child_idx &lt; len(curr.Children):</p>
<blockquote>
<div>stack[-1][1] += 1
stack.append([curr.Children[child_idx], 0])</div></blockquote>
<dl class="docutils">
<dt>else:</dt>
<dd>yield stack.pop()[0]</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.pre_and_postorder">
<code class="descname">pre_and_postorder</code><span class="sig-paren">(</span><em>include_self=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.pre_and_postorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs iteration over tree, visiting node before and after.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.preorder">
<code class="descname">preorder</code><span class="sig-paren">(</span><em>include_self=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.preorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs preorder iteration over tree.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.prune">
<code class="descname">prune</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs correct topology after nodes have been removed.</p>
<p>Internal nodes with only one child will be removed and new connections
will be made to reflect change.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.reassignNames">
<code class="descname">reassignNames</code><span class="sig-paren">(</span><em>mapping</em>, <em>nodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.reassignNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Reassigns node names based on a mapping dict</p>
<p>mapping : dict, old_name -&gt; new_name
nodes : specific nodes for renaming (such as just tips, etc...)</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes node by name instead of identity.</p>
<p>Returns True if node was present, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.removeNode">
<code class="descname">removeNode</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.removeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes node by identity instead of value.</p>
<p>Returns True if node was present, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.root">
<code class="descname">root</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns root of the tree self is in. Dynamically calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.sameShape">
<code class="descname">sameShape</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.sameShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Ignores lengths and order, so trees should be sorted first</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.separation">
<code class="descname">separation</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.separation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of edges separating self and other.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.setMaxTipTipDistance">
<code class="descname">setMaxTipTipDistance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.setMaxTipTipDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate tip distance information up the tree</p>
<p>This method was originally implemented by Julia Goodrich with the intent
of being able to determine max tip to tip distances between nodes on 
large trees efficiently. The code has been modified to track the 
specific tips the distance is between</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.setParamValue">
<code class="descname">setParamValue</code><span class="sig-paren">(</span><em>param</em>, <em>edge</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.setParamValue" title="Permalink to this definition">¶</a></dt>
<dd><p>set&#8217;s the value for param at named edge</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.siblings">
<code class="descname">siblings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.siblings" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all nodes that are children of the same parent as self.</p>
<p class="rubric">Notes</p>
<p>Excludes self from the list. Dynamically calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.sorted">
<code class="descname">sorted</code><span class="sig-paren">(</span><em>sort_order=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>An equivalent tree sorted into a standard order. If this is not
specified then alphabetical order is used.  At each node starting from
root, the algorithm will try to put the descendant which contains the
lowest scoring tip on the left.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.subset">
<code class="descname">subset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns set of names that descend from specified node</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.subsets">
<code class="descname">subsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.subsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all sets of names that come from specified node and its kids</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.tipChildren">
<code class="descname">tipChildren</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.tipChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns direct children of self that are tips.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.tips">
<code class="descname">tips</code><span class="sig-paren">(</span><em>include_self=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.tips" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns tips descended from self, [] if self is a tip.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.traverse">
<code class="descname">traverse</code><span class="sig-paren">(</span><em>self_before=True</em>, <em>self_after=False</em>, <em>include_self=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.traverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns iterator over descendants. Iterative: safe for large trees.</p>
<p class="rubric">Notes</p>
<p>self_before includes each node before its descendants if True.
self_after includes each node after its descendants if True.
include_self includes the initial node if True.</p>
<p>self_before and self_after are independent. If neither is True, only
terminal nodes will be returned.</p>
<p>Note that if self is terminal, it will only be included once even if
self_before and self_after are both True.</p>
<p>This is a depth-first traversal. Since the trees are not binary,
preorder and postorder traversals are possible, but inorder traversals
would depend on the data in the tree and are not handled here.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.traverse_recursive">
<code class="descname">traverse_recursive</code><span class="sig-paren">(</span><em>self_before=True</em>, <em>self_after=False</em>, <em>include_self=True</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.traverse_recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns iterator over descendants. IMPORTANT: read notes below.</p>
<p class="rubric">Notes</p>
<p>traverse_recursive is slower than traverse, and can lead to stack
errors. However, you _must_ use traverse_recursive if you plan to
modify the tree topology as you walk over it (e.g. in post-order),
because the iterative methods use their own stack that is not updated
if you alter the tree.</p>
<p>self_before includes each node before its descendants if True.
self_after includes each node after its descendants if True.
include_self includes the initial node if True.</p>
<p>self_before and self_after are independent. If neither is True, only
terminal nodes will be returned.</p>
<p>Note that if self is terminal, it will only be included once even if
self_before and self_after are both True.</p>
<p>This is a depth-first traversal. Since the trees are not binary,
preorder and postorder traversals are possible, but inorder traversals
would depend on the data in the tree and are not handled here.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.thirdparty.cogent.tree.TreeNode.writeToFile">
<code class="descname">writeToFile</code><span class="sig-paren">(</span><em>filename</em>, <em>with_distances=True</em>, <em>format=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.TreeNode.writeToFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the tree to filename</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><ul class="first last simple">
<li>filename: self-evident</li>
<li>with_distances: whether branch lengths are included in string.</li>
<li>format: default is newick, xml is alternate. Argument overrides
the filename suffix. All attributes are saved in the xml format.</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.thirdparty.cogent.tree.cmp">
<code class="descclassname">lingpy.thirdparty.cogent.tree.</code><code class="descname">cmp</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.cmp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="lingpy.thirdparty.cogent.tree.comb">
<code class="descclassname">lingpy.thirdparty.cogent.tree.</code><code class="descname">comb</code><span class="sig-paren">(</span><em>items</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.thirdparty.cogent.tree.comb" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields each successive combination of n items.</p>
<p>items: a slicable sequence.
n: number of items in each combination
This version from Raymond Hettinger, 2006/03/23</p>
</dd></dl>

</div>
<div class="section" id="module-lingpy.thirdparty.cogent">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lingpy.thirdparty.cogent" title="Permalink to this headline">¶</a></h2>
<p>Simple py3-port of PyCogent&#8217;s (<a class="reference external" href="http://pycogent.sourceforge.net">http://pycogent.sourceforge.net</a>) Tree classes.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy-logo.svg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">lingpy.thirdparty.cogent package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-lingpy.thirdparty.cogent.newick">lingpy.thirdparty.cogent.newick module</a></li>
<li><a class="reference internal" href="#module-lingpy.thirdparty.cogent.tree">lingpy.thirdparty.cogent.tree module</a></li>
<li><a class="reference internal" href="#module-lingpy.thirdparty.cogent">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/lingpy.thirdparty.cogent.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>
 <div id="footer" style="align-items:center;padding-top:5px;padding-left:0px;display:flex;justify-content:space-between;">

   <div>
     <a href="http://ssh.mpg.de"><img width="60px" src="../_static/minerva.png" alt="MPG-SSH" /></a>
   </div>
  <div>
    <a href="http://dfg.de/"><img width="80px" src="../_static/dfg_logo_schwarz.jpg" alt="DFG" /></a>
  </div>

  <div style="max-width:300px;">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated
    on May 17, 2016<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">Creative
      Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a> </p>
  </div>

  <div>
    <a href="http://erc.europa.eu/"><img width="80px" src="http://quanthistling.info/theme/qhl/images/logo_erc.png" alt="ERC" /></a>
  </div>
  <div style="max-width:150px;text-align:right;">
    <a href="http://github.com/lingpy/lingpy/">Application source on</a> 
    <a href="https://github.com/"><img width="100px" src="../_static/GitHub_Logo.png" alt="github logo" /></a>
</div>
</div>

  </body>
</html>