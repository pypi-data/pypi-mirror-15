<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lingpy.align package &mdash; LingPy</title>
    
    <link rel="stylesheet" href="../_static/lingpy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="LingPy" href="../index.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />

  </head>
  <body role="document">
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lingpy-align-package">
<h1>lingpy.align package<a class="headerlink" href="#lingpy-align-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-lingpy.align.multiple">
<span id="lingpy-align-multiple-module"></span><h2>lingpy.align.multiple module<a class="headerlink" href="#module-lingpy.align.multiple" title="Permalink to this headline">¶</a></h2>
<p>Module provides classes and functions for multiple alignment analyses.</p>
<dl class="class">
<dt id="lingpy.align.multiple.Multiple">
<em class="property">class </em><code class="descclassname">lingpy.align.multiple.</code><code class="descname">Multiple</code><span class="sig-paren">(</span><em>seqs</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Basic class for multiple sequence alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqs</strong> : list</p>
<blockquote class="last">
<div><p>List of sequences that shall be aligned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Depending on the structure of the sequences, further keywords can be
specified that manage how the items get tokenized.</p>
<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_local_peaks">
<code class="descname">get_local_peaks</code><span class="sig-paren">(</span><em>threshold=2</em>, <em>gap_weight=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_local_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all peaks in a given alignment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : { int, float } (default=2)</p>
<blockquote>
<div><p>The threshold to determine whether a given column is a peak or not.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0.0)</p>
<blockquote class="last">
<div><p>The weight for gaps.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_pairwise_alignments">
<code class="descname">get_pairwise_alignments</code><span class="sig-paren">(</span><em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_pairwise_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Function creates a dictionary of all pairwise alignments  scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_calc</strong> : bool (default=True)</p>
<blockquote>
<div><p>Specify, whether the analysis should be repeated from the
beginning, or whether already conducted analyses should be carried
out.</p>
</div></blockquote>
<p><strong>model</strong> : string (default=&#8221;sca&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : string (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-3)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_peaks">
<code class="descname">get_peaks</code><span class="sig-paren">(</span><em>gap_weight=0</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the profile score for each column of the alignment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>peaks</strong> : list</p>
<blockquote class="last">
<div><p>A list containing the profile scores for each column of the given
alignment.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.get_pid">
<code class="descname">get_pid</code><span class="sig-paren">(</span><em>mode=1</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.get_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Percentage Identity (PID) score of the calculated MSA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mode</strong> : { 1, 2, 3, 4, 5 } (default=1)</p>
<blockquote>
<div><p>Indicate which of the four possible PID scores described in
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Raghava2006"><span class="pre">Raghava2006</span></a></code> should be calculated, the fifth possibility is added
for linguistic purposes:</p>
<ol class="arabic simple">
<li>identical positions / (aligned positions + internal gap positions),</li>
<li>identical positions / aligned positions,</li>
<li>identical positions / shortest sequence, or</li>
<li>identical positions / shortest sequence (including internal gap
pos.)</li>
<li>identical positions / (aligned positions + 2 * number of gaps)</li>
</ol>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>The PID score of the given alignment as a floating point number between
0 and 1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="lingpy.sequence.html#lingpy.sequence.sound_classes.pid" title="lingpy.sequence.sound_classes.pid"><code class="xref py py-obj docutils literal"><span class="pre">lingpy.sequence.sound_classes.pid</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_all_sequences">
<code class="descname">iterate_all_sequences</code><span class="sig-paren">(</span><em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1</em>, <em>restricted_chars='T_'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on a complete realignment of all sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>check</strong> : { &#8220;final&#8221;, &#8220;immediate&#8221; } (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
<li>&#8220;overlap&#8221; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_clusters</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_similar_gap_sites</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="lingpy.align.multiple.Multiple.iterate_orphans"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_orphans</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method essentially follows the iterative method of
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Barton1987"><span class="pre">Barton1987</span></a></code> with the exception that an MSA has already been
calculated.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_clusters">
<code class="descname">iterate_clusters</code><span class="sig-paren">(</span><em>threshold</em>, <em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1</em>, <em>restricted_chars='T_'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on a flat cluster analysis of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : float</p>
<blockquote>
<div><p>The threshold for the flat cluster analysis.</p>
</div></blockquote>
<p><strong>check</strong> : string (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8216;global&#8217; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8216;dialign&#8217; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
<li>&#8216;overlap&#8217; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_similar_gap_sites</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_all_sequences</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This method uses the <a class="reference internal" href="lingpy.algorithm.html#lingpy.algorithm.clustering.flat_upgma" title="lingpy.algorithm.clustering.flat_upgma"><code class="xref py py-func docutils literal"><span class="pre">lingpy.algorithm.clustering.flat_upgma()</span></code></a>
function in order to retrieve a flat cluster of the data.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_orphans">
<code class="descname">iterate_orphans</code><span class="sig-paren">(</span><em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1.0</em>, <em>restricted_chars='T_'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the most divergent sequences in the sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>check</strong> : string (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
<li>&#8220;overlap&#8221; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1981"><span class="pre">Gotoh1981</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_clusters</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="lingpy.align.multiple.Multiple.iterate_similar_gap_sites"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_similar_gap_sites</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_all_sequences</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The most divergent sequences are those whose average distance to all
other sequences is above the average distance of all sequence pairs.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.iterate_similar_gap_sites">
<code class="descname">iterate_similar_gap_sites</code><span class="sig-paren">(</span><em>check='final'</em>, <em>mode='global'</em>, <em>gop=-3</em>, <em>scale=0.5</em>, <em>factor=0</em>, <em>gap_weight=1</em>, <em>restricted_chars='T_'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.iterate_similar_gap_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterative refinement based on the <em>Similar Gap Sites</em> heuristic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>check</strong> : { &#8220;final&#8221;, &#8220;immediate&#8221; } (default=&#8221;final&#8221;)</p>
<blockquote>
<div><p>Specify when to check for improved sum-of-pairs scores: After each
iteration (&#8220;immediate&#8221;) or after all iterations have been carried
out (&#8220;final&#8221;).</p>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;overlap&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8216;global&#8217; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8216;dialign&#8217; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
<li>&#8216;overlap&#8217; &#8211; semi-global alignment, where gaps introduced in the
beginning and the end of a sequence do not score.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=1)</p>
<blockquote class="last">
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When, e.g., set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_clusters" title="lingpy.align.multiple.Multiple.iterate_clusters"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_clusters</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_all_sequences" title="lingpy.align.multiple.Multiple.iterate_all_sequences"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_all_sequences</span></code></a>, <a class="reference internal" href="#lingpy.align.multiple.Multiple.iterate_orphans" title="lingpy.align.multiple.Multiple.iterate_orphans"><code class="xref py py-obj docutils literal"><span class="pre">Multiple.iterate_orphans</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This heuristic is fairly simple. The idea is to try to split a given
MSA into partitions with identical gap sites.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.lib_align">
<code class="descname">lib_align</code><span class="sig-paren">(</span><em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.lib_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a library-based progressive alignment analysis of the sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : { &#8220;dolgo&#8221;, &#8220;sca&#8221;, &#8220;asjp&#8221; } (default=&#8221;sca&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>modes</strong> : list (default=[(&#8220;global&#8221;,-10,0.6),(&#8220;local&#8221;,-1,0.6)])</p>
<blockquote>
<div><p>Indicate the mode, the gap opening penalties (GOP), and the gap extension
scale (GEP scale), of the pairwise alignment analyses which
are used to create the library.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>gep_scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8220;neighbor&#8221;, &#8220;upgma&#8221; } (default=&#8221;upgma&#8221;)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <code class="docutils literal"><span class="pre">neighbor</span></code>, the Neighbor-Joining
algorithm (<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></code>), and <code class="docutils literal"><span class="pre">upgma</span></code>, the UPGMA
algorithm (<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>).</p>
</div></blockquote>
<p><strong>guide_tree</strong> : tree_matrix</p>
<blockquote>
<div><p>Use a custom guide tree instead of performing a cluster algorithm
for constructing one based on the input similarities. The use of this
option makes the tree_calc option irrelevant.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In contrast to traditional progressive multiple sequence alignment
approaches such as <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Feng1981"><span class="pre">Feng1981</span></a></code> and <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Thompson1994"><span class="pre">Thompson1994</span></a></code>,
library-based progressive alignment <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Notredame2000"><span class="pre">Notredame2000</span></a></code> is based on
a pre-processing of the data where the information given in global and
local pairwise alignments of the input sequences is used to derive a
refined scoring function (<em>library</em>) which is later used in the
progressive phase.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.prog_align">
<code class="descname">prog_align</code><span class="sig-paren">(</span><em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.prog_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a progressive alignment analysis of the input sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : { &#8220;dolgo&#8221;, &#8220;sca&#8221;, &#8220;asjp&#8221; } (defaul=&#8221;sca&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { &#8220;global&#8221;, &#8220;dialign&#8221; } (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>gop</strong> : int (default=-2)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=0.3)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8220;neighbor&#8221;, &#8220;upgma&#8221; } (default=&#8221;upgma&#8221;)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <code class="docutils literal"><span class="pre">neighbor</span></code>, the Neighbor-Joining
algorithm (<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></code>), and <code class="docutils literal"><span class="pre">upgma</span></code>, the UPGMA
algorithm (<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>).</p>
</div></blockquote>
<p><strong>guide_tree</strong> : tree_matrix</p>
<blockquote>
<div><p>Use a custom guide tree instead of performing a cluster algorithm
for constructing one based on the input similarities. The use of this
option makes the tree_calc option irrelevant.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.sum_of_pairs">
<code class="descname">sum_of_pairs</code><span class="sig-paren">(</span><em>alm_matrix='self'</em>, <em>mat=None</em>, <em>gap_weight=0.0</em>, <em>gop=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.sum_of_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the sum-of-pairs score for a given alignment analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alm_matrix</strong> : { &#8220;self&#8221;, &#8220;other&#8221; } (default=&#8221;self&#8221;)</p>
<blockquote>
<div><p>Indicate for which MSA the sum-of-pairs score shall be calculated.</p>
</div></blockquote>
<p><strong>mat</strong> : { None, list }</p>
<blockquote>
<div><p>If &#8220;other&#8221; is chosen as an option for <strong>alm_matrix</strong>, define for
which matrix the sum-of-pairs score shall be calculated.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>The sum-of-pairs score of the alignment.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.multiple.Multiple.swap_check">
<code class="descname">swap_check</code><span class="sig-paren">(</span><em>swap_penalty=-3</em>, <em>score_mode='classes'</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.Multiple.swap_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for possibly swapped sites in the alignment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>swap_penalty</strong> : { int, float } (default=-3)</p>
<blockquote>
<div><p>Specify the penalty for swaps in the alignment.</p>
</div></blockquote>
<p><strong>score_mode</strong> : { &#8220;classes&#8221;, &#8220;library&#8221; } (default=&#8221;classes&#8221;)</p>
<blockquote>
<div><p>Define the score-mode of the calculation which is either based on
sound classes proper, or on the specific scores derived from the
library approach.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : bool</p>
<blockquote class="last">
<div><p>Returns <code class="docutils literal"><span class="pre">True</span></code>, if a swap was identified, and <code class="docutils literal"><span class="pre">False</span></code>
otherwise. The information regarding the position of the swap is
stored in the attribute <code class="docutils literal"><span class="pre">swap_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The method for swap detection is described in detail in <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>.</p>
<p class="rubric">Examples</p>
<p>Define a set of strings whose alignment contans a swap.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span> <span class="o">=</span> <span class="n">Multiple</span><span class="p">([</span><span class="s2">&quot;woldemort&quot;</span><span class="p">,</span> <span class="s2">&quot;waldemar&quot;</span><span class="p">,</span> <span class="s2">&quot;wladimir&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Align the data, using the progressive approach.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">prog_align</span><span class="p">()</span>
</pre></div>
</div>
<p>Check for swaps.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">swap_check</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Print the alignment</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="go">w   o   l   -   d   e   m   o   r   t</span>
<span class="go">w   a   l   -   d   e   m   a   r   -</span>
<span class="go">v   -   l   a   d   i   m   i   r   -</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.align.multiple.mult_align">
<code class="descclassname">lingpy.align.multiple.</code><code class="descname">mult_align</code><span class="sig-paren">(</span><em>seqs</em>, <em>gop=-1</em>, <em>scale=0.5</em>, <em>tree_calc='upgma'</em>, <em>scoredict=False</em>, <em>pprint=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.multiple.mult_align" title="Permalink to this definition">¶</a></dt>
<dd><p>A short-cut method for multiple alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqs</strong> : list</p>
<blockquote>
<div><p>The input sequences.</p>
</div></blockquote>
<p><strong>gop = int (default=-1)</strong> :</p>
<blockquote>
<div><p>The gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The scaling factor by which penalties for gap extensions are decreased.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8220;upgma&#8221; &#8220;neighbor&#8221; } (default=&#8221;upgma&#8221;)</p>
<blockquote>
<div><p>The algorithm which is used for the calculation of the guide tree.</p>
</div></blockquote>
<p><strong>pprint</strong> : bool (default=False)</p>
<blockquote>
<div><p>Indicate whether results shall be printed onto screen.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alignments</strong> : list</p>
<blockquote class="last">
<div><p>A two-dimensional list in which alignments are represented as a list of
tokens.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">mult_align</span><span class="p">([</span><span class="s2">&quot;woldemort&quot;</span><span class="p">,</span> <span class="s2">&quot;waldemar&quot;</span><span class="p">,</span> <span class="s2">&quot;vladimir&quot;</span><span class="p">],</span> <span class="n">pprint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">w   o   l   -   d   e   m   o   r   t</span>
<span class="go">w   a   l   -   d   e   m   a   r   -</span>
<span class="go">-   v   l   a   d   i   m   i   r   -</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-lingpy.align.pairwise">
<span id="lingpy-align-pairwise-module"></span><h2>lingpy.align.pairwise module<a class="headerlink" href="#module-lingpy.align.pairwise" title="Permalink to this headline">¶</a></h2>
<p>Module provides classes and functions for pairwise alignment analyses.</p>
<dl class="class">
<dt id="lingpy.align.pairwise.Pairwise">
<em class="property">class </em><code class="descclassname">lingpy.align.pairwise.</code><code class="descname">Pairwise</code><span class="sig-paren">(</span><em>seqs</em>, <em>seqB=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.Pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Basic class for the handling of pairwise sequence alignments (PSA).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqs</strong> : string list</p>
<blockquote>
<div><p>Either the first string of a sequence pair that shall be aligned,
or a list of sequence tuples.</p>
</div></blockquote>
<p><strong>seqB</strong> : string or bool (default=None)</p>
<blockquote class="last">
<div><p>Define the second sequence that shall be aligned with the first
sequence, if only two sequences shall be compared.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.align.pairwise.Pairwise.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.Pairwise.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a pair of sequences or multiple sequence pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gop</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap opening penalty (GOP).</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The gap extension penalty (GEP), calculated with help of a scaling
factor.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8220;global&#8221;,&#8221;local&#8221;,&#8221;overlap&#8221;,&#8221;dialign&#8221;}</p>
<blockquote>
<div><p>The alignment mode, see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code> for details.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default = 0.3)</p>
<blockquote>
<div><p>The factor by which matches in identical prosodic position are
increased.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : str (default=&#8221;T_&#8221;)</p>
<blockquote>
<div><p>The restricted chars that function as an indicator of syllable or
morpheme breaks for secondary alignment, see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012c"><span class="pre">List2012c</span></a></code>
for details.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to <em>True</em>, return the distance instead of the similarity
score. Distance is calculated using the formula by
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Downey2008"><span class="pre">Downey2008</span></a></code>.</p>
</div></blockquote>
<p><strong>model</strong> : { None, ~lingpy.data.model.Model }</p>
<blockquote>
<div><p>Specify the sound class model that shall be used for the analysis.
If no model is specified, the default model of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code>
will be used.</p>
</div></blockquote>
<p><strong>pprint</strong> : bool (default=False)</p>
<blockquote class="last">
<div><p>If set to <em>True</em>, the alignments are printed to the screen.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.edit_dist">
<code class="descclassname">lingpy.align.pairwise.</code><code class="descname">edit_dist</code><span class="sig-paren">(</span><em>seqA</em>, <em>seqB</em>, <em>normalized=False</em>, <em>restriction=''</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.edit_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edit distance between two strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA,seqB</strong> : str</p>
<blockquote>
<div><p>The strings that shall be compared.</p>
</div></blockquote>
<p><strong>normalized</strong> : bool (default=False)</p>
<blockquote>
<div><p>Specify whether the normalized edit distance shall be returned. If no
restrictions are chosen, the edit distance is normalized by dividing by
the length of the longer string. If <em>restriction</em> is set to <em>cv</em>
(consonant-vowel), the edit distance is normalized by the length of the
alignment.</p>
</div></blockquote>
<p><strong>restriction</strong> : {&#8220;cv&#8221;} (default=&#8221;&#8221;)</p>
<blockquote>
<div><p>Specify the restrictions to be used. Currently, only <code class="docutils literal"><span class="pre">cv</span></code> is
supported. This prohibits matches of vowels with consonants.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist</strong> : {int float}</p>
<blockquote class="last">
<div><p>The edit distance, which is a float if normalized is set to c{True},
and an integer otherwise.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The edit distance was first formally defined by V. I. Levenshtein
(<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Levenshtein1965"><span class="pre">Levenshtein1965</span></a></code>). The first algorithm to compute the edit
distance was proposed by Wagner and Fisher (<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Wagner1974"><span class="pre">Wagner1974</span></a></code>).</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edit_dist</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.nw_align">
<code class="descclassname">lingpy.align.pairwise.</code><code class="descname">nw_align</code><span class="sig-paren">(</span><em>seqA</em>, <em>seqB</em>, <em>scorer=False</em>, <em>gap=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.nw_align" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Carry out the traditional Needleman-Wunsch algorithm.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<dl class="docutils">
<dt>scorer</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict (default=False)</span><dd><p class="first last">If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings (segment matches need to
be passed as tuples of two segments, following the order of the input
sequences). Note also that the scorer can well be asymmetric, so you
could also use it for two completely different alphabets. All you need
to make sure is that the tuples representing the segment matches follow
the order of your input sequences.</p>
</dd>
<dt>gap</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int (default=-1)</span><dd><p class="first last">The gap penalty.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alm</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple consisting of the aligments of the first and the second
sequence, and the alignment score.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Needleman-Wunsch algorithm (see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>) returns a global
alignment of two sequences.</p>
<dl class="docutils">
<dt>&#8216;+&#8217; &#8216;.join(almB), &#8220;(sim={0})&#8221;.format(sim))</dt>
<dd><p class="first">a b a b -
- b a b a (sim=1)</p>
<p>Nothing unexpected so far, you could reach the same result without the
scorer. But now let&#8217;s make a scorer that favors mismatches for our little
two-letter alphabet.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scorer</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;abab&#39;</span><span class="p">,</span> <span class="s1">&#39;baba&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">almA</span><span class="p">,</span> <span class="n">almB</span><span class="p">,</span> <span class="n">sim</span> <span class="o">=</span> <span class="n">nw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">scorer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">almA</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span>
</pre></div>
</div>
</dd>
<dt>&#8216;+&#8217; &#8216;.join(almB), &#8220;(sim={0})&#8221;.format(sim))</dt>
<dd><p class="first">a b a b
b a b a (sim=4)</p>
<p>Now, let&#8217;s analyse two strings which are completely different, but where we
use the scorer to define mappings between the segments. We simply do this
by using lower case letters in one and upper case letters in the other
case, which will, of course, be treated as different symbols in Python:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scorer</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span> <span class="o">=</span> <span class="s1">&#39;ABAB&#39;</span><span class="p">,</span> <span class="s1">&#39;aa&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">almA</span><span class="p">,</span> <span class="n">almB</span><span class="p">,</span> <span class="n">sim</span> <span class="o">=</span> <span class="n">nw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">,</span> <span class="n">scorer</span><span class="o">=</span><span class="n">scorer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">almA</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span>
</pre></div>
</div>
</dd>
<dt>&#8216;+&#8217; &#8216;.join(almB), &#8220;(sim={0})&#8221;.format(sim))</dt>
<dd>A B A B
a - a - (sim=0)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.pw_align">
<code class="descclassname">lingpy.align.pairwise.</code><code class="descname">pw_align</code><span class="sig-paren">(</span><em>seqA</em>, <em>seqB</em>, <em>gop=-1</em>, <em>scale=0.5</em>, <em>scorer=False</em>, <em>mode='global'</em>, <em>distance=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.pw_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align two sequences in various ways.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {text_type, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap opening penalty.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.5)</p>
<blockquote>
<div><p>The gap extension scale. This scale is similar to the gap extension
penalty, but in contrast to the traditional GEP, it &#8220;scales&#8221; the gap
opening penalty.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8220;global&#8221;, &#8220;local&#8221;, &#8220;diagonal&#8221;, &#8220;overlap&#8221;} (default=&#8221;global&#8221;)</p>
<blockquote>
<div><p>Select between one of the four different alignment modes regularly
implemented in LingPy, see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012a"><span class="pre">List2012a</span></a></code> for details.</p>
</div></blockquote>
<p><strong>distance</strong> : bool (default=False)</p>
<blockquote class="last">
<div><p>If set to c{True} return the distance score following the formula by
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Downey2008"><span class="pre">Downey2008</span></a></code>. Otherwise, return the basic similarity score.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<dl class="docutils">
<dt>Align two words using the dialign algorithm::</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;dialign&#39;</span><span class="p">)</span>
<span class="go">([&#39;f&#39;, &#39;a&#39;, &#39;t&#39;, &#39; &#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;],</span>
<span class="go"> [&#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;-&#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;f&#39;, &#39;a&#39;, &#39;t&#39;],</span>
<span class="go"> 3.0)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.structalign">
<code class="descclassname">lingpy.align.pairwise.</code><code class="descname">structalign</code><span class="sig-paren">(</span><em>seqA</em>, <em>seqB</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.structalign" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental function for testing structural alignment algorithms.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.sw_align">
<code class="descclassname">lingpy.align.pairwise.</code><code class="descname">sw_align</code><span class="sig-paren">(</span><em>seqA</em>, <em>seqB</em>, <em>scorer=False</em>, <em>gap=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.sw_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out the traditional Smith-Waterman algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gap</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap penalty.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alm</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple consisting of prefix, alignment, and suffix of the first and
the second sequence, and the alignment score.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Smith-Waterman algorithm (see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Smith1981"><span class="pre">Smith1981</span></a></code>) returns a local
alignment between two sequences. A local alignment is an alignment of those
subsequences of the input sequences that yields the highest score.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sw_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">)</span>
<span class="go">(([], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], [&#39; &#39;, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;]),</span>
<span class="go"> ([&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], []),</span>
<span class="go"> 3.0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.turchin">
<code class="descclassname">lingpy.align.pairwise.</code><code class="descname">turchin</code><span class="sig-paren">(</span><em>seqA</em>, <em>seqB</em>, <em>model='dolgo'</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.turchin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cognate judgment based on the method by <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Turchin2010"><span class="pre">Turchin2010</span></a></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>model</strong> : {&#8220;asjp&#8221;, &#8220;sca&#8221;, &#8220;dolgo&#8221;} (default=&#8221;dolgo&#8221;)</p>
<blockquote>
<div><p>A sound-class model instance or a string that denotes one of the
standard sound class models used in LingPy.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cognacy</strong> : {0, 1}</p>
<blockquote class="last">
<div><p>The cognacy assertion which is either 0 (words are probably cognate) or
1 (words are not likely to be cognate).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.pairwise.we_align">
<code class="descclassname">lingpy.align.pairwise.</code><code class="descname">we_align</code><span class="sig-paren">(</span><em>seqA</em>, <em>seqB</em>, <em>scorer=False</em>, <em>gap=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.pairwise.we_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out the traditional Waterman-Eggert algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seqA, seqB</strong> : {str, list, tuple}</p>
<blockquote>
<div><p>The input strings. These should be iterables, so you can use tuples,
lists, or strings.</p>
</div></blockquote>
<p><strong>scorer</strong> : dict (default=False)</p>
<blockquote>
<div><p>If set to c{False} a scorer will automatically be calculated,
otherwise, the scorer needs to be passed as a dictionary that covers
all segment matches between the input strings.</p>
</div></blockquote>
<p><strong>gap</strong> : int (default=-1)</p>
<blockquote>
<div><p>The gap penalty.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>alms</strong> : list</p>
<blockquote class="last">
<div><p>A list consisting of tuples. Each tuple gives the alignment of one of
the subsequences of the input sequences. Each tuple contains the
aligned part of the first, the aligned part of the second sequence, and
the score of the alignment.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Waterman-Eggert algorithm (see <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Waterman1987"><span class="pre">Waterman1987</span></a></code>) returns <em>all</em>
local matches between two sequences.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seqA</span> <span class="o">=</span> <span class="s1">&#39;fat cat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setB</span> <span class="o">=</span> <span class="s1">&#39;catfat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">we_align</span><span class="p">(</span><span class="n">seqA</span><span class="p">,</span> <span class="n">seqB</span><span class="p">)</span>
<span class="go">[([&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;f&#39;, &#39;a&#39;, &#39;t&#39;], 3.0),</span>
<span class="go"> ([&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], 3.0)]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-lingpy.align.sca">
<span id="lingpy-align-sca-module"></span><h2>lingpy.align.sca module<a class="headerlink" href="#module-lingpy.align.sca" title="Permalink to this headline">¶</a></h2>
<p>Basic module for pairwise and multiple sequence comparison.</p>
<p>The module consists of four classes which deal with pairwise and multiple
sequence comparison from the <em>sequence</em> and the <em>alignment</em> perspective. The
sequence perspective deals with unaligned sequences. The <em>alignment</em>
perspective deals with aligned sequences.</p>
<dl class="class">
<dt id="lingpy.align.sca.Alignments">
<em class="property">class </em><code class="descclassname">lingpy.align.sca.</code><code class="descname">Alignments</code><span class="sig-paren">(</span><em>infile</em>, <em>row='concept'</em>, <em>col='doculect'</em>, <em>conf=''</em>, <em>modify_ref=False</em>, <em>_interactive=True</em>, <em>ref='cogid'</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal"><span class="pre">lingpy.basic.wordlist.Wordlist</span></code></a></p>
<p>Class handles Wordlists for the purpose of alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>infile</strong> : str</p>
<blockquote>
<div><p>The name of the input file that should conform to the basic format of
the <cite>~lingpy.basic.wordlist.Wordlist</cite> class and define a specific ID
for cognate sets.</p>
</div></blockquote>
<p><strong>row</strong> : str (default = &#8220;concept&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the row that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>col</strong> : str (default = &#8220;doculect&#8221;)</p>
<blockquote>
<div><p>A string indicating the name of the column that shall be taken as the
basis for the tabular representation of the word list.</p>
</div></blockquote>
<p><strong>conf</strong> : string (default=&#8217;&#8216;)</p>
<blockquote>
<div><p>A string defining the path to the configuration file.</p>
</div></blockquote>
<p><strong>ref</strong> : string (default=&#8217;cogid&#8217;)</p>
<blockquote>
<div><p>The name of the column that stores the cognate IDs.</p>
</div></blockquote>
<p><strong>modify_ref</strong> : function (default=False)</p>
<blockquote class="last">
<div><p>Use a function to modify the reference. If your cognate identifiers
are numerical, for example, and negative values are assigned as
loans, but you want to suppress this behaviour, just set this
keyword to &#8220;abs&#8221;, and all cognate IDs will be converted to their
absolute value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This class inherits from <a class="reference internal" href="lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal"><span class="pre">Wordlist</span></code></a> and
additionally creates instances of the
<a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><code class="xref py py-class docutils literal"><span class="pre">Multiple</span></code></a> class for all cognate sets that
are specified by the <em>ref</em> keyword.</p>
<p class="rubric">Attributes</p>
<dl class="method">
<dt id="lingpy.align.sca.Alignments.add_alignments">
<code class="descname">add_alignments</code><span class="sig-paren">(</span><em>ref=False</em>, <em>modify_ref=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.add_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Function adds a new set of alignments to the data.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry out a multiple alignment analysis of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : { &#8220;progressive&#8221;, &#8220;library&#8221; } (default=&#8221;progressive&#8221;)</p>
<blockquote>
<div><p>Select the method to use for the analysis.</p>
</div></blockquote>
<p><strong>iteration</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to use iterative refinement methods.</p>
</div></blockquote>
<p><strong>swap_check</strong> : bool (default=False)</p>
<blockquote>
<div><p>Set to c{True} in order to carry out a swap-check.</p>
</div></blockquote>
<p><strong>model</strong> : { &#8216;dolgo&#8217;, &#8216;sca&#8217;, &#8216;asjp&#8217; }</p>
<blockquote>
<div><p>A string indicating the name of the <a class="reference internal" href="lingpy.data.html#module-lingpy.data.model" title="lingpy.data.model"><code class="xref py py-class docutils literal"><span class="pre">Model</span></code></a> object that shall be used for the analysis.
Currently, three models are supported:</p>
<ul class="simple">
<li>&#8220;dolgo&#8221; &#8211; a sound-class model based on <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Dolgopolsky1986"><span class="pre">Dolgopolsky1986</span></a></code>,</li>
<li>&#8220;sca&#8221; &#8211; an extension of the &#8220;dolgo&#8221; sound-class model based on
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>, and</li>
<li>&#8220;asjp&#8221; &#8211; an independent sound-class model which is based on the
sound-class model of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2008"><span class="pre">Brown2008</span></a></code> and the empirical data
of <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Brown2011"><span class="pre">Brown2011</span></a></code> (see the description in
<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012"><span class="pre">List2012</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>mode</strong> : { &#8216;global&#8217;, &#8216;dialign&#8217; }</p>
<blockquote>
<div><p>A string indicating which kind of alignment analysis should be
carried out during the progressive phase. Select between:</p>
<ul class="simple">
<li>&#8220;global&#8221; &#8211; traditional global alignment analysis based on the
Needleman-Wunsch algorithm <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Needleman1970"><span class="pre">Needleman1970</span></a></code>,</li>
<li>&#8220;dialign&#8221; &#8211; global alignment analysis which seeks to maximize
local similarities <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Morgenstern1996"><span class="pre">Morgenstern1996</span></a></code>.</li>
</ul>
</div></blockquote>
<p><strong>modes</strong> : list (default=[(&#8216;global&#8217;,-2,0.5),(&#8216;local&#8217;,-1,0.5)])</p>
<blockquote>
<div><p>Indicate the mode, the gap opening penalties (GOP), and the gap
extension scale (GEP scale), of the pairwise alignment analyses
which are used to create the library.</p>
</div></blockquote>
<p><strong>gop</strong> : int (default=-5)</p>
<blockquote>
<div><p>The gap opening penalty (GOP) used in the analysis.</p>
</div></blockquote>
<p><strong>scale</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The factor by which the penalty for the extension of gaps (gap
extension penalty, GEP) shall be decreased. This approach is
essentially inspired by the exension of the basic alignment
algorithm for affine gap penalties <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Gotoh1982"><span class="pre">Gotoh1982</span></a></code>.</p>
</div></blockquote>
<p><strong>factor</strong> : float (default=1)</p>
<blockquote>
<div><p>The factor by which the initial and the descending position shall
be modified.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : { &#8216;neighbor&#8217;, &#8216;upgma&#8217; } (default=&#8217;upgma&#8217;)</p>
<blockquote>
<div><p>The cluster algorithm which shall be used for the calculation of
the guide tree. Select between <code class="docutils literal"><span class="pre">neighbor</span></code>, the Neighbor-Joining
algorithm (<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Saitou1987"><span class="pre">Saitou1987</span></a></code>), and <code class="docutils literal"><span class="pre">upgma</span></code>, the UPGMA
algorithm (<code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Sokal1958"><span class="pre">Sokal1958</span></a></code>).</p>
</div></blockquote>
<p><strong>gap_weight</strong> : float (default=0)</p>
<blockquote>
<div><p>The factor by which gaps in aligned columns contribute to the
calculation of the column score. When set to 0, gaps will be
ignored in the calculation. When set to 0.5, gaps will count half
as much as other characters.</p>
</div></blockquote>
<p><strong>restricted_chars</strong> : string (default=&#8221;T&#8221;)</p>
<blockquote class="last">
<div><p>Define which characters of the prosodic string of a sequence
reflect its secondary structure (cf. <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=List2012b"><span class="pre">List2012b</span></a></code>) and
should therefore be aligned specifically. This defaults to &#8220;T&#8221;,
since this is the character that represents tones in the prosodic
strings of sequences.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.get_confidence">
<code class="descname">get_confidence</code><span class="sig-paren">(</span><em>scorer</em>, <em>ref='lexstatid'</em>, <em>gap_weight=0.25</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.get_confidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Function creates confidence scores for a given set of alignments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scorer</strong> : <code class="xref py py-class docutils literal"><span class="pre">ScoreDict</span></code></p>
<blockquote>
<div><p>A <em>ScoreDict</em> object which gives similarity scores for all segments in
the alignment.</p>
</div></blockquote>
<p><strong>ref</strong> : str (default=&#8221;lexstatid&#8221;)</p>
<blockquote>
<div><p>The reference entry-type, referring to the cognate-set to be used for
the analysis.</p>
</div></blockquote>
<p><strong>gap_weight</strong> : {loat} (default=1.0)</p>
<blockquote class="last">
<div><p>Determine the weight assigned to matches containing gaps.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.get_consensus">
<code class="descname">get_consensus</code><span class="sig-paren">(</span><em>tree=False</em>, <em>gaps=False</em>, <em>classes=False</em>, <em>consensus='consensus'</em>, <em>counterpart='ipa'</em>, <em>weights=[]</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.get_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a consensus string of all MSAs in the wordlist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>msa</strong> : {c{list} ~lingpy.align.multiple.Multiple}</p>
<blockquote>
<div><p>Either an MSA object or an MSA matrix.</p>
</div></blockquote>
<p><strong>tree</strong> : {c{str} ~lingpy.thirdparty.cogent.PhyloNode}</p>
<blockquote>
<div><p>A tree object or a Newick string along which the consensus shall be
calculated.</p>
</div></blockquote>
<p><strong>gaps</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return the gap positions in the consensus.</p>
</div></blockquote>
<p><strong>classes</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>Specify whether sound classes shall be used to calculate the consensus.</p>
</div></blockquote>
<p><strong>model</strong> : ~lingpy.data.model.Model</p>
<blockquote class="last">
<div><p>A sound class model according to which the IPA strings shall be
converted to sound-class strings.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.output">
<code class="descname">output</code><span class="sig-paren">(</span><em>fileformat</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write wordlist to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileformat</strong> : {&#8220;tsv&#8221;, &#8220;msa&#8221;, &#8220;tre&#8221;, &#8220;nwk&#8221;, &#8220;dst&#8221;, &#8220;taxa&#8221;, &#8220;starling&#8221;, &#8220;paps.nex&#8221;,</p>
<blockquote>
<div><p>&#8220;paps.csv&#8221; &#8220;html&#8221;}
The format that is written to file. This corresponds to the file
extension, thus &#8216;tsv&#8217; creates a file in tsv-format, &#8216;dst&#8217; creates
a file in Phylip-distance format, etc. Specific output is created
for the formats &#8220;html&#8221; and &#8220;msa&#8221;:</p>
<ul class="simple">
<li>&#8220;msa&#8221; will create a folder containing all alignments of all
cognate sets in &#8220;msa&#8221;-format</li>
<li>&#8220;html&#8221; will create html-output in which words are sorted
according to meaning, cognate set, and all cognate words are
aligned</li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Specify the name of the output file (defaults to a filename that
indicates the creation date).</p>
</div></blockquote>
<p><strong>subset</strong> : bool (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return only a subset of the data. Which subset
is specified in the keywords &#8216;cols&#8217; and &#8216;rows&#8217;.</p>
</div></blockquote>
<p><strong>cols</strong> : list</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, specify the columns that shall be
written to the csv-file.</p>
</div></blockquote>
<p><strong>rows</strong> : dict</p>
<blockquote>
<div><p>If <em>subset</em> is set to c{True}, use a dictionary consisting of keys
that specify a column and values that give a Python-statement in
raw text, such as, e.g., &#8220;== &#8216;hand&#8217;&#8221;. The content of the specified
column will then be checked against statement passed in the
dictionary, and if it is evaluated to c{True}, the respective row
will be written to file.</p>
</div></blockquote>
<p><strong>ref</strong> : str</p>
<blockquote>
<div><p>Name of the column that contains the cognate IDs if &#8216;starling&#8217; is
chosen as an output format.</p>
</div></blockquote>
<p><strong>missing</strong> : { str, int } (default=0)</p>
<blockquote>
<div><p>If &#8216;paps.nex&#8217; or &#8216;paps.csv&#8217; is chosen as fileformat, this character
will be inserted as an indicator of missing data.</p>
</div></blockquote>
<p><strong>tree_calc</strong> : {&#8216;neighbor&#8217;, &#8216;upgma&#8217;}</p>
<blockquote>
<div><p>If no tree has been calculated and &#8216;tre&#8217; or &#8216;nwk&#8217; is chosen as
output format, the method that is used to calculate the tree.</p>
</div></blockquote>
<p><strong>threshold</strong> : float (default=0.6)</p>
<blockquote>
<div><p>The threshold that is used to carry out a flat cluster analysis if
&#8216;groups&#8217; or &#8216;cluster&#8217; is chosen as output format.</p>
</div></blockquote>
<p><strong>style</strong> : str (default=&#8221;id&#8221;)</p>
<blockquote>
<div><p>If &#8220;msa&#8221; is chosen as output format, this will write the alignments
for each msa-file in a specific format in which the first column
contains a direct reference to the word via its ID in the wordlist.</p>
</div></blockquote>
<p><strong>ignore</strong> : { list, &#8220;all&#8221; }</p>
<blockquote>
<div><p>Modifies the output format in &#8220;tsv&#8221; output and allows to ignore
certain blocks in extended &#8220;tsv&#8221;, like &#8220;msa&#8221;, &#8220;taxa&#8221;, &#8220;json&#8221;, etc.,
which should be passed as a list. If you choose &#8220;all&#8221; as a plain
string and not a list, this will ignore all additional blocks and
output only plain &#8220;tsv&#8221;.</p>
</div></blockquote>
<p><strong>prettify</strong> : bool (default=True)</p>
<blockquote class="last">
<div><p>Inserts comment characters between concepts in the &#8220;tsv&#8221; file
output format, which makes it easier to see blocks of words
denoting the same concept. Switching this off will output the file
in plain &#8220;tsv&#8221;.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.Alignments.reduce_alignments">
<code class="descname">reduce_alignments</code><span class="sig-paren">(</span><em>alignment=False</em>, <em>ref=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.Alignments.reduce_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Function reduces alignments which contain columns that are marked to be                 ignored by the user.</p>
<p class="rubric">Notes</p>
<p>This function changes the data only internally: All alignments are
checked as to whether they contain data that should be ignored. If this
is the case, the alignments are then reduced, and stored in a specific
item of the alignment string. If the method doesn&#8217;t find any instances
for reduction, it still makes the copies of the alignments in order to
guarantee that the alignments with with we want to work are at the same
place in the dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.align.sca.MSA">
<em class="property">class </em><code class="descclassname">lingpy.align.sca.</code><code class="descname">MSA</code><span class="sig-paren">(</span><em>infile</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.MSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><code class="xref py py-class docutils literal"><span class="pre">lingpy.align.multiple.Multiple</span></code></a></p>
<p>Basic class for carrying out multiple sequence alignment analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>infile</strong> : file</p>
<blockquote>
<div><p>A file in <code class="docutils literal"><span class="pre">msq</span></code>-format or <code class="docutils literal"><span class="pre">msa</span></code>-format.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate, whether neighboring vowels should be merged into
diphtongs, or whether they should be kept separated during the
analysis.</p>
</div></blockquote>
<p><strong>comment</strong> : char (default=&#8217;#&#8217;)</p>
<blockquote>
<div><p>The comment character which, inserted in the beginning of a line,
prevents that line from being read.</p>
</div></blockquote>
<p><strong>normalize</strong> : bool (default=True)</p>
<blockquote class="last">
<div><p>Normalize the alignment, that is, add gap characters for all sequences
which are shorter than the longest sequence, and delete all columns
from the alignment in which only gaps occur.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>There are two possible input formats for this class: the MSQ-format, and
the MSA-format (see <a class="reference internal" href="../tutorial/formats.html#msa-formats"><span class="std std-ref">Multiple Alignments (MSQ and MSA)</span></a> for details). This class directly
inherits all methods of the <a class="reference internal" href="#lingpy.align.multiple.Multiple" title="lingpy.align.multiple.Multiple"><code class="xref py py-class docutils literal"><span class="pre">Multiple</span></code></a>
class.</p>
<p class="rubric">Examples</p>
<p>Get the path to a file from the testset.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">rc</span><span class="p">(</span><span class="s2">&quot;test_path&quot;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;harry.msq&#39;</span>
</pre></div>
</div>
<p>Load the file into the Multiple class.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span> <span class="o">=</span> <span class="n">Multiple</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
<p>Carry out a progressive alignment analysis of the sequences.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mult</span><span class="o">.</span><span class="n">prog_align</span><span class="p">()</span>
</pre></div>
</div>
<p>Print the result to the screen:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="go">w    o    l    -    d    e    m    o    r    t</span>
<span class="go">w    a    l    -    d    e    m    a    r    -</span>
<span class="go">v    -    l    a    d    i    m    i    r    -</span>
</pre></div>
</div>
<dl class="method">
<dt id="lingpy.align.sca.MSA.ipa2cls">
<code class="descname">ipa2cls</code><span class="sig-paren">(</span><em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.MSA.ipa2cls" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve sound-class strings from aligned IPA sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : str (default=&#8217;sca&#8217;)</p>
<blockquote class="last">
<div><p>The sound-class model according to which the sequences shall be
converted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is only useful when an <code class="docutils literal"><span class="pre">msa</span></code>-file with already
conducted alignment analyses was loaded.</p>
</dd></dl>

<dl class="method">
<dt id="lingpy.align.sca.MSA.output">
<code class="descname">output</code><span class="sig-paren">(</span><em>fileformat='msa'</em>, <em>filename=None</em>, <em>sorted_seqs=False</em>, <em>unique_seqs=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.MSA.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileformat</strong> : { &#8220;psa&#8221;, &#8220;msa&#8221;, &#8220;msq&#8221; }</p>
<blockquote>
<div><p>Indicate which data should be written to file. Select between:</p>
<ul class="simple">
<li>&#8220;psa&#8221; &#8211; output of all pairwise alignments in <code class="docutils literal"><span class="pre">psa</span></code>-format,</li>
<li>&#8220;msa&#8221; &#8211; output of the multiple alignment in <code class="docutils literal"><span class="pre">msa</span></code>-format, or</li>
<li>&#8220;msq&#8221; &#8211; output of the multiple sequences in <code class="docutils literal"><span class="pre">msq</span></code>-format.</li>
<li>&#8220;html&#8221; &#8211; output of the multiple alignment in <code class="docutils literal"><span class="pre">html</span></code>-format.</li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote>
<div><p>Select a specific name for the outfile, otherwise, the name of
the infile will be taken by default.</p>
</div></blockquote>
<p><strong>sorted_seqs</strong> : bool</p>
<blockquote>
<div><p>Indicate whether the sequences should be sorted or not (applys only
to &#8216;msa&#8217; and &#8216;msq&#8217; output.</p>
</div></blockquote>
<p><strong>unique_seqs</strong> : bool</p>
<blockquote class="last">
<div><p>Indicate whether only unique sequences should be written to file or
not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingpy.align.sca.PSA">
<em class="property">class </em><code class="descclassname">lingpy.align.sca.</code><code class="descname">PSA</code><span class="sig-paren">(</span><em>infile</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.PSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingpy.align.pairwise.Pairwise" title="lingpy.align.pairwise.Pairwise"><code class="xref py py-class docutils literal"><span class="pre">lingpy.align.pairwise.Pairwise</span></code></a></p>
<p>Basic class for dealing with the pairwise alignment of sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>infile</strong> : file</p>
<blockquote>
<div><p>A file in <code class="docutils literal"><span class="pre">psq</span></code>-format.</p>
</div></blockquote>
<p><strong>merge_vowels</strong> : bool (default=True)</p>
<blockquote>
<div><p>Indicate, whether neighboring vowels should be merged into
diphtongs, or whether they should be kept separated during the
analysis.</p>
</div></blockquote>
<p><strong>comment</strong> : char (default=&#8217;#&#8217;)</p>
<blockquote class="last">
<div><p>The comment character which, inserted in the beginning of a line,
prevents that line from being read.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>In order to read in data from text files, two different file formats can be
used along with this class: the PSQ-format, and the PSA-format (see
<a class="reference internal" href="../tutorial/formats.html#psa-formats"><span class="std std-ref">Pairwise Alignments (PSQ and PSA)</span></a> for details). This class inherits the methods of the
<a class="reference internal" href="#lingpy.align.pairwise.Pairwise" title="lingpy.align.pairwise.Pairwise"><code class="xref py py-class docutils literal"><span class="pre">Pairwise</span></code></a> class.</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="5%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>taxa</td>
<td>list</td>
<td>A list of tuples containing the taxa of all sequence pairs.</td>
</tr>
<tr class="row-even"><td>seqs</td>
<td>list</td>
<td>A list of tuples containing all sequence pairs.</td>
</tr>
<tr class="row-odd"><td>tokens</td>
<td>list</td>
<td>A list of tuples containing all sequence pairs in a tokenized form.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lingpy.align.sca.PSA.output">
<code class="descname">output</code><span class="sig-paren">(</span><em>fileformat='psa'</em>, <em>filename=None</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.PSA.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the results of the analyses to a text file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fileformat</strong> : { &#8216;psa&#8217;, &#8216;psq&#8217; }</p>
<blockquote>
<div><p>Indicate which data should be written to file. Select between:</p>
<ul class="simple">
<li>&#8216;psa&#8217; &#8211; output of all pairwise alignments in <code class="docutils literal"><span class="pre">psa</span></code>-format,</li>
<li>&#8216;psq&#8217; &#8211; output of the multiple sequences in <code class="docutils literal"><span class="pre">psq</span></code>-format.</li>
</ul>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote class="last">
<div><p>Select a specific name for the outfile, otherwise, the name of
the infile will be taken by default.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingpy.align.sca.SCA">
<code class="descclassname">lingpy.align.sca.</code><code class="descname">SCA</code><span class="sig-paren">(</span><em>infile</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.SCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Method returns alignment objects depending on input file or input data.</p>
<p class="rubric">Notes</p>
<p>This method checks for the type of an alignment object and returns an
alignment object of the respective type.</p>
</dd></dl>

<dl class="function">
<dt id="lingpy.align.sca.get_consensus">
<code class="descclassname">lingpy.align.sca.</code><code class="descname">get_consensus</code><span class="sig-paren">(</span><em>msa</em>, <em>gaps=False</em>, <em>taxa=False</em>, <em>classes=False</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#lingpy.align.sca.get_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a consensus string of a given MSA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>msa</strong> : {c{list} ~lingpy.align.multiple.Multiple}</p>
<blockquote>
<div><p>Either an MSA object or an MSA matrix.</p>
</div></blockquote>
<p><strong>gaps</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>If set to c{True}, return the gap positions in the consensus.</p>
</div></blockquote>
<p><strong>taxa</strong> : {c{list} bool} (default=False)</p>
<blockquote>
<div><p>If <em>tree</em> is chosen as a parameter, specify the taxa in order of the aligned
strings.</p>
</div></blockquote>
<p><strong>classes</strong> : c{bool} (default=False)</p>
<blockquote>
<div><p>Specify whether sound classes shall be used to calculate the consensus.</p>
</div></blockquote>
<p><strong>model</strong> : ~lingpy.data.model.Model</p>
<blockquote>
<div><p>A sound class model according to which the IPA strings shall be
converted to sound-class strings.</p>
</div></blockquote>
<p><strong>local</strong> : { c{bool}, &#8220;peaks&#8221;, &#8220;gaps&#8221; }(default=False)</p>
<blockquote>
<div><p>Specify whether local pre-processing should be applied to the data. If
set to c{peaks}, the average alignment score of each column is taken as
reference to remove low-scoring columns from the alignment. If set to
&#8220;gaps&#8221;, the columns with the highest proportion of gaps will be
excluded.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cons</strong> : c{str}</p>
<blockquote class="last">
<div><p>A consensus string of the given MSA.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-lingpy.align">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lingpy.align" title="Permalink to this headline">¶</a></h2>
<p>Package provides basic modules for alignment analyses.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/lingpy-logo.svg" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">lingpy.align package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-lingpy.align.multiple">lingpy.align.multiple module</a></li>
<li><a class="reference internal" href="#module-lingpy.align.pairwise">lingpy.align.pairwise module</a></li>
<li><a class="reference internal" href="#module-lingpy.align.sca">lingpy.align.sca module</a></li>
<li><a class="reference internal" href="#module-lingpy.align">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/lingpy.align.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="../index.html">Home</a> |&nbsp;</li>
	<li><a href="../news.html">News</a> |&nbsp;</li>
	<li><a href="../intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="../examples.html">Examples</a> |&nbsp;</li>
	<li><a href="../tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="../docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="modules.html">Reference</a> |&nbsp;</li>
        <li><a href="../download.html">Download </a> </li>

 
      </ul>
    </div>
 <div id="footer" style="align-items:center;padding-top:5px;padding-left:0px;display:flex;justify-content:space-between;">

   <div>
     <a href="http://ssh.mpg.de"><img width="60px" src="../_static/minerva.png" alt="MPG-SSH" /></a>
   </div>
  <div>
    <a href="http://dfg.de/"><img width="80px" src="../_static/dfg_logo_schwarz.jpg" alt="DFG" /></a>
  </div>

  <div style="max-width:300px;">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated
    on May 17, 2016<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">Creative
      Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a> </p>
  </div>

  <div>
    <a href="http://erc.europa.eu/"><img width="80px" src="http://quanthistling.info/theme/qhl/images/logo_erc.png" alt="ERC" /></a>
  </div>
  <div style="max-width:150px;text-align:right;">
    <a href="http://github.com/lingpy/lingpy/">Application source on</a> 
    <a href="https://github.com/"><img width="100px" src="../_static/GitHub_Logo.png" alt="github logo" /></a>
</div>
</div>

  </body>
</html>