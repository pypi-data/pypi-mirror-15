<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Whats New in Version 2.5? &mdash; LingPy</title>
    
    <link rel="stylesheet" href="_static/lingpy.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="LingPy" href="index.html" />
<link rel="stylesheet" type="text/css" href="_static/handheld.css" media="screen and (max-device-width: 720px)" />

  </head>
  <body role="document">
<div style="color: black;background-color: white; font-size: 3.2em; text-align: left; padding: 15px 10px 10px 15px">
LingPy
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="index.html">Home</a> |&nbsp;</li>
	<li><a href="#">News</a> |&nbsp;</li>
	<li><a href="intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="examples.html">Examples</a> |&nbsp;</li>
	<li><a href="tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="reference/modules.html">Reference</a> |&nbsp;</li>
        <li><a href="download.html">Download </a> </li>

 
      </ul>
    </div>

  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="whats-new-in-version-version">
<h1>Whats New in Version 2.5?<a class="headerlink" href="#whats-new-in-version-version" title="Permalink to this headline">¶</a></h1>
<p>Version 2.5 of LingPy introduces a couple of new algorithms, but more importantly, much more
consistency than earlier versions. As of now, LingPy runs in Python 2 and Python 3 across all
major platforms, and we try hard to make sure it stays in this way.</p>
<p>Below, we list some interesting new features shipped along with LingPy 2.5 and which you might
want to test.</p>
<div class="section" id="enhanced-documentation">
<h2>Enhanced Documentation<a class="headerlink" href="#enhanced-documentation" title="Permalink to this headline">¶</a></h2>
<p>You may not notice this directly, but we have enhanced the documentation. New algorithms which have
been added are all fully documented, but in addition, we have finally updated the documentation for
the deep alignment modules, such as <a class="reference internal" href="reference/lingpy.algorithm.cython.html#module-lingpy.algorithm.cython.calign" title="lingpy.algorithm.cython.calign"><code class="xref py py-class docutils literal"><span class="pre">calign</span></code></a> and
<code class="xref py py-class docutils literal"><span class="pre">misc</span></code>. If you want to use these functions to speed up your
alignments, or to create your own algorithms that build on LingPy&#8217;s deep alignment functions, you
should definitely have a look at the additional documentation and some examples which we added.</p>
</div>
<div class="section" id="the-command-line-interface">
<h2>The Command Line Interface<a class="headerlink" href="#the-command-line-interface" title="Permalink to this headline">¶</a></h2>
<p>Version 2.5 introduces a command line interface which remains purely experimental for the
moment, but will be further enhanced in the future in order to enable users to include LingPy in
their pipelines with other programs.</p>
<p>As an example, after installing LingPy on your machine, just open a terminal, and try the
following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ lingpy -h
</pre></div>
</div>
<p>This will show you all basic instructions regarding the usage of the command line interface. The
basic idea here is that we split the commandline into different subtasks:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ lingpy pairwise -h
usage: lingpy pairwise [-h] [--input-file INPUT_FILE]
                     [--output-file OUTPUT_FILE] [--factor FACTOR]
                     [--gop GOP] [--scale SCALE]
                     [--restricted-chars RESTRICTED_CHARS]
                     [--strings STRINGS STRINGS]
                     [--mode {global,local,overlap,dialign}] [--distance]
                     [--method {sca,basic}]
...
</pre></div>
</div>
<p>If you want to align a couple of strings, you can, for example, do the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ lingpy multiple -s woldemort walter waldemar
w    o    l    d    e    m    o    r    t
w    a    l    t    e    -    -    r    -
w    a    l    d    e    m    a    r    -
</pre></div>
</div>
<p>There are many more possibilities, but since this features is still experimental, we did not work
out a full documentation, so for the moment, we recommend to follow the instructions provided by
adding the &#8220;-h&#8221; command to each of the subcommands currently available, when testing this feature.</p>
</div>
<div class="section" id="slowly-saying-goodbye-to-the-alias-system">
<h2>Slowly Saying Goodbye to the Alias System<a class="headerlink" href="#slowly-saying-goodbye-to-the-alias-system" title="Permalink to this headline">¶</a></h2>
<p>The alias-system in LingPy wordlists has lead to some confusion among users. Basically, the idea was
to guarantee a maximum of flexibility. As a result, the flexibility lead to a high degree of
confusion. We should note, however, that most of these aspects are documented, especially in our
tutorial section, and it is recommended for all users and those interested in using LingPy to give
these a proper read.</p>
<p>As of version 2.5, however, we re-arranged the handling to potentially overcome the problem of
namespaces by adding explicit arguments to the main classes for alignments and cognate sets, like
<a class="reference internal" href="reference/lingpy.align.html#lingpy.align.sca.Alignments" title="lingpy.align.sca.Alignments"><code class="xref py py-class docutils literal"><span class="pre">Alignments</span></code></a> and <a class="reference internal" href="reference/lingpy.compare.html#lingpy.compare.lexstat.LexStat" title="lingpy.compare.lexstat.LexStat"><code class="xref py py-class docutils literal"><span class="pre">LexStat</span></code></a>. As of now, you can specify
integral parts of the data by passing how you define your namespace as an argument upon
initialization. For a LexStat analysis, for example, we need to know where we find the following
information and how it should be named:</p>
<ul class="simple">
<li>transcription (usually called &#8220;ipa&#8221;)</li>
<li>segments (usually called &#8220;tokens&#8221;, if not given, it is created from &#8220;transcription&#8221;)</li>
<li>classes (the sound classes, which are usually created from &#8220;segments&#8221;)</li>
<li>langid (language identifiers, which are needed to create the individual segments for each language, usually created)</li>
<li>prostrings (the prosodic strings, distinguishing context, usually created)</li>
<li>numbers (the combination of langid, classes, and prostrings to form unique segment representations for each segment in each language, also the basic value passed to the scoring function)</li>
<li>duplicates (the column in which duplicates are stored, and marked by a 1 for a duplicated entry, that is, an entry which is identical with another entry with a different meaning, usually created)</li>
</ul>
<p>For an Alignments analysis, we need to know:</p>
<ul class="simple">
<li>transcription,</li>
<li>segments, and</li>
<li>alignment (for alignment analyses, the argument where alignments should be stored, created automatically or manually)</li>
</ul>
<p>From now on, you can define your own namespaces by passing those as arguments when loading a
wordlist for a LexStat or an alignment analysis:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lex</span> <span class="o">=</span> <span class="n">LexStat</span><span class="p">(</span><span class="s1">&#39;myfile.tsv&#39;</span><span class="p">,</span> <span class="n">segments</span><span class="o">=</span><span class="s2">&quot;segments&quot;</span><span class="p">,</span> <span class="n">transcription</span><span class="o">=</span><span class="s2">&quot;transcription&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alm</span> <span class="o">=</span> <span class="n">Alignments</span><span class="p">(</span><span class="s1">&#39;myalms.tsv&#39;</span><span class="p">,</span> <span class="n">segments</span><span class="o">=</span><span class="s2">&quot;segments&quot;</span><span class="p">,</span> <span class="n">alignment</span><span class="o">=</span><span class="s2">&quot;myperfectalignment&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This allows for a much greated flexibility and is a first step towards replacing the alias and the
rc-configuration file system in which the namespace was handled previously.</p>
</div>
<div class="section" id="partial-cognate-detection">
<h2>Partial Cognate Detection<a class="headerlink" href="#partial-cognate-detection" title="Permalink to this headline">¶</a></h2>
<p>We present an initial attempt to carry out partial cognate detection and which is shipped along with
LingPy 2.5 and accessible via the <a class="reference internal" href="reference/lingpy.compare.html#lingpy.compare.partial.Partial" title="lingpy.compare.partial.Partial"><code class="xref py py-class docutils literal"><span class="pre">Partial</span></code></a> class which
itself expands the <a class="reference internal" href="reference/lingpy.compare.html#lingpy.compare.lexstat.LexStat" title="lingpy.compare.lexstat.LexStat"><code class="xref py py-class docutils literal"><span class="pre">LexStat</span></code></a> class for automatic cognate
judgments. The main requirement for partial cognate detection is that your data is morphologically
annotated. Morphological annotation will be assumed automatically, if your dataset contains tone
annotations in South-East-Asian style, with superscript or subscript numbers, since in most of these
languages each syllable corresponds to one morpheme. If this is not given, you need to provide
morphological annotations by adding one of the currently accepted symbols for morpheme segmentation.
If you want to know which symbols are currently accepted, you can check with the
<a class="reference internal" href="reference/lingpy.data.html#lingpy.settings.rc" title="lingpy.settings.rc"><code class="xref py py-class docutils literal"><span class="pre">rc</span></code></a> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="n">rc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;morpheme_separators&#39;</span><span class="p">)</span>
<span class="go">&#39;◦+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;word_separators&#39;</span><span class="p">)</span>
<span class="go">&#39;_#&#39;</span>
</pre></div>
</div>
<p>As you can see, we currently support two morpheme separators and two word separators. Note, however,
that there is no difference in treatment when using the new method for partial cognate detection:
whether your data uses the morpheme separators or the word separators should not make a difference,
since LingPy will split all words in your data into their smallest units.</p>
<p>In order to test partial cognate detection, you can use a very small test set shipped with the
LingPy test suite:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.compare.partial</span> <span class="k">import</span> <span class="n">Partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.tests.util</span> <span class="k">import</span> <span class="n">test_data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">part</span> <span class="o">=</span> <span class="n">Partial</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;partial_cognates.tsv&#39;</span><span class="p">),</span> <span class="n">segments</span><span class="o">=</span><span class="s2">&quot;segments&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">part</span><span class="o">.</span><span class="n">partial_cluster</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;sca&#39;</span><span class="p">,</span> <span class="n">cluster_method</span><span class="o">=</span><span class="s1">&#39;upgma&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="s1">&#39;partial_ids&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]:</span>
<span class="go">        print(k, &#39;&#39;.join(part[k, &#39;segments&#39;]), &#39; &#39;.join([str(x) for x in part[k, &#39;partial_ids&#39;]]))</span>
<span class="gp">...</span>
<span class="go">1 xu²⁴+ni⁵⁵ 3 4</span>
<span class="go">2 xu²⁴ni⁴⁴ 3 4</span>
<span class="go">3 xu³⁵+ni⁵⁵ 3 4</span>
<span class="go">4 bu¹³li⁵³ 1 2</span>
<span class="go">5 bu¹³ 1</span>
</pre></div>
</div>
<p>Note that now, if you provide both partial cognate sets and segmented words, you can even align all
partial cognate sets in separation. The only current restriction here is that you need to follow our
namespace for fuzzy cognates as defined in the <cite>wordlist.rc</cite> (but you can modify it accordingly by
just creating your own <cite>wordlist.rc</cite> and passing it as an extra argument):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alm</span> <span class="o">=</span> <span class="n">Alignments</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;partial_cognates.tsv&#39;</span><span class="p">),</span><span class="n">ref</span><span class="o">=</span><span class="s1">&#39;partial_ids&#39;</span><span class="p">,</span> <span class="n">segments</span><span class="o">=</span><span class="s1">&#39;segments&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alm</span><span class="o">.</span><span class="n">align</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">SCA</span><span class="p">(</span><span class="n">alm</span><span class="o">.</span><span class="n">msa</span><span class="p">[</span><span class="s1">&#39;partial_ids&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">x    u    ³⁵</span>
<span class="go">x    u    ²⁴</span>
<span class="go">x    u    ²⁴</span>
<span class="go">x    u    ²⁴</span>
</pre></div>
</div>
<p>The basic idea behind this change is a different handling of etymological dictionaries within the
<a class="reference internal" href="reference/lingpy.basic.html#lingpy.basic.wordlist.Wordlist" title="lingpy.basic.wordlist.Wordlist"><code class="xref py py-class docutils literal"><span class="pre">Wordlist</span></code></a> class: Earlier, an etymological dictionary was just a
transposed representation in which the cognate identifier was the key of a dictionary, and a list of values in order
of the languages linked to the words, with a zero indicating absence of values:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">part</span> <span class="o">=</span> <span class="n">Partial</span><span class="p">(</span><span class="n">test_data</span><span class="p">(</span><span class="s1">&#39;partial_cognates.tsv&#39;</span><span class="p">),</span> <span class="n">segments</span><span class="o">=</span><span class="s2">&quot;segments&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etd1</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">get_etymdict</span><span class="p">(</span><span class="s1">&#39;partialids2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etd2</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">get_etymdict</span><span class="p">(</span><span class="s1">&#39;pcogsets&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">etd1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">etd2</span><span class="p">)</span>
<span class="go">13, 19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etd1</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">dict_keys([&#39;7 8 9&#39;, &#39;18 16 17&#39;, &#39;3 4&#39;, &#39;18 16&#39;, &#39;13&#39;, &#39;12&#39;, &#39;1 1&#39;, &#39;5 6&#39;, &#39;1 2&#39;, &#39;14 15&#39;, &#39;12 10 11&#39;, &#39;12 10&#39;, &#39;1&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etd2</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">dict_keys([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])</span>
</pre></div>
</div>
<p>In the case of <code class="docutils literal"><span class="pre">etd1</span></code>, we reference the column &#8220;partialcogids2&#8221; for the creation of the
etymological dictionary, but for this column, there is no instruction in LingPy, no column type
defined in the wordlist-rc file. As a result, its values are interpreted as strings, and the
etymological dictionary that is created has strings as keys. In the case of the second column, the
column &#8220;pcogsets&#8221; is a reserved namespace for partial cognate sets, and all values are converted to
lists of integers. If the Wordlist class (or its descendants) creates an etymdict and detects a list
type instead of a string type or an integer type, it automatically assumes that the data is &#8220;fuzzy&#8221;,
and it creates a different etymdict in which each item of the list of integer ids is transformed
into the key of the dictionary.</p>
<p>Note that even if this sounds a bit confusing in the moment, we will try to further improve the
handling of this feature. This is closely related to the general change of wordlist handling in
LingPy using the wordlist-rc files, which we will try to replace with a more consistent system.</p>
</div>
<div class="section" id="evaluation-methods">
<h2>Evaluation methods<a class="headerlink" href="#evaluation-methods" title="Permalink to this headline">¶</a></h2>
<p>If you want to test how well a partial cognate detection analysis works, there is a special function
for evaluation, and its usage is idential with the usage of the classical
<a class="reference internal" href="reference/lingpy.evaluate.html#lingpy.evaluate.acd.bcubes" title="lingpy.evaluate.acd.bcubes"><code class="xref py py-class docutils literal"><span class="pre">bcubes</span></code></a> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.evaluate.acd</span> <span class="k">import</span> <span class="n">partial_bcubes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">partial_bcubes</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="s2">&quot;partialid&quot;</span><span class="p">,</span> <span class="s2">&quot;pcogsets&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Furthermore, you can test n-point average precision (<a class="reference internal" href="reference/lingpy.evaluate.html#lingpy.evaluate.acd.npoint_ap" title="lingpy.evaluate.acd.npoint_ap"><code class="xref py py-class docutils literal"><span class="pre">npoint_ap</span></code></a>) on string similarity measures, which we
implemented following the suggestion by <code class="docutils literal"><a class="reference external" href="http://lingulist.de/evobib/evobib.php?key=Kondrak2002"><span class="pre">Kondrak2002</span></a></code>. The n-point average precision is a
measure that can be used to test how well string similarities or distances distinguish cognates from
non-cognates, and it is therefore useful for the evaluation or the training of different string
similarity measures:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy.evaluate.acd</span> <span class="k">import</span> <span class="n">npoint_ap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lingpy</span> <span class="k">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">word_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;harry&quot;</span><span class="p">,</span> <span class="s2">&quot;gari&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;walter&quot;</span><span class="p">,</span> <span class="s2">&quot;woldemort&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;harry&quot;</span><span class="p">,</span> <span class="s2">&quot;walter&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;gari&quot;</span><span class="p">,</span> <span class="s2">&quot;woldemort&quot;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">edit_dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">word_pairs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cogs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># these are our cognates for all word pairs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">npoint_ap</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">cogs</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</div>
<div class="section" id="what-s-next">
<h2>What&#8217;s Next?<a class="headerlink" href="#what-s-next" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="docu/index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="download.html">Download</a></li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/lingpy-logo.svg" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Whats New in Version 2.5?</a><ul>
<li><a class="reference internal" href="#enhanced-documentation">Enhanced Documentation</a></li>
<li><a class="reference internal" href="#the-command-line-interface">The Command Line Interface</a></li>
<li><a class="reference internal" href="#slowly-saying-goodbye-to-the-alias-system">Slowly Saying Goodbye to the Alias System</a></li>
<li><a class="reference internal" href="#partial-cognate-detection">Partial Cognate Detection</a></li>
<li><a class="reference internal" href="#evaluation-methods">Evaluation methods</a></li>
<li><a class="reference internal" href="#what-s-next">What&#8217;s Next?</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/news.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
	<li><a href="index.html">Home</a> |&nbsp;</li>
	<li><a href="#">News</a> |&nbsp;</li>
	<li><a href="intro.html">Introduction</a> |&nbsp;</li>
	<li><a href="examples.html">Examples</a> |&nbsp;</li>
	<li><a href="tutorial/index.html">Tutorial</a> |&nbsp;</li>
	<li><a href="docu/index.html">Documentation</a> |&nbsp;</li>
	<li><a href="reference/modules.html">Reference</a> |&nbsp;</li>
        <li><a href="download.html">Download </a> </li>

 
      </ul>
    </div>
 <div id="footer" style="align-items:center;padding-top:5px;padding-left:0px;display:flex;justify-content:space-between;">

   <div>
     <a href="http://ssh.mpg.de"><img width="60px" src="_static/minerva.png" alt="MPG-SSH" /></a>
   </div>
  <div>
    <a href="http://dfg.de/"><img width="80px" src="_static/dfg_logo_schwarz.jpg" alt="DFG" /></a>
  </div>

  <div style="max-width:300px;">
    <p style="font-size:70%">Created using <a href="http://sphinx-doc.org">Sphinx</a>. Last updated
    on May 17, 2016<br>
      This work is licensed under a <a rel="license"
        href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">Creative
      Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
    <p>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img alt="Creative Commons License" style="border-width:0;width:100px;"
		    src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a> </p>
  </div>

  <div>
    <a href="http://erc.europa.eu/"><img width="80px" src="http://quanthistling.info/theme/qhl/images/logo_erc.png" alt="ERC" /></a>
  </div>
  <div style="max-width:150px;text-align:right;">
    <a href="http://github.com/lingpy/lingpy/">Application source on</a> 
    <a href="https://github.com/"><img width="100px" src="_static/GitHub_Logo.png" alt="github logo" /></a>
</div>
</div>

  </body>
</html>