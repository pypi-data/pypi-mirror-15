from __future__ import absolute_import, division, print_function, unicode_literals

import os
import shutil
import six

import json

from contextlib import contextmanager

from stone.data_type import (
    DataType,
    Float32,
    Float64,
    Int32,
    Int64,
    UInt32,
    UInt64,
    is_boolean_type,
    is_bytes_type,
    is_list_type,
    is_string_type,
    is_struct_type,
    is_timestamp_type,
    is_union_type,
    is_numeric_type,
    is_nullable_type,
    is_user_defined_type,
    is_void_type,
)
from stone.generator import CodeGenerator
from stone.target.swift_helpers import (
    fmt_class,
    fmt_func,
    fmt_obj,
    fmt_var,
)

base = """
/* Autogenerated. Do not edit. */

import Foundation
"""


class SwiftGenerator(CodeGenerator):

    def _docf(self, tag, val):
        if tag == 'route':
            return fmt_func(val)
        elif tag == 'field':
            if '.' in val:
                cls, field = val.split('.')
                return ('{} in {}'.format(fmt_var(field),
                        fmt_class(cls)))
            else:
                return fmt_var(val)
        elif tag in ('type', 'val', 'link'):
            return val
        else:
            import pdb
            pdb.set_trace()
            return val

    def generate(self, api):
        rsrc_folder = os.path.join(os.path.dirname(__file__), 'swift_rsrc')
        self.logger.info('Copying StoneSerializers.swift to output folder')
        shutil.copy(os.path.join(rsrc_folder, 'StoneSerializers.swift'),
                    os.path.join(self.target_folder_path, 'Source'))

        self.logger.info('Copying StoneValidators.swift to output folder')
        shutil.copy(os.path.join(rsrc_folder, 'StoneValidators.swift'),
                    os.path.join(self.target_folder_path, 'Source'))

        self.logger.info('Copying Client.swift to output folder')
        shutil.copy(os.path.join(rsrc_folder, 'Client.swift'),
                    os.path.join(self.target_folder_path, 'Source'))

        jazzy_cfg_path = os.path.join(rsrc_folder, 'jazzy.json')
        with open(jazzy_cfg_path) as jazzy_file:
            jazzy_cfg = json.load(jazzy_file)

        for namespace in api.namespaces.values():

            ns_class = fmt_class(namespace.name)
            path = os.path.join('Source', '{}.swift'.format(ns_class))
            with self.output_to_relative_path(path):
                self._generate_base_namespace_module(namespace)
            jazzy_cfg['custom_categories'][1]['children'].append(ns_class)

            if len(namespace.routes) > 0:
                path = os.path.join('Source', '{}Routes.swift'.format(ns_class))
                with self.output_to_relative_path(path):
                    self._generate_routes(namespace)
                jazzy_cfg['custom_categories'][0]['children'].append(ns_class + 'Routes')

        with self.output_to_relative_path('.jazzy.json'):
            self.emit_raw(json.dumps(jazzy_cfg, indent=2)+'\n')

        client_path = os.path.join('Source', 'DropboxClient.swift')
        dropbox_raw_path = os.path.join(rsrc_folder, 'DropboxClient-raw.swift')

        with open(dropbox_raw_path) as raw_client, self.output_to_relative_path(client_path):
            self._generate_bound_client(api, raw_client)

    # At this point I've basically given up trying to separate out the
    # generated code from the generator. They are tightly coupled and stone 
    # supplies no reasoanble interface for avoiding that.
    #
    # So this code makes deep assumptions about the layout of concrete syntax
    # and the general structure of handwritten code in the Dropbox-specific
    # swift SDK. Eventually we should work on separating out the generated code
    # more cleanly from the rest of the SDK.
    def _generate_bound_client(self, api, raw_client):

        self.emit_raw(base)
        self.emit('import Alamofire')

        self.emit('/// The client for the API. Call routes using'
                   'the namespaces inside this object.')
        with self.block('public class DropboxClient : StoneClient'):
            self.emit_raw(raw_client.read())
            namespace_fields = []
            for namespace in api.namespaces.values():
                if len(namespace.routes) > 0:
                    namespace_fields.append((namespace.name,
                                              fmt_class(namespace.name)))

            my_props = [('accessToken', 'DropboxAccessToken')]
            super_props = [('manager', 'Manager'), ('backgroundManager', 'Manager'), ('baseHosts', '[String : String]')]

            for var, typ in namespace_fields:
                self.emit('/// Routes within the {} namespace.'
                          'See {}Routes for details.'.format(var, typ))
                self.emit('public var {} : {}Routes!'.format(var, typ))

            with self.function_block('public init', self._func_args(my_props + super_props)):
                for var, typ in my_props:
                    self.emit('self.{} = {}'.format(var, var))
                self.emit('super.init({})'.format(self._func_args((name,name)
                                                                  for name, _ in super_props)))

                for var, typ in namespace_fields:
                    self.emit('self.{} = {}Routes(client: self)'.format(var, typ))

    def _generate_base_namespace_module(self, namespace):
        self.emit_raw(base)

        self.emit('/**')
        self.emit('    Datatypes and serializers for the {} namespace'.format(namespace.name))
        self.emit('*/')
        with self.block('public class {}'.format(fmt_class(namespace.name))):
            for data_type in namespace.linearize_data_types():
                if is_struct_type(data_type):
                    self._generate_struct_class(namespace, data_type)
                elif is_union_type(data_type):
                    self._generate_union_type(namespace, data_type)

    # generation helper methods

    @contextmanager
    def function_block(self, func, args, return_type=None):
        signature = '{}({})'.format(func, args)
        if return_type:
            signature += ' -> {}'.format(return_type)
        with self.block(signature):
            yield

    def _func_args(self, args_list, newlines=False, force_first=False):
        out = []
        first = True
        for k, v in args_list:
            if first and force_first and '=' not in v:
                k = "{} {}".format(k, k)
            if v is not None:
                out.append('{}: {}'.format(k, v))
            first = False
        sep = ', '
        if newlines:
            sep += '\n' + self.make_indent()
        return sep.join(out)

    @contextmanager
    def class_block(self, thing, protocols=None):
        protocols = protocols or []
        extensions = []

        if isinstance(thing, DataType):
            name = self.class_data_type(thing)
            if thing.parent_type:
                extensions.append(self._swift_type_mapping(thing.parent_type))
        elif isinstance(thing, six.text_type):
            name = thing
        else:
            raise TypeError("trying to generate class block for unknown type %r" % thing)

        extensions.extend(protocols)

        extend_suffix = ': {}'.format(', '.join(extensions)) if extensions else ''

        with self.block('public class {}{}'.format(name, extend_suffix)):
            yield

    @contextmanager
    def serializer_block(self, data_type):
        with self.class_block(self.class_data_type(data_type)+'Serializer',
                              protocols=['JSONSerializer']):
            self.emit("public init() { }")
            yield

    @contextmanager
    def serializer_func(self, data_type):
        with self.function_block('public func serialize',
                                 args=self._func_args([('value', self.class_data_type(data_type))]),
                                 return_type='JSON'):
            yield

    @contextmanager
    def deserializer_func(self, data_type):
        with self.function_block('public func deserialize',
                                 args=self._func_args([('json', 'JSON')]),
                                 return_type=self.class_data_type(data_type)):
            yield

    def class_data_type(self, data_type):
        return fmt_class(data_type.name)

    def _serializer_obj(self, data_type):
        if is_nullable_type(data_type):
            data_type = data_type.data_type
            nullable = True
        else:
            nullable = False
        if is_list_type(data_type):
            ret = 'ArraySerializer({})'.format(
                self._serializer_obj(data_type.data_type))
        elif is_string_type(data_type):
            ret = 'Serialization._StringSerializer'
        elif is_timestamp_type(data_type):
            ret = 'NSDateSerializer("{}")'.format(data_type.format)
        elif is_boolean_type(data_type):
            ret = 'Serialization._BoolSerializer'
        elif is_bytes_type(data_type):
            ret = 'Serialization._NSDataSerializer'
        elif is_void_type(data_type):
            ret = 'Serialization._VoidSerializer'
        elif isinstance(data_type, Int32):
            ret = 'Serialization._Int32Serializer'
        elif isinstance(data_type, Int64):
            ret = 'Serialization._Int64Serializer'
        elif isinstance(data_type, UInt32):
            ret = 'Serialization._UInt32Serializer'
        elif isinstance(data_type, UInt64):
            ret = 'Serialization._UInt64Serializer'
        elif isinstance(data_type, Float32):
            ret = 'Serialization._FloatSerializer'
        elif isinstance(data_type, Float64):
            ret = 'Serialization._DoubleSerializer'
        elif is_user_defined_type(data_type):
            ret = "{}.{}Serializer()".format(fmt_class(data_type.namespace.name),
                                             self.class_data_type(data_type))

        if nullable:
            ret = 'NullableSerializer({})'.format(ret)

        return ret

    def _swift_type_mapping(self, data_type, serializer=False):
        suffix = 'Serializer' if serializer else ''
        if is_nullable_type(data_type):
            data_type = data_type.data_type
            nullable = True
        else:
            nullable = False
        if is_list_type(data_type):
            ret = 'Array{}<{}>'.format(
                suffix,
                self._swift_type_mapping(data_type.data_type, serializer)
            )
            suffix = ''
        elif is_string_type(data_type):
            ret = 'String'
        elif is_timestamp_type(data_type):
            ret = 'NSDate'
        elif is_boolean_type(data_type):
            ret = 'Bool'
        elif is_bytes_type(data_type):
            ret = 'NSData'
        elif is_void_type(data_type):
            ret = 'Void'
        elif isinstance(data_type, Int32):
            ret = 'Int32'
        elif isinstance(data_type, Int64):
            ret = 'Int64'
        elif isinstance(data_type, UInt32):
            ret = 'UInt32'
        elif isinstance(data_type, UInt64):
            ret = 'UInt64'
        elif isinstance(data_type, Float32):
            ret = 'Float'
        elif isinstance(data_type, Float64):
            ret = 'Double'
        elif is_user_defined_type(data_type):
            ret = '{}.{}'.format(fmt_class(data_type.namespace.name),
                                 self.class_data_type(data_type))
        ret += suffix
        if nullable:
            if serializer:
                ret = 'NullableSerializer<{}>'.format(ret)
            else:
                ret += '?'

        return ret

    def _determine_validator_type(self, data_type):
        if is_nullable_type(data_type):
            data_type = data_type.data_type
            nullable = True
        else:
            nullable = False
        if is_list_type(data_type):
            item_validator = self._determine_validator_type(data_type.data_type)
            if item_validator:
                v = "arrayValidator({})".format(
                    self._func_args([
                        ("minItems", data_type.min_items),
                        ("maxItems", data_type.max_items),
                        ("itemValidator", item_validator),
                    ])
                )
            else:
                return None
        elif is_numeric_type(data_type):
            v = "comparableValidator({})".format(
                self._func_args([
                    ("minValue", data_type.min_value),
                    ("maxValue", data_type.max_value),
                ])
            )
        elif is_string_type(data_type):
            pat = data_type.pattern if data_type.pattern else None
            if isinstance(pat, six.text_type):
                pat = pat.encode('unicode_escape')
            v = "stringValidator({})".format(
                self._func_args([
                    ("minLength", data_type.min_length),
                    ("maxLength", data_type.max_length),
                    ("pattern", '"{}"'.format(pat) if pat else None),
                ])
            )
        else:
            return None

        if nullable:
            v = "nullableValidator({})".format(v)
        return v

    def _generate_struct_class(self, namespace, data_type):
        self.emit('/**')
        if data_type.doc:
            doc = self.process_doc(data_type.doc, self._docf)
        else:
            doc = 'The {} struct'.format(self.class_data_type(data_type))
        self.emit_wrapped_text(doc, prefix='    ', width=120)
        self.emit('*/')
        protocols = []
        if not data_type.parent_type:
            protocols.append('CustomStringConvertible')

        with self.class_block(data_type, protocols=protocols):
            for field in data_type.fields:
                fdoc = self.process_doc(field.doc, self._docf) if field.doc else 'Undocumented'
                self.emit_wrapped_text(fdoc, prefix='/// ', width=120)
                self.emit('public let {} : {}'.format(
                    fmt_var(field.name),
                    self._swift_type_mapping(field.data_type),
                ))
            self._generate_struct_init(namespace, data_type)

            decl = 'public var' if not data_type.parent_type else 'public override var'

            with self.block('{} description : String'.format(decl)):
                cls = self.class_data_type(data_type)+'Serializer'
                self.emit(
                    'return "\(prepareJSONForSerialization({}().serialize(self)))"'.format(cls)
                )

        self._generate_struct_class_serializer(namespace, data_type)

    def _struct_init_args(self, data_type, namespace=None):
        args = []
        for field in data_type.all_fields:
            name = fmt_var(field.name)
            value = self._swift_type_mapping(field.data_type)
            field_type = field.data_type
            if is_nullable_type(field_type):
                field_type = field_type.data_type
                nullable = True
            else:
                nullable = False

            if field.has_default:
                if is_union_type(field_type):
                    default = '.{}'.format(fmt_class(field.default.tag_name))
                else:
                    default = fmt_obj(field.default)
                value += ' = {}'.format(default)
            elif nullable:
                value += ' = nil'
            arg = (name, value)
            args.append(arg)
        return args

    def _generate_struct_init(self, namespace, data_type):
        # init method
        args = self._struct_init_args(data_type)
        if data_type.parent_type and not data_type.fields:
            return
        with self.function_block('public init', self._func_args(args)):
            for field in data_type.fields:
                v = fmt_var(field.name)
                validator = self._determine_validator_type(field.data_type)
                if validator:
                    self.emit('{}(value: {})'.format(validator, v))
                self.emit('self.{} = {}'.format(v, v))
            if data_type.parent_type:
                func_args = [(fmt_var(f.name),
                              fmt_var(f.name))
                             for f in data_type.parent_type.all_fields]
                self.emit('super.init({})'.format(self._func_args(func_args)))

    def _generate_enumerated_subtype_serializer(self, namespace, data_type):
        with self.block('switch value'):
            for tags, subtype in data_type.get_all_subtypes_with_tags():
                assert len(tags) == 1, tags
                tag = tags[0]
                tagvar = fmt_var(tag)
                self.emit('case let {} as {}:'.format(
                    tagvar,
                    self._swift_type_mapping(subtype)
                ))

                with self.indent():
                    with self.block('for (k,v) in Serialization.getFields({}.serialize({}))'.format(
                        self._serializer_obj(subtype), tagvar
                    )):
                        self.emit('output[k] = v')
                    self.emit('output[".tag"] = .Str("{}")'.format(tag))
            self.emit('default: fatalError("Tried to serialize unexpected subtype")')

    def _generate_struct_base_class_deserializer(self, namespace, data_type):
            args = []
            for field in data_type.all_fields:
                var = fmt_var(field.name)
                self.emit('let {} = {}.deserialize(dict["{}"] ?? .Null)'.format(
                    var,
                    self._serializer_obj(field.data_type),
                    field.name,
                ))

                args.append((var, var))
            self.emit('return {}({})'.format(
                self.class_data_type(data_type),
                self._func_args(args)
            ))

    def _generate_enumerated_subtype_deserializer(self, namespace, data_type):
        self.emit('let tag = Serialization.getTag(dict)')
        with self.block('switch tag'):
            for tags, subtype in data_type.get_all_subtypes_with_tags():
                assert len(tags) == 1, tags
                tag = tags[0]
                self.emit('case "{}":'.format(tag))
                with self.indent():
                    self.emit('return {}.deserialize(json)'.format(self._serializer_obj(subtype)))
            self.emit('default:')
            with self.indent():
                if data_type.is_catch_all():
                    self._generate_struct_base_class_deserializer(namespace, data_type)
                else:
                    self.emit('fatalError("Unknown tag \\(tag)")')

    def _generate_struct_class_serializer(self, namespace, data_type):
        with self.serializer_block(data_type):
            with self.serializer_func(data_type):
                if not data_type.all_fields:
                    self.emit('let output = [String : JSON]()')
                else:
                    intro = 'var' if data_type.has_enumerated_subtypes() else 'let'
                    self.emit("{} output = [ ".format(intro))
                    for field in data_type.all_fields:
                        self.emit('"{}": {}.serialize(value.{}),'.format(
                            field.name,
                            self._serializer_obj(field.data_type),
                            fmt_var(field.name)
                        ))
                    self.emit(']')

                    if data_type.has_enumerated_subtypes():
                        self._generate_enumerated_subtype_serializer(namespace, data_type)
                self.emit('return .Dictionary(output)')
            with self.deserializer_func(data_type):
                with self.block("switch json"):
                    self.emit("case .Dictionary(let dict):")
                    with self.indent():
                        if data_type.has_enumerated_subtypes():
                            self._generate_enumerated_subtype_deserializer(namespace, data_type)
                        else:
                            self._generate_struct_base_class_deserializer(namespace, data_type)
                    self.emit("default:")
                    with self.indent():
                        self.emit('fatalError("Type error deserializing")')

    def _format_tag_type(self, namespace, data_type):
        if is_void_type(data_type):
            return ''
        else:
            return '({})'.format(self._swift_type_mapping(data_type))

    def _generate_union_type(self, namespace, data_type):
        self.emit('/**')
        if data_type.doc:
            doc = self.process_doc(data_type.doc, self._docf)
        else:
            doc = 'The {} union'.format(self.class_data_type(data_type))
        self.emit_wrapped_text(doc, prefix='    ', width=120)
        self.emit('*/')

        class_type = self.class_data_type(data_type)
        with self.block('public enum {}: CustomStringConvertible'.format(class_type)):
            all_fields = self._populate_all_fields(data_type)
            for field in all_fields:
                typ = self._format_tag_type(namespace, field.data_type)
                if field.doc:
                    self.emit('/**')
                    self.emit_wrapped_text(self.process_doc(field.doc, self._docf),
                                           prefix='    ', width=120)
                    self.emit('*/')
                self.emit('case {}{}'.format(fmt_class(field.name),
                                                  typ))
            with self.block('public var description : String'):
                cls = class_type+'Serializer'
                self.emit(
                    'return "\(prepareJSONForSerialization({}().serialize(self)))"'.format(cls)
                )

        self._generate_union_serializer(data_type)

    def _tag_type(self, data_type, field):
        return "{}.{}".format(
            self.class_data_type(data_type),
            fmt_class(field.name)
        )

    def _generate_union_serializer(self, data_type):
        with self.serializer_block(data_type):
            with self.serializer_func(data_type), self.block('switch value'):
                all_fields = self._populate_all_fields(data_type)
                for field in all_fields:
                    field_type = field.data_type
                    case = '.{}{}'.format(fmt_class(field.name),
                                         '' if is_void_type(field_type) else '(let arg)')
                    self.emit('case {}:'.format(case))

                    with self.indent():
                        if is_void_type(field_type):
                            self.emit('var d = [String : JSON]()')
                        elif (is_struct_type(field_type) and
                                not field_type.has_enumerated_subtypes()):
                            self.emit('var d = Serialization.getFields({}.serialize(arg))'.format(
                                self._serializer_obj(field_type)))
                        else:
                            self.emit('var d = ["{}": {}.serialize(arg)]'.format(
                                field.name,
                                self._serializer_obj(field_type)))
                        self.emit('d[".tag"] = .Str("{}")'.format(field.name))
                        self.emit('return .Dictionary(d)')
            with self.deserializer_func(data_type):
                with self.block("switch json"):
                    self.emit("case .Dictionary(let d):")
                    with self.indent():
                        self.emit('let tag = Serialization.getTag(d)')
                        with self.block('switch tag'):
                            all_fields = self._populate_all_fields(data_type)
                            for field in all_fields:
                                field_type = field.data_type
                                self.emit('case "{}":'.format(field.name))

                                tag_type = self._tag_type(data_type, field)
                                with self.indent():
                                    if is_void_type(field_type):
                                        self.emit('return {}'.format(tag_type))
                                    else:
                                        if (is_struct_type(field_type) and
                                                not field_type.has_enumerated_subtypes()):
                                            subdict = 'json'
                                        else:
                                            subdict = 'd["{}"] ?? .Null'.format(field.name)

                                        self.emit('let v = {}.deserialize({})'.format(
                                            self._serializer_obj(field_type), subdict
                                        ))
                                        self.emit('return {}(v)'.format(tag_type))
                            self.emit('default:')
                            with self.indent():
                                if data_type.catch_all_field:
                                    self.emit('return {}'.format(
                                        self._tag_type(data_type, data_type.catch_all_field)
                                    ))
                                else:
                                    self.emit('fatalError("Unknown tag \(tag)")')
                    self.emit("default:")
                    with self.indent():

                        self.emit('fatalError("Failed to deserialize")')

    def _populate_all_fields(self, data_type):
        result = []
        curr = data_type

        # loops until top-most parent is reached -- each
        # generation's attributes are recorded
        while curr.parent_type:
            # add types to `result` in the correct order,
            # i.e. grandparent attr -> parent attr -> child attr
            result = curr.parent_type.all_fields + result
            curr = curr.parent_type

        result += data_type.fields

        return result

    def _generate_routes(self, namespace):
        ns_class = fmt_class(namespace.name)
        self.emit('/// Routes for the {} namespace'.format(namespace.name))
        with self.block('public class {}Routes'.format(ns_class)):
            self.emit('public let client : StoneClient')
            args = [('client', 'StoneClient')]
            with self.function_block('init', self._func_args(args)):
                self.emit('self.client = client')

            for route in namespace.routes:
                self._generate_route(namespace, route)

    STYLE_MAPPING = {
        None: 'Rpc',
        'upload': 'Upload',
        'download': 'Download',
    }

    def _get_route_args(self, namespace, route):
        arg_type = self._swift_type_mapping(route.arg_data_type)
        if is_struct_type(route.arg_data_type):
            arg_list = self._struct_init_args(route.arg_data_type, namespace=namespace)
            doc_list = [(fmt_var(f.name), self.process_doc(f.doc, self._docf))
                        for f in route.arg_data_type.fields if f.doc]
        else:
            arg_list = [] if is_void_type(route.arg_data_type) else [('request', arg_type)]
            doc_list = []
        return arg_list, doc_list

    def _emit_route(self, namespace, route, extra_args=None, extra_docs=None):
        arg_list, doc_list = self._get_route_args(namespace, route)
        extra_args = extra_args or []
        extra_docs = extra_docs or []

        arg_type = self._swift_type_mapping(route.arg_data_type)
        func_name = fmt_func(route.name)

        self.emit('/**')
        if route.doc:
            route_doc = self.process_doc(route.doc, self._docf)
        else:
            route_doc = 'The {} route'.format(func_name)
        self.emit_wrapped_text(route_doc, prefix='    ', width=120)
        self.emit()
        for name, doc in doc_list + extra_docs:
            if not doc:
                doc = 'Undocumented'
            self.emit_wrapped_text('- parameter {}: {}'.format(name, doc), prefix='    ', width=120)
        self.emit()
        self.emit_wrapped_text(' - returns: Through the response callback, the caller will ' +
                               'receive a `{}` object on success or a `{}` object on ' +
                               'failure.'.format(
                                   self._swift_type_mapping(route.result_data_type),
                                   self._swift_type_mapping(route.error_data_type)),
                              prefix='    ', width=120)
        self.emit('*/')
        route_type = self.STYLE_MAPPING[route.attrs.get('style')]

        rtype = self._swift_type_mapping(route.result_data_type,
                                         serializer=True)
        etype = self._swift_type_mapping(route.error_data_type,
                                         serializer=True)

        host_ident = route.attrs.get('host', 'meta')
        func_args = [
            ('client', 'self.client'),
            ('host', '"'+host_ident+'"'),
            ('route', '"/{}/{}"'.format(namespace.name, route.name)),
            ('params', '{}.serialize({})'.format(
                self._serializer_obj(route.arg_data_type),
                '' if is_void_type(route.arg_data_type) else 'request')),
            ('responseSerializer', self._serializer_obj(route.result_data_type)),
            ('errorSerializer', self._serializer_obj(route.error_data_type)),
        ]

        for name, typ, value in extra_args:
            arg_list.append((name, typ))
            func_args.append((name, value))

        with self.function_block('public func {}'.format(func_name),
                                 args=self._func_args(arg_list, force_first=True),
                                 return_type='Stone{}Request<{}, {}>'.format(route_type,
                                                                               rtype,
                                                                               etype)):
            if is_struct_type(route.arg_data_type):
                args = [(name, name) for name, _ in self._struct_init_args(route.arg_data_type)]
                self.emit('let request = {}({})'.format(arg_type, self._func_args(args)))

            self.emit('return Stone{}Request({})'.format(route_type, self._func_args(func_args)))

    def _generate_upload_route_bindings(self, namespace, route):
        for case, typ in (('.Data', 'NSData'),
                                ('.File', 'NSURL'),
                                ('.Stream', 'NSInputStream')):
            extra_args = [("body", typ, "{}(body)".format(case))]
            extra_docs = [("body", "The file to upload, as an {} object".format(typ))]

            self._emit_route(namespace, route, extra_args, extra_docs)

    def _generate_download_route_bindings(self, namespace, route):
        extra_args = [(
            'destination', '(NSURL, NSHTTPURLResponse) -> NSURL', 'destination',
        ), (
            'overwrite', 'Bool = false', 'overwrite',
        )]
        extra_docs = [(
            'destination',
            'A closure used to compute the destination, '
            + 'given the temporary file location and the response'
        ), (
            'overwrite',
            'A boolean to set behavior in the event of a naming conflict. `True` will '
            + 'overwrite conflicting file at destination. `False` will take no action (but '
            + 'if left unhandled in destination closure, an NSError will be thrown).'
        )]

        self._emit_route(namespace, route, extra_args, extra_docs)

    def _generate_route(self, namespace, route):
        route_type = route.attrs.get('style')
        if route_type == 'upload':
            self._generate_upload_route_bindings(namespace, route)
        elif route_type == 'download':
            self._generate_download_route_bindings(namespace, route)
        else:
            self._emit_route(namespace, route)
