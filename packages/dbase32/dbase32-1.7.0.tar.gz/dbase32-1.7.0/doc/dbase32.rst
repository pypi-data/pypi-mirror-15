:mod:`dbase32` API
==================

.. py:module:: dbase32
    :synopsis: base32-encoding with a sorted-order alphabet (for databases)


The core :mod:`dbase32` API consists of just six functions:

    * For encoding and decoding, there is :func:`db32enc()` and :func:`db32dec()`

    * For validation, there is :func:`isdb32()` and :func:`check_db32()`

    * :func:`random_id()` generates Dbase32 encoded random IDs

    * :func:`time_id()` generates random IDs that will sort by timestamp



Tutorial
--------

Encode a ``bytes`` instance with :func:`db32enc()`:

>>> from dbase32 import db32enc
>>> db32enc(b'binary foo')
'FCNPVRELI7J9FUUI'

Decode the resulting ``str`` instance with :func:`db32dec()`:

>>> from dbase32 import db32dec
>>> db32dec('FCNPVRELI7J9FUUI')
b'binary foo'

:func:`db32dec()` can also directly decode UTF-8 encoded ``bytes``:

>>> db32dec(b'FCNPVRELI7J9FUUI')
b'binary foo'

Use :func:`isdb32()` to test whether you have a valid Dbase32 encoded ID.  It
will return ``True`` if the ID is valid:

>>> from dbase32 import isdb32
>>> isdb32('FCNPVRELI7J9FUUI')
True

And will return ``False`` if the ID contains invalid characters:

>>> isdb32('FCNPVRELI7J9FUUZ')
False

Or will also return ``False`` if the ID is the wrong length:

>>> isdb32('FCNPVRELI7J9FUU')
False

You can likewise use :func:`check_db32()` to validate an ID.  It will return
``None`` if the ID is valid:

>>> from dbase32 import check_db32
>>> check_db32('FCNPVRELI7J9FUUI')

And will raise a ``ValueError`` if the ID contains invalid characters:

>>> check_db32('FCNPVRELI7J9FUUZ')  # doctest: -IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
ValueError: invalid Dbase32: 'FCNPVRELI7J9FUUZ'

Or will also raise a ``ValueError`` if the ID is the wrong length:

>>> check_db32('FCNPVRELI7J9FUU')  # doctest: -IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
  ...
ValueError: len(text) is 15, need len(text) % 8 == 0

When you don't need the decoded ID, it's faster to validate with
:func:`isdb32()` or :func:`check_db32()` than to validate with :func:`db32dec()`
and throw away the needlessly decoded value.

Use :func:`random_id()` to generate a Dbase32 encoded random ID.  By default it
returns a 120-bit (15-byte) ID, which will be 24 characters in length when
Dbase32 encoded:

>>> from dbase32 import random_id
>>> random_id()  # doctest: +SKIP
'UGT6U75VTJL8IRBBPRFONKOQ'

The *numbytes* keyword argument defaults to ``15``, but you can override this
to get an ID of a different length.  For example, you might want to create a
well-formed 240-bit (30-byte) `Dmedia`_ file ID for unit testing, which will be
48 characters in length when Dbase32 encoded:

>>> random_id(30)  # doctest: +SKIP
'AU8HC68B9IC6AY6B3NHWOGCI9VK4MTOUSFLWRD7TLQBC56MN'

:func:`random_id()` gets its random data from ``os.urandom()``.  This:

>>> _id = random_id(15)

Is equivalent to this:

>>> import os
>>> _id = db32enc(os.urandom(15))

Although note that the C implementation of :func:`random_id()` is faster than
the above because it does everything internally with no back-and-forth between
Python and C.

Lastly, use :func:`time_id()` to generate random IDs that will sort according to
their Unix timestamp with a one second granularity.

Similar to :func:`random_id()`, :func:`time_id()` returns a 120-bit (15-byte)
ID, which will be 24 characters in length when Dbase32 encoded.  The difference
is the first 4 bytes contain the Unix timestamp (32-bit unsigned big endian),
and the remaining 11 bytes are from ``os.urandom()``.

If you don't provide the *timestamp* argument, it will be automatically
generated by calling ``time.time()``:

>>> time_id()  # doctest: +SKIP
'DBFL77QDNXTGB7GB3JB9YCCK'

Or you can provide your own timestamp, for example to use a timestamp already
generated for another purpose:

>>> time_id(1234567890)  # doctest: +SKIP
'C9E38NQ89VDDM5DAI8NGWGN5'



Well-formed IDs
---------------

Dbase32 is not designed to encode arbitrary data.  Instead, it's designed only
to encode well-formed IDs like those used in `Dmedia`_ and `Novacut`_.

Unlike standard `RFC-3548 Base32`_ encoding, Dbase32 does *not* support
padding.  The binary data must always be a multiple of 40 bits (5 bytes) in
length.

Well-formed *data* to be encoded must meet the following condition::

    5 <= len(data) <= 60 and len(data) % 5 == 0

If this condition isn't met, :func:`db32enc()` will raise a ``ValueError``.

In addition to only containing letters in :data:`DB32ALPHABET`, well-formed
*text* to be decoded must meet the following condition::

    8 <= len(text) <= 96 and len(text) % 8 == 0

If this condition isn't met, both :func:`db32dec()` and :func:`check_db32()`
will raise a ``ValueError``.  Likewise, if this condition isn't met,
:func:`isdb32()` will return ``False``.



Functions
---------

.. function:: db32enc(data)

    Encode *data* as Dbase32 text.

    A ``str`` instance is returned:

    >>> db32enc(b'Bytes')
    'BCVQBSEM'

    *data* must be a ``bytes`` instance that meets the following condition::

        5 <= len(data) <= 60 and len(data) % 5 == 0

    If the above condition is not met, a ``ValueError`` is raised.


.. function:: db32dec(text)

    Decode Dbase32 *text*.

    A ``bytes`` instance is returned:

    >>> db32dec('BCVQBSEM')
    b'Bytes'

    *text* must be a ``str`` or ``bytes`` instance that meets the following
    condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If the above condition is not met, or if *text* contains any letters not
    in :data:`DB32ALPHABET`, a ``ValueError`` is raised.


.. function:: isdb32(text)

    Return ``True`` if *text* contains a valid Dbase32 encoded ID.

    >>> isdb32('39AYA9AY')
    True
    >>> isdb32('27AZ27AZ')
    False

    This function will only return ``True`` if *text* contains only letters
    in :data:`DB32ALPHABET`, and if *text* meets following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    Otherwise, ``False`` is returned.


.. function:: check_db32(text)

    Raise a ``ValueError`` if *text* is not a valid Dbase32 encoded ID.

    This function will raise a ``ValueError`` if *text* contains any letters
    that are not in :data:`DB32ALPHABET`.  For example:

    >>> check_db32('39AYA9AY')
    >>> check_db32('39AY27AZ')  # doctest: -IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32: '39AY27AZ'

    This function will likewise raise a ``ValueError`` if *text* doesn't meet
    the following condition::

        8 <= len(text) <= 96 and len(text) % 8 == 0

    If *text* is a valid Dbase32 ID, this function returns ``None``.


.. function:: random_id(numbytes=15)

    Return a Dbase32 encoded random ID.

    By default, a 120-bit (15-byte) ID is returned, which will be 24
    characters in length when Dbase32 encoded:

    >>> random_id()  # doctest: +SKIP
    'XM4OINLIPO6VVF549TWYNK89'

    If provided, *numbytes* must be an ``int`` such that::

        5 <= numbytes <= 60 and numbytes % 5 == 0

    The random data is from ``os.urandom()``.


.. function:: time_id(timestamp=-1)

    Return a Dbase32 encoded random ID that will sort according to timestamp.

    These IDs will sort in ascending order according to the Unix timestamp, with
    a one second granularity.

    Similar to :func:`random_id()`, this function returns a 120-bit (15-byte)
    ID, which will be 24 characters in length when Dbase32 encoded.

    The difference is the first 4 bytes of this ID are the time since the Unix
    Epoch in seconds, truncated a 32-bit unsigned integer (which wont overflow
    till the year 2106).  The remaining 11 bytes are from ``os.urandom()``.

    This function is aimed at event logging and similar scenarios where it's
    handy for the IDs to sort chronologically.

    If you provide the optional *timestamp* kwarg, that timestamp will be used.
    Otherwise the timestamp is built by calling ``time.time()``.



.. _path-functions:

Path Functions
--------------

Dbase32 :ref:`version-1.7` introduced two functions to the stable API that test whether some
untrusted input is a valid Dbase32 ID and, if valid, construct a file-system or
URL path from it. (Or if this unstrusted input is not a valid Dbase32 ID, these
functions raise a ``ValueError``.)

These functions can be used to:

    1.  Build an absolute path for accessing files on the filesystem or for
        building URLs

    2.  Build a relative path for accessing files on the filesystem relative to
        an open directory descriptor

For example, :func:`db32_join()` can be used to build an absolute path like
this:

>>> from dbase32 import db32_join
>>> db32_join('/foo', 'bar', '39AY39AY')
'/foo/bar/39AY39AY'

Or a relative path like this:

>>> from dbase32 import db32_join
>>> db32_join('/foo', 'bar', '39AY39AY')
'/foo/bar/39AY39AY'

:func:`db32_join_2()` is similar except that it spits the Dbase32 ID into two
path components joined by a slash, equivalent to::

    '/'.join([untrusted[0:2], untrusted[2:]])

For example:

>>> from dbase32 import db32_join_2
>>> db32_join_2('39AY39AY')
'39/AY39AY'

:func:`db32_join_2()` can likewise be used to construct an absolute path:

>>> db32_join_2('/foo', 'bar', '39AY39AY')
'/foo/bar/39/AY39AY'

Or a relative path with additional parent path components:

>>> db32_join_2('foo', 'bar', '39AY39AY')
'foo/bar/39/AY39AY'

:func:`db32_join_2()` might seem peculiar, but it exactly fits the needs of the
directory and file layout used by the `Dmedia FileStore`_.

On the surface, these functions are similar to `os.path.join()`_, but there are
some key differences that should be noted:

    1.  The Dbase32 join functions are not portable: they always join with a
        ``'/'`` (slash) regardless of the platform; in part this is because
        Windows isn't currently a target of interest, but also because a key
        use case for these functions is building validated URLs, where a ``'/'``
        should always be used regardless of the filesystems conventions of the
        platform

    2.  The Dbase32 join functions do no validation of the *parent* path
        components and have no special logic based on the content of the
        *parent* path components; these functions only validate the final
        *untrusted* argument, ensuring it's a valid Dbase32 ID

For example, ``os.path.join()`` gives you this:

>>> from os import path
>>> path.join('/foo/', '39AY39AY')
'/foo/39AY39AY'

Whereas :func:`db32.join()` gives you this:

>>> db32_join('/foo/', '39AY39AY')
'/foo//39AY39AY'

Although it should be noted that ``os.path.join()`` has a some of curious
behaviors that should raise your security eyebrow when it comes to handling
untrusted input:

>>> path.join('/home', 'user', '/etc', 'ssh')
'/etc/ssh'

The Dbase32 join functions assume that any provided *parent* components are
either safe static values, or values that were already carefully validated.


.. function:: db32_join([parent, ...,] untrusted)

    Join path components, ensuring the final component is a valid Dbase32 ID.

    For example:

    >>> from dbase32 import db32_join
    >>> db32_join('foo', 'XFMIN6NRI84O3IX8DAV5MBTR')
    'foo/XFMIN6NRI84O3IX8DAV5MBTR'

    Similar to :func:`check_db32()`, a ``ValueError`` will be raised if
    *untrusted* is not a valid Dbase32 ID:

    >>> db32_join('foo', '../very/naughty/')
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32: '../very/naughty/'

    Note that unlike :func:`check_db32()`, the *untrusted* argument must always
    be a ``str``.

    .. versionadded:: 1.7


.. function:: db32_join_2([parent, ...,] untrusted)

    Join path components, spitting final Dbase32 argument into two components.

    This function ensures the final argument is a valid Dbase32 ID, then builds
    a path using any provided parent components, plus the first two characters
    of the Dbase32 ID, plus the remaining characters of the Dbase32.

    The *untrusted* argument is itself spit into path components doing something
    like this:

        '/'.join([final[0:2], final[2:]])

    For example:

    >>> from dbase32 import db32_join_2
    >>> db32_join_2('XFMIN6NRI84O3IX8DAV5MBTR')
    'XF/MIN6NRI84O3IX8DAV5MBTR'

    Like :func:`db32_join()`, this function joins together any leading *parent*
    components:

    >>> db32_join_2('/foo', 'bar', 'XFMIN6NRI84O3IX8DAV5MBTR')
    '/foo/bar/XF/MIN6NRI84O3IX8DAV5MBTR'

    Similar to :func:`check_db32()`, a ``ValueError`` will be raised if
    *untrusted* is not a valid Dbase32 ID:

    >>> db32_join_2('/foo', 'bar', '../very/naughty/')
    Traceback (most recent call last):
      ...
    ValueError: invalid Dbase32: '../very/naughty/'

    Note that unlike :func:`check_db32()`, the *untrusted* argument must always
    be a ``str`` instance.

    .. versionadded:: 1.7


Constants
---------

The :mod:`dbase32` module defines several handy constants:

.. data:: using_c_extension

    A flag indicating whether the Dbase32 `C implementation`_ is being used.

    >>> import dbase32
    >>> dbase32.using_c_extension  # doctest: +SKIP
    True

    This will be ``True`` when the ``dbase32._dbase32`` C extension is being
    used, or ``False`` when the ``dbase32._dbase32py`` pure-Python fallback is
    being used.

    For both security and performance reasons, only the `C implementation`_ is
    recommended for production use.  As such, 3rd party software might want to
    use this attribute in their unit tests and/or runtime initialization to
    verify that the Dbase32 C extension is in fact being used.

    Please see :doc:`security` for more details.

    .. versionadded:: 1.4


.. data:: DB32ALPHABET

    A ``str`` containing the Dbase32 alphabet.

    >>> import dbase32
    >>> dbase32.DB32ALPHABET
    '3456789ABCDEFGHIJKLMNOPQRSTUVWXY'

    Note that the Dbase32 alphabet (encoding table) is in ASCII/UTF-8 sorted
    order:

    >>> dbase32.DB32ALPHABET == ''.join(sorted(set(dbase32.DB32ALPHABET)))
    True


.. data:: MAX_BIN_LEN

    Max length of data (in bytes) accepted for encoding.

    >>> import dbase32
    >>> dbase32.MAX_BIN_LEN
    60
    >>> dbase32.MAX_BIN_LEN * 8  # 480 bits
    480

    This constraint is used by :func:`db32enc()`, :func:`random_id()`, and
    :func:`time_id()`.


.. data:: MAX_TXT_LEN

    Max length of text (in characters) accepted for decoding or validation.

    >>> import dbase32
    >>> dbase32.MAX_TXT_LEN
    96
    >>> dbase32.MAX_TXT_LEN * 5 // 8 == dbase32.MAX_BIN_LEN
    True

    This constraint is used by :func:`db32dec()`, :func:`isdb32()`, and
    :func:`check_db32()`.


.. data:: RANDOM_BITS

    Default size (in bits) of the *decoded* ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_BITS
    120


.. data:: RANDOM_BYTES

    Default size (in bytes) of the *decoded* ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_BYTES
    15
    >>> dbase32.RANDOM_BYTES * 8 == dbase32.RANDOM_BITS
    True


.. data:: RANDOM_B32LEN

    Default size (in characters) of the ID generated by :func:`random_id()`.

    >>> import dbase32
    >>> dbase32.RANDOM_B32LEN
    24
    >>> dbase32.RANDOM_B32LEN * 5 // 8 == dbase32.RANDOM_BYTES
    True



.. _`Dbase32`: https://launchpad.net/dbase32
.. _`RFC-3548 Base32`: https://tools.ietf.org/html/rfc4648
.. _`Novacut`: https://launchpad.net/novacut
.. _`Dmedia`: https://launchpad.net/dmedia
.. _`Dmedia FileStore`: https://launchpad.net/filestore
.. _`C implementation`: http://bazaar.launchpad.net/~dmedia/dbase32/trunk/view/head:/dbase32/_dbase32.c
.. _`os.path.join()`: https://docs.python.org/3/library/os.path.html#os.path.join

