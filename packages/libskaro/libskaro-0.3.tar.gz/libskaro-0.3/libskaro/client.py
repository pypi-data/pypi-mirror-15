"""Abstract class for writing chat clients."""

import websockets
import cbor
import hmac
import hashlib
import logging
from libskaro import (event, helpers)

logger = logging.getLogger(__name__)


class Client:
    """Instant messaging client for skaro.

    Maintains a connections to the server, emits events, and accepts commands.
    """

    def __init__(self, url):
        """Create new client.

        :arg string url:
            the url address of the server.
        """

        self.url = url
        self.ws = None

        self.token = ""
        self.sent_requests = dict()
        self.thread = None
        self.user = None
        self.active = False
        self.authorized = False

        self.on_connect = event.Event('Client.on_connect')
        self.on_register_type = event.Event('Client.on_register_type')
        self.on_received_session_id = event.Event(
            'Client.on_received_session_id')
        self.on_received_user_data = event.Event(
            'Client.on_received_user_data')
        self.on_get_contacts = event.Event('Client.on_get_contacts')
        self.on_get_history = event.Event('Client.on_get_history')
        self.on_send_message = event.Event('Client.on_send_message')
        self.on_show_message = event.Event('Client.on_show_message')
        self.on_info = event.Event('Client.on_info')
        self.on_error = event.Event('Client.on_error')

    async def connect(self):
        """This function is called to connect to the server and
        runs all the time, until the connection to the server is actively.
        """

        async with websockets.connect(self.url) as ws:
            self.ws = ws
            self.active = True
            while True:
                await self._received_message(await ws.recv())

    ##########################################################################
    # Registration / Authorization
    ##########################################################################

    async def _check_connection(self, data):
        """It called immediately after the connection and
        contains a token used for authentication.

        :arg dict data:
            received information.
        """

        await self.on_connect.fire()
        self.token = data.get('token')

    async def authorize(self, data):
        """The authorization request of the user.

        The client uses the stored token (see. _check_connection) and
        hashes it user password as the key for the HMAC-SHA512 hashing.

        The resulting hash it sends as a user password in the message
        to the server type authorize

        :arg dict data:
            {'login': __YOUR_USERNAME__, 'password': __YOUR_PASSWORD__}
        """

        data['type'] = "authorize"
        # Instead of a password, put a hash of the token+password.
        # The server will do the same and thus will validate the password
        data['password'] = hmac.new(key=bytes(data['password'], 'utf-8'),
                                    msg=bytes(self.token, 'utf-8'),
                                    digestmod=hashlib.sha512).hexdigest()
        data['on_request'] = helpers.request_id(self)
        await self.__write_client__(data)
        self.sent_requests[data.get('on_request')] = data

    async def _authorize_on_request(self, data):
        """The success of the operation defined by the field 'status' and
        depends on whether coincided: the hash sent by the client,
        and the hash generated by the server on
        the same algorithm as that of the client.

        Thus hashes coincide only with the same hash key -
        the user's password, but the password
        over the communication channel is not transmitted.

        :arg dict data:
            received information.
        """

        request = self.sent_requests.get(data.get('id'))
        if request is not None and data is not None:
            if data.get('status')[:3] == "200":
                # Performs initial operations for newly logged-on user
                await self._init_user(data)
            else:
                await self._info(data, request.get('type'))
            self.sent_requests.pop(data.get('id'))

    async def register_type(self):
        """Requests a registration type on the server:
        open, by invitation, closed.
        """

        data = dict()
        data['type'] = "register_type"
        data['on_request'] = helpers.request_id(self)
        await self.__write_client__(data)
        self.sent_requests[data.get('on_request')] = data

    async def _register_type_on_request(self, data):
        """The answer to the query 'register_type'

        :arg dict data:
            received information.
        """

        request = self.sent_requests.get(data.get('id'))
        if request is not None and data is not None:
            if (data.get('status') is not None and
                    data.get('status')[:3] == "200"):
                await self.on_register_type.fire(data.get('register_type'))
            else:
                await self._info(data, request.get('type'))
            self.sent_requests.pop(data.get('id'))

    async def register(self, form, register_type):
        pass

    async def session_restore(self, sid):
        """Tries to restore the broken session.
        In the result of the authorization (event 'on_received_user_data')
        we received the session identifier (SID), which is used in this query.
        The session can be restored, if the gap was no more than 5 minutes.

        :arg string sid:
            the session identifier (SID).
        """

        data = dict()
        data['type'] = "session_restore"
        data['sid'] = sid
        data['on_request'] = helpers.request_id(self)
        await self.__write_client__(data)
        self.sent_requests[data.get('on_request')] = data

    async def _session_restore_on_request(self, data):
        """If successful, it performs the initialization procedure of the user.

        :arg dict data:
            received information.
        """

        request = self.sent_requests.get(data.get('id'))
        if request is not None and data is not None:
            if (data.get('status') is not None and
                    data.get('status')[:3] == "200"):
                # Performs initial operations for newly logged-on user
                await self._init_user(data)
            else:
                await self._info(data, request.get('type'))
            self.sent_requests.pop(data.get('id'))

    ##########################################################################
    # Work with contacts
    ##########################################################################

    async def get_contacts(self):
        """Requests a list and information about all the users whom we know.
        """

        data = dict()
        data['type'] = "get_contacts"
        data['on_request'] = helpers.request_id(self)
        await self.__write_client__(data)
        self.sent_requests[data.get('on_request')] = data

    async def _get_contacts_on_request(self, data):
        """The answer to the query 'register_type'

        :arg dict data:
            received information.
        """

        request = self.sent_requests.get(data.get('id'))
        if request is not None and data is not None:
            if (data.get('status') is not None and
                    data.get('status')[:3] == "200"):

                await self.on_get_contacts.fire(data.get('data'))
            else:
                await self._info(data, request.get('type'))
            self.sent_requests.pop(data.get('id'))

    # TODO:
    # add_contact - Добавление пользователя в список контактов.
    #
    # del_contact - Удаление пользователя из нашего списка контактов.
    #
    # search_contacts - Поиск пользователей по части их логина.

    ##########################################################################
    # Work with users
    ##########################################################################

    async def get_user_data(self, login, add_contact, load_if_empty):
        pass

    # TODO:
    # (от сервера) changed_user_data - Вызывается, если кто-то,
    # кого мы знаем, поменял публичные данные.

    ##########################################################################
    # Work with messages
    ##########################################################################

    async def get_history(self, login):
        """Requests a message history with another user.
        """

        data = dict()
        data['type'] = "get_history"
        data['login'] = login
        data['on_request'] = helpers.request_id(self)
        await self.__write_client__(data)
        self.sent_requests[data.get('on_request')] = data

    async def _get_history_on_request(self, data):
        """The answer to the query 'register_type'

        :arg dict data:
            received information.
        """

        request = self.sent_requests.get(data.get('id'))
        if request is not None and data is not None:
            if (data.get('status') is not None and
                    data.get('status')[:3] == "200"):

                await self.on_get_history.fire(
                    request.get('login'), data.get('history'))
            else:
                await self._info(data, request.get('type'))
            self.sent_requests.pop(data.get('id'))

    async def send_message(self, login, message, marker=None):
        """Produces the sending of a message to another user.

        :arg string login:
            the login of the user for whom the message is intended.

        :arg string message:
            a message that will be sent.

        :arg int marker:
            a temporary marker messages
        """

        data = dict()
        data['type'] = "send_message"
        data['to'] = login
        data['body'] = message
        data['on_request'] = helpers.request_id(self)
        await self.__write_client__(data)

        if marker is not None:
            data['marker'] = marker
        self.sent_requests[data.get('on_request')] = data

    async def _send_message_on_request(self, data):
        """The answer to the query 'register_type'

        :arg dict data:
            received information.
        """

        request = self.sent_requests.get(data.get('id'))
        if request is not None and data is not None:
            if (data.get('status') is not None and
                    data.get('status')[:3] == "200"):

                await self.on_send_message.fire(
                    request.get('to'),
                    data,
                    request.get('marker')
                )
            else:
                await self._info(data, request.get('type'))
            self.sent_requests.pop(data.get('id'))

    async def _show_message(self, data):
        """It called when someone sends you a new message.

        :arg dict data:
            received information.
        """

        # If the message belongs to us
        if data.get('from').get('login') == self.user.get('login'):
            dialog = data.get('to')
        # Otherwise, this message is not FROM us, and TO us.
        else:
            if data.get('from').get('in_conference') is None:
                dialog = data.get('from').get('login')
            else:
                dialog = data.get('from').get('in_conference')
        data['status'] = "ok"
        await self.on_show_message.fire(dialog, data)

    ##########################################################################
    # Work with your data
    ##########################################################################

    # update_my_data

    ##########################################################################
    # Other
    ##########################################################################

    async def _info(self, data, on_request=None):
        """The server wants to communicate some information.

        :arg dict data:
            received information.
        :arg string on_request:
            the type of query that reports information.
        """
        await self.on_info.fire(data.get('info'), on_request)

    async def _error(self, data):
        """The server reports the error occurred.

        :arg dict data:
            received information.
        """
        await self.on_error.fire(data.get('info'))

    async def _received_message(self, data):
        """Called if there was a new response from the server.
        Depending on the type of response determines what to do with it.

        :arg bytearray data:
            received information.
        """
        data = cbor.loads(data)
        logger.debug("Received from server: {}".format(data))

        method = data.get('type')
        if method == "request":
            method = data.get('for') + "_on_request"

        try:
            await getattr(self, "_" + method)(data)
        except AttributeError:
            logger.debug("Received a message of unknown type")

    async def _init_user(self, data):
        """Initializes user (operation performs the primary input into account).

        :arg dict data:
            received information.
        """

        self.token = None
        self.authorized = True
        await self.on_received_session_id.fire(data.get('session_id'))

        self.user = data.get('user')
        await self.on_received_user_data.fire(self.user)

    async def __write_client__(self, data):
        """Sending a data to the server.

        :arg dict data:
            transmitted information.
        """

        logger.debug("Sending to server: {}".format(data))
        data = cbor.dumps(data)

        if self.active:
            await self.ws.send(data)
        else:
            logger.debug("The connection was closed")
