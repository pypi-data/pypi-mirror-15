"""This module handles the parsing of name lines.


Details on what has to go here:
https://bitbucket.org/HenningTimm/dna_handler/issues/139/name-line-parser
"""

cpdef tuple split_casava_line(bytes line):
    """Split a Casava Style illumina fastq header.
    
    Note:
        http://support.illumina.com/content/dam/illumina-support/documents/myillumina/feb3d85a-6c63-467d-aa86-18abd5e880f3/casava_ug_15011196b.pdf
        p. 50

    Arguments:
        line (bytes): A casava style header line.

    Returns: 
        tuple: Containing all information of the casava line. These are

            - instrument (bytes)
            - run (int)
            - flowcell_id (int)
            - lane (int)
            - tile (int)
            - cluster_x (int)
            - cluster_y (int)
            - pair_member (int)
            - filtered (bool)
            - control_nr (int)
            - index_sequence (bytes)
            - additional information after the casava line (empty most of the time) (list)
    """
    cdef:
        bytes hardware_info
        bytes instrument, run, flowcell_id, lane, tile, cluster_x, cluster_y
        bytes mate_pair_info
        bytes pair_member, filtered, control_number, index_sequence
        list additional_info

    hardware_info, mate_pair_info, *additional_info = line.split(b" ", maxsplit=2)

    # check if additional info is present, for example generated by RAGE and if so, split it.
    if additional_info:
        additional_info = additional_info[0].split(b", ")

    instrument, run, flowcell_id, lane, tile, cluster_x, cluster_y = hardware_info.split(b":")
    pair_member, filtered, control_number, index_sequence = mate_pair_info.split(b":")

    #TODO: This should be a named tuple.
    return (
        instrument,
        int(run),
        flowcell_id,
        int(lane),
        int(tile),
        int(cluster_x),
        int(cluster_y),
        int(pair_member),
        True if filtered==b"Y" else False,
        int(control_number),
        index_sequence,
        additional_info,
        )


def peek_for_casava_style(path_fastq_file):
    """Guess the style of the CASAVA line style.

    This refers to  
    """
    fqr = dinopy.FastqReader(path_fastq_file)
    first_nameline = None
    for seq, name, qvs in fqr.reads():
         first_nameline = name
         break
    del(fqr)
    return guess_casava_style(name)


def _test_casava_style_guessing():
    """Test if the guessing of casava line styles works as expected.
    """
    plain_style_read = (b"ACGT", b"@NS500639:6:H3MYMAFXX:1:11101:9262:1124 1:N:0:TAATGC", b"####")
    long_style_read = (b"ACGT", b"@NS500639:6:H3MYMAFXX:1:11101:9262:1124 1:N:0:TAATGCGCTACTTACA", b"####")
    plus_style_read = (b"ACGT", b"@NS500639:6:H3MYMAFXX:1:11101:9262:1124 1:N:0:TAATGCGC+TACTTACA", b"####")
    with dinopy.FastqWriter("/tmp/plain.fastq", force_overwrite=True) as f:
        f.write_reads([plain_style_read]*5)
    with dinopy.FastqWriter("/tmp/long.fastq", force_overwrite=True) as f:
        f.write_reads([long_style_read]*5)
    with dinopy.FastqWriter("/tmp/plus.fastq", force_overwrite=True) as f:
        f.write_reads([plus_style_read]*5)

    guessed_style_plain = peek_for_casava_style("/tmp/plain.fastq")
    guessed_style_long = peek_for_casava_style("/tmp/long.fastq")
    guessed_style_plus = peek_for_casava_style("/tmp/plus.fastq")
    print("plain: {}\nlong: {}\nplus: {}".format(guessed_style_plain, guessed_style_long, guessed_style_plus))
