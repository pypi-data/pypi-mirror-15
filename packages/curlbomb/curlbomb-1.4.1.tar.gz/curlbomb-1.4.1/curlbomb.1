.TH curlbomb 1 2016\-05\-05
.SH SYNOPSIS
 \fBcurlbomb\fR [-h] [-n N] [-p PORT] [-d host[:port]] [-w] [-l] [-q] [-v]
         [--ssh SSH_FORWARD] [--ssl CERTIFICATE] [--pin] [-e]
         [--encrypt-to GPG_ID] [--passphrase] [--survey] [--unwrapped]
         [--client-logging] [--client-quiet] [--mime-type MIME_TYPE] [--pipe]
         [--disable-knock] [--knock KNOCK] [--version]
         {run,put,get,ping,ssh-copy-id} ...


.SH DESCRIPTION

.br

.br
curlbomb is a personal HTTP(s) server for serving one\-time\-use shell scripts.
.br

.br
You know all those docs for the cool and hip software projects that
.br
start out by telling you to install their software in one line, like
.br
this?
.br

.br
    curl http://example.com/install.sh | bash
.br

.br
I call that a curl bomb... I don't know if anyone else does.
.br

.br
*convenient* as hell, but a security and trustability
.br
*nightmare*. Especially since installers usually require root access,
.br
do you trust a random file on the internet with direct access to your
.br
machine?
.br

.br
But I usually try to ask myself this question: is it possible to turn
.br
a *bad* idea into a *good* one, or at the very least a less\-bad idea?
.br
Let's take a look..
.br

.br
curlbomb serves a single file (read from disk or stdin) via HTTP to
.br
the first client to request it, then it shuts down. A command is
.br
printed out that will construct the curl bomb the client needs to run,
.br
which includes a one\-time\-use passphrase (called a knock) that is
.br
required to download the resource. This command is copy/pasted (or
.br
typed) into another shell, on some other computer, which will download
.br
and run the script in one line.
.br

.br
curlbomb has optional (but recommended) integration with OpenSSL to
.br
secure communications. OpenSSH is supported as well, to make it easy
.br
to curlbomb from anywhere on the internet, to anywhere else, through a
.br
proxy server that you can forward the port through.
.br

.br
So does curlbomb measure up to making this a good idea? Decide for yourself:
.br

.br
+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
.br
| Feature/ | Traditional curl bomb  | Using    |
.br
| Problem  |                        | curlbomb |
.br
+==========+========================+==========+
.br
| Convenie | Yup, sure is.          | I think  |
.br
| ce       |                        | so.      |
.br
+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
.br
| Trust    | Is it even SSL? Do you | Self     |
.br
|          | know/trust the URL and | hosted   |
.br
|          | it's author?           | server   |
.br
|          |                        | and SSL  |
.br
|          |                        | verifies |
.br
|          |                        | connecti |
.br
|          |                        | on       |
.br
+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
.br
| Security | Even if you verify the | Self     |
.br
|          | script beforehand,     | hosted   |
.br
|          | `are you sure it       | script,  |
.br
|          | hasn't                 | you're   |
.br
|          | changed? <https://www. | in       |
.br
|          | idontplaydarts.com/201 | control  |
.br
|          | 6/04/detecting\-curl\-pi | of the   |
.br
|          | pe\-bash\-server\-side/>` | contents |
.br
|          | __                     | .        |
.br
+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
.br
| Privacy  | Anyone who knows the   | curlbomb |
.br
|          | URL can download/run.  | requires |
.br
|          | Cannot contain private | a        |
.br
|          | information like       | passphra |
.br
|          | passwords.             | se       |
.br
|          |                        | (knock)  |
.br
|          |                        | and only |
.br
|          |                        | serves a |
.br
|          |                        | file one |
.br
|          |                        | time (by |
.br
|          |                        | default. |
.br
|          |                        | )        |
.br
|          |                        | Optional |
.br
|          |                        | ly       |
.br
|          |                        | gpg      |
.br
|          |                        | encrypt  |
.br
|          |                        | the      |
.br
|          |                        | contents |
.br
|          |                        | of the   |
.br
|          |                        | script.  |
.br
|          |                        | Put      |
.br
|          |                        | sensitiv |
.br
|          |                        | e        |
.br
|          |                        | data     |
.br
|          |                        | like SSH |
.br
|          |                        | keys and |
.br
|          |                        | passphra |
.br
|          |                        | ses      |
.br
|          |                        | into     |
.br
|          |                        | your     |
.br
|          |                        | script   |
.br
|          |                        | as       |
.br
|          |                        | necessar |
.br
|          |                        | y.       |
.br
+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
.br
| Repeatab | Is the script going to | It's     |
.br
| ility    | stay at the same URL   | your     |
.br
|          | forever? Can you       | script,  |
.br
|          | specify any parameters | read     |
.br
|          | or at least a version  | whatever |
.br
|          | number?                | env vars |
.br
|          |                        | you      |
.br
|          |                        | want.    |
.br
|          |                        | You can  |
.br
|          |                        | keep it  |
.br
|          |                        | checked  |
.br
|          |                        | into     |
.br
|          |                        | your own |
.br
|          |                        | git      |
.br
|          |                        | reposito |
.br
|          |                        | ry       |
.br
|          |                        | and      |
.br
|          |                        | serve it |
.br
|          |                        | from     |
.br
|          |                        | anywhere |
.br
|          |                        | anytime. |
.br
+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
.br

.br

.br
curlbomb is well tested, but not intended for heavy automation
.br
work. There are better alternatives to choose from (saltstack,
.br
ansible, puppet, etc.) curlbomb can be used effectively in doing the
.br
front work for setting up these other tools, like copying SSH keys and
.br
installing packages.
.br

.br

.SH EXAMPLES

.br

.br
Serve a script stored in a file:
.br

.br
    curlbomb run /path/to/script
.br
	
.br
This outputs a curl command that you copy and paste into a shell on another
.br
computer:
.br

.br
    KNOCK=nDnXXp8jkZKtbush bash <(curl \-LSs http://192.0.2.100:48690)
.br
	
.br
Once pasted, the script is automatically downloaded and executed.
.br

.br
By default, the client must pass a KNOCK variable that is passed in
.br
the HTTP headers. This is for two reasons:
.br

.br
 * It adds a factor of authentication. Requests without the knock are
.br
   denied.
.br
 * It helps to prevent mistakes, as the knock parameter is randomly
.br
   generated each time curlbomb is run and can only be used once. (See
.br
   \fB\fC\-n 1\fR)
.br

.br
(Astute readers will notice that the KNOCK variable is being fed to
.br
the script that is being downloaded, not into the curl command. That's
.br
because it's really a curlbomb within a curlbomb. The first curl
.br
command downloads a script that includes a second curl command that
.br
*does* require the KNOCK parameter. This nesting allows us to keep the
.br
client command as short as possible and hide some extra
.br
boilerplate. See \fB\fC\-\-unwrapped\fR.)
.br

.br
If you want just the curl, without the bomb, ie. you just want to grab
.br
the script without redirecting it to bash, use \fB\fC\-\-survey\fR. This is
.br
useful for testing the retrieval of scripts without running them.
.br

.br
You can pipe scripts directly into curlbomb:
.br

.br
    echo "pacman \-\-noconfirm \-S openssh && systemctl start sshd" | curlbomb
.br
	
.br
Whenever you pipe data to curlbomb you can omit the \fB\fCrun\fR subcommand,
.br
it's assumed that you want to run a script from stdin.
.br
	
.br
This works in shell scripts too:
.br

.br
    cat <<EOF | curlbomb
.br
    #!/bin/bash
.br
    echo "I'm a script output from another script on another computer"
.br
    EOF
.br

.br
Or type it interactively:
.br

.br
    $ curlbomb run \-
.br
    pkg instll sqlite3
.br
    echo "bad idea, I don't have spollcheck when I typ in the terminal"
.br

.br
(The single dash says to read from stdin, even when nothing is being
.br
piped. Ctrl\-D ends the interactive input.)
.br

.br
The shebang line (#!) is interpreted and automatically changes the
.br
interpreter the client runs, the following example runs the script
.br
with python instead of the default bash:
.br

.br
    cat <<EOF | curlbomb
.br
    #!/usr/bin/env python3
.br
    import this
.br
    print("Hello, from Python!")
.br
    EOF
.br

.br
curlbomb can also transfer files and directories with \fB\fCput\fR and \fB\fCget\fR
.br
subcommands:
.br

.br
    # Recursively copy a directory 
.br
    # (to whatever directory the client is run from):
.br
    curlbomb put ~/.ssh
.br

.br
    # Recursively copy a remote directory to the server
.br
    # (to whatever directory the server is run from)
.br
    curlbomb get /var/log 
.br

.br
    # Recursively copy a directory
.br
    #  \- Specifies the explicit remote destination directory.
.br
    #  \- Environment vars in single quotes are evaluated on the remote end.
.br
    #  \- Excludes some files you may want to keep private.
.br
    curlbomb put ~/.ssh '$HOME' \-\-exclude='*rsa'
.br

.br
The \fB\fCput\fR and \fB\fCget\fR subcommands are just convenience wrappers for
.br
running tar on both ends of the curlbomb pipe. You *could* achieve the
.br
same thing more generically:
.br

.br
    # Copy a local directory to a client, the hard way:
.br
    tar cjh \-C $HOME .ssh | curlbomb run \-c "tar xjv \-f"
.br
    
.br
    # Copy a remote directory to the server, the hard way:
.br
    echo "tar cjh \-C /var log" | curlbomb \-l \-\-client\-quiet | tar xjv
.br

.br
The first example has a \fB\fCrun \-c\fR parameter that tells the client that
.br
we want to interpret the data as being a tar archive rather than a
.br
script. The second example has a \fB\fC\-l\fR parameter that will output the
.br
data received to stdout, in this case piped directly into tar.
.br

.br
\fB\fCSSH tunnel\fR
.br

.br
By default, curlbomb constructs URLs with the IP address of the local
.br
machine. This usually means that clients on another network will be
.br
unable to retrieve anything from curlbomb, unless you have a port
.br
opened up through your firewall (and appropriate use of the \fB\fC\-\-domain\fR
.br
and \fB\fC\-\-port\fR arguments.) As an alternative, curlbomb can be tunneled
.br
through SSH to another host that has the proper port open. For
.br
instance:
.br

.br
    echo "apt\-get install salt\-minion" | curlbomb \-\-ssh user@example.com:8080
.br
	
.br
The above command connects to example.com over SSH (port 22 by
.br
default) and forwards the curlbomb server port to
.br
example.com:8080. The URL that curlbomb prints out will now use the
.br
domain name of the ssh server, instead of the local IP address. The
.br
SSH tunnel is left open for as long as the curlbomb server remains
.br
running. Any user directly on the example.com host will be able to
.br
fetch the resource from localhost:8080. However, by default, SSH does
.br
not open this up to the rest of the world. If you want any client to
.br
be able to connect to example.com:8080 you will need to modify the
.br
sshd_config of the server to allow GatewayPorts:
.br

.br
    # Put this in your /etc/ssh/sshd_config and restart your ssh service:
.br
    GatewayPorts clientspecified
.br

.br
\fB\fCTLS / SSL security\fR
.br

.br
For extra security, you can enable TLS with \fB\fC\-\-ssl\fR:
.br

.br
    echo "PASSWORD=hunter2 run_my_server" | curlbomb \-\-ssl /path/to/cert.pem
.br

.br
The example above is passing a bit of secure information; a
.br
password. Even without TLS, curlbomb secures access with a knock
.br
parameter. For many use\-cases, this is sufficient to secure it, as
.br
curlbombs are short lived and can only be retrieved one time (`\-n
.br
1`). However, the connection itself might be spied on (or even
.br
modified!) through traffic analysis at your ISP or any other router
.br
your connection flows through. Using TLS makes sure this doesn't
.br
happen. 
.br

.br
Note that when the \fB\fC\-\-ssl\fR parameter is combined with the \fB\fC\-\-ssh\fR
.br
parameter, the SSL certificate should be generated for the host
.br
running the SSH server rather than the one running curlbomb. To
.br
prevent having to store the SSL certificate in plain text on your
.br
local machine, the file may be optionally PGP encrypted and curlbomb
.br
will decrypt it only when necessary.
.br

.br
You can also specify the SSL certificate path as a single \fB\fC\-\fR. In this
.br
case, a new self\-signed certificate will be generated and used for
.br
this session only.
.br

.br
\fB\fC\-\-pin\fR can be used to extract the SSL certificate fingerprint and
.br
directly provide it to the client curl command (requires curl >=7.39). 
.br
This avoids having to trust the client's CA root certificate
.br
store, and trusts your certificate explicitly. When generating a
.br
self\-signed certificate with \fB\fC\-\-ssl\fR, the \fB\fC\-\-pin\fR option is turned on
.br
automatically. Pinning adds some extra security benefits, but makes
.br
the client command you have to paste/type much longer than it usually
.br
is, for example:
.br

.br
    $ echo "whoami" | curlbomb \-\-ssl \-
.br
    WARNING:curlbomb.server:No SSL certificate provided, creating a new self\-signed certificate for this session
.br
    Paste this command on the client:
.br
	
.br
      KNOCK=bbxfOV1ToDVhJjAl bash <(curl \-LSs \-k \-\-pinnedpubkey 'sha256//RSkhZc2Qw/j8AxHMLUzipRpegEK9I0BlX7J1I5bcg0Y=' https://192.0.2.100:39817)
.br
	  
.br
\fB\fC\-\-pin\fR is a different kind of trust model then using a certificate
.br
signed by a CA. When you use \fB\fC\-\-pin\fR you are completely bypassing the
.br
root CA certificate store of the client machine and instructing it to
.br
trust your certificate explicitly. This mitigates many
.br
man\-in\-the\-middle type attacks that can happen with TLS, but you still
.br
need to take care that the client command is not modified or
.br
eavesdropped before being pasted into the client.
.br

.br
\fB\fCAliases\fR
.br

.br
By now the curlbomb command might be getting quite long. Once you've
.br
encrypted and stored your SSL certificate, and setup your SSH server,
.br
create an alias for ease of use, for example:
.br

.br
    alias cb=curlbomb \-\-ssl ~/.curlbomb/curlbomb.pem.gpg \-\-ssh user@example.com:22:8080
.br

.br
There's a few more examples in [EXAMPLES.md](EXAMPLES.md)
.br

.br

.SH OPTIONS

.br

.br
    curlbomb [\-h] [\-n N] [\-p PORT] [\-d host[:port]] [\-w] [\-l] [\-q] [\-v]
.br
             [\-\-ssh SSH_FORWARD] [\-\-ssl CERTIFICATE] [\-\-pin] [\-e]
.br
             [\-\-encrypt\-to GPG_ID] [\-\-passphrase] [\-\-survey] [\-\-unwrapped]
.br
             [\-\-client\-logging] [\-\-client\-quiet] [\-\-mime\-type MIME_TYPE]
.br
             [\-\-disable\-knock] [\-\-knock KNOCK] [\-\-version]
.br
             {run,put,get,ping,ssh\-copy\-id} ...
.br
				   
.br
curlbomb has a few subcommands:
.br

.br
 * \fB\fCrun\fR \- run a shell script
.br
 * \fB\fCput\fR \- copy local files/directories to remote system
.br
 * \fB\fCget\fR \- copy remote files/directories to local system
.br
 * \fB\fCping\fR \- wait for a client to finish a task, with optional
.br
   notification command
.br
 * \fB\fCssh\-copy\-id\fR \- copy SSH public keys to the remote authorized_keys
.br
   file
.br
 
.br
If no subcommand is specified, and there is data being piped to stdin,
.br
then the \fB\fCrun\fR subcommand is used implicitly.
.br

.br
\fB\fCThe following arguments apply to all subcommands:\fR
.br

.br
\fB\fC\-n N, \-\-num\-gets N\fR The maximum number of times the script may be
.br
fetched by clients, defaulting to 1. Increasing this may be useful in
.br
certain circumstances, but please note that the same knock parameter
.br
is used for all requests so this is inherently less secure than the
.br
default. Setting this to 0 will allow the resource to be downloaded an
.br
unlimited number of times.
.br

.br
\fB\fC\-p PORT\fR The local TCP port number to use.
.br

.br
\fB\fC\-d host[:port], \-\-domain host[:port]\fR Specify the domain name and
.br
port that is displayed in the URL of the client command. This does not
.br
change where the resource is actually located, use \-\-port or \-\-ssh for
.br
that. This is useful if you are setting up your own port forwards and
.br
need to show an external URL.
.br

.br
\fB\fC\-w, \-\-wget\fR Print wget syntax rather than curl syntax. Useful in the
.br
case where the client doesn't have curl installed. Not compatible with
.br
\fB\fC\-\-log\-\-posts\fR or the \fB\fCput\fR and \fB\fCget\fR subcommands. :(
.br

.br
\fB\fC\-l, \-\-log\-posts\fR Log the client stdout to the server stdout.
.br

.br
\fB\fC\-q, \-\-quiet\fR Be more quiet. Don't print the client curlbomb command.
.br

.br
\fB\fC\-v, \-\-verbose\fR Be more verbose. Turns off \fB\fC\-\-quiet\fR, enables
.br
\fB\fC\-\-log\-posts\fR, and enables INFO level logging within curlbomb.
.br

.br
\fB\fC\-\-ssh SSH_FORWARD\fR Forwards the curlbomb server to a remote port of
.br
another computer through SSH. This is useful to serve curlbombs to
.br
clients on another network without opening up any ports to the machine
.br
running curlbomb. The syntax for SSH_FORWARD is
.br
[user@]host[:ssh_port][:http_port]. The SSH server must have the
.br
GatewayPorts setting turned on to allow remote clients to connect to
.br
this port. See sshd_config(5).
.br

.br
\fB\fC\-\-ssl CERTIFICATE\fR Run the HTTP server with TLS encryption. Provide
.br
the full path to your SSL certificate, which may be PGP encrypted. The
.br
file should contain the entire certificate chain, including the CA
.br
certificate, if any. If the SSL certificate path is specified as \fB\fC\-\fR, a
.br
temporary self\-signed certificate will be generated for the current
.br
curlbomb session and \fB\fC\-\-pin\fR will be turned on implicitly.
.br

.br
\fB\fC\-\-pin\fR (requires curl>=7.39.0) Pin the SSL certificate fingerprint
.br
into the client curl command. This is used to bypass the root CA store
.br
of the client machine, and to tell it exactly what the server's SSL
.br
certificate looks like. This is useful for mitigating
.br
man\-in\-the\-middle attacks, as well as when using self\-signed
.br
certificates. This makes the client command quite a bit longer than
.br
usual.
.br

.br
\fB\fC\-e, \-\-encrypt\fR Encrypt the resource with gpg before serving it to the
.br
client. A randomly generated symmetric passphrase will be printed
.br
below the client command on the server. This passphrase must be input
.br
on the client. You can specify the passphrase to use interactively
.br
with \fB\fC\-\-passphrase\fR. You can use public key encryption if you use
.br
\fB\fC\-\-encrypt\-to\fR
.br

.br
\fB\fC\-\-passphrase\fR Encrypt the resource with a passphrase interactively
.br
asked on server start.
.br

.br
\fB\fC\-\-encrypt\-to GPG_ID\fR Encrypt the resource with the given gpg
.br
identity. Can be specified multiple times to encrypt to multiple
.br
recipients.
.br

.br
\fB\fC\-\-survey\fR Only print the curl (or wget) command. Don't redirect to a
.br
shell command. Useful for testing script retrieval without running
.br
them.
.br

.br
\fB\fC\-\-unwrapped\fR output the full curlbomb command, including all the
.br
boilerplate that curlbomb normally wraps inside of a nested curlbomb.
.br

.br
This parameter is useful when you want to source variables into your
.br
current shell:
.br

.br
    echo "export PATH=/asdf/bin:$PATH" | curlbomb \-c source \-\-unwrapped
.br

.br
Without the \-\-unwrapped option, the client command will not run the
.br
source command directly, but instead a bash script with a source
.br
inside it. This won't work for sourcing environment variables in your
.br
shell, so use \-\-unwrapped when you want to use
.br
source. 
.br

.br
\fB\fC\-\-client\-logging\fR Logs all client output locally on the client to a
.br
file called curlbomb.log
.br

.br
\fB\fC\-\-client\-quiet\fR Quiets the output on the client
.br

.br
\fB\fC\-\-mime\-type MIME_TYPE\fR The mime\-type header to send, by default
.br
"text/plain"
.br

.br
\fB\fC\-\-disable\-knock\fR Don't require a X\-knock HTTP header from the
.br
client. Normally, curlbombs are one\-time\-use and meant to be
.br
copy\-pasted from terminal to terminal. If you're embedding into a
.br
script, you may not know the knock parameter ahead of time and so this
.br
disables that. This is inherently less secure than the default.
.br

.br
\fB\fC\-\-version\fR Print the curlbomb version
.br

.br
\fB\fCRun subcommand\fR
.br

.br
    curlbomb run [\-c COMMAND] [\-\-hash SHA256] [\-\-signature FILE_OR_URL [GPG_ID ...]] [SCRIPT]
.br

.br
Runs a shell script on the remote client.
.br

.br
\fB\fC\-c COMMAND\fR Set the name of the command that the curlbomb is run with
.br
on the client. By default, this is autodected from the first line of
.br
the script, called the shebang (#!). If none can be detected, and one
.br
is not provided by this setting, the fallback of "bash" is used. Note
.br
that curlbomb will still wrap your script inside of bash, even with \fB\fC\-c\fR
.br
specified, so the client command will still show it as running in
.br
bash. The command you specified is put into the wrapped script. See
.br
\fB\fC\-\-unwrapped\fR to change this behaviour.
.br

.br
\fB\fC\-\-hash SHA256\fR Specify the expected SHA\-256 hash of the script and
.br
the server will verify that it actually has that hash before the
.br
server starts. This is useful if you are pipeing a script from
.br
someplace outside of your control, like from the network. This
.br
prevents the server from serving a script other than the version you
.br
were expecting.
.br

.br
\fB\fC\-\-signature FILE_OR_URL [GPG_ID ...]\fR Specify the file or URL
.br
containing the GPG signature for the script. Optionally specify a list
.br
of GPG key identifiers that are allowed to sign the script. If no
.br
GPG_ID is specified, any valid signature from your keyring is
.br
accepted. The script will be checked for a valid signature before the
.br
server starts.
.br

.br
\fB\fCSCRIPT\fR The script or other resource to serve via curlbomb. You can
.br
also leave this blank (or specify '\-') and the resource will be read
.br
from stdin.
.br

.br
Note that the run subcommand is implied if you are pipeing data to
.br
curlbomb. For instance, this command is assumed that the run command
.br
is desired even if not explicitly used:
.br

.br
    echo "./run_server.sh" | curlbomb
.br

.br
Which is equivalent to:
.br

.br
    echo "./run_server.sh" | curlbomb run \-
.br

.br
\fB\fCPut subcommand\fR
.br

.br
    curlbomb put [\-\-exclude=PATTERN] SOURCE [DEST]
.br

.br
Copies file(s) from the local SOURCE path to the remote DEST path. If
.br
a directory is specified, all child paths will be copied recursively.
.br

.br
If DEST path is unspecified, files/directories will be copied to the
.br
working directory of wherever the client was run.
.br

.br
Exclude patterns can be specified like tar(1)
.br

.br
\fB\fCGet subcommand\fR
.br

.br
    curlbomb get [\-\-exclude=PATTERN] SOURCE [DEST]
.br

.br
Copies file(s) from the remote SOURCE path to the local DEST path. If
.br
a directory is specified, all child paths will be copied recursively.
.br

.br
If DEST path is unspecified, files/directories will be copied to the
.br
working directory of wherever curlbomb was run.
.br

.br
Exclude patterns can be specified like tar(1)
.br

.br
\fB\fCPing subcommand\fR
.br

.br
    curlbomb ping [\-m MESSAGE] [\-r RETURN_CODE] [\-\-return\-success]
.br
	              [\-c COMMAND] [\-n]
.br

.br
Serves an empty body resource for the purposes of pinging the server
.br
when the client has finished some task.
.br

.br
\fB\fC\-m\fR sets the message the client will respond with.
.br

.br
\fB\fC\-r\fR sets the return code the client will respond with. This is used
.br
as the main curlbomb return code on the server as well. If \fB\fC\-n\fR > 1,
.br
the last non\-zero return code received is used instead, defaulting to
.br
0.
.br

.br
\fB\fC\-\-return\-success\fR Always return 0, regardless of the return code(s)
.br
received.
.br

.br
\fB\fC\-c COMMAND\fR Run this command for each ping received. You can use the
.br
following placeholders to format ping data: {return_code} and
.br
{message}. {message} is replaced surrounded by quotes, so no need to
.br
do that again in your command.
.br

.br
\fB\fCssh\-copy\-id subcommand\fR
.br

.br
    curlbomb ssh\-copy\-id IDENTITY
.br
	
.br
Copies the given OpenSSH identity file (eg. ~/.ssh/id_rsa.pub) into
.br
the remote ~/.ssh/authorized_keys file.
.br

.br
Of course OpenSSH comes with it's own ssh\-copy\-id program, but I've
.br
never really understood the usefulness of it. The idea of using SSH
.br
keys is to not use crappy passwords, right? But the OpenSSH version of
.br
ssh\-copy\-id requires password authentication (at least temporarily
.br
during the setup process.) So you either have to edit your
.br
sshd_config, turn on \fB\fCPasswordAuthentication\fR, and restart the
.br
service, or you resign yourself to run an insecure sshd all the
.br
time. \fB\fCcurlbomb ssh\-copy\-id\fR is easier and works in more situations.
.br

.br
Another difference in this version is that you must explicity specify
.br
the identity file, whereas the OpenSSH version does some automatic
.br
determination of which key to install. Especially if you maintain
.br
several ssh identities, being explicit seems the more sane thing to do
.br
than try to save some keystrokes and inevitably install the wrong key
.br
on the server.
.br

.SH DISTRIBUTION
 The latest version of curlbomb may be downloaded from https://github.com/EnigmaCurry/curlbomb
.SH AUTHORS
 Ryan McGuire <ryan@enigmacurry.com>